import { Role as Role$1, User as User$1, FieldsUser, SystemMessage, File as File$1, Masquerade, Message, Server as Server$1, FieldsServer, FieldsRole, Channel as Channel$1, MessageSort, Invite as Invite$1, Embed as Embed$1, SendableEmbed, Special, FieldsChannel, Member, FieldsMember, Category as Category$1 } from 'revolt-api';
import { Readable } from 'stream';
import { File as File$2 } from 'node:buffer';
import { Readable as Readable$1 } from 'node:stream';
import { EventEmitter } from 'node:events';
import FormData from 'form-data';

type PartialObject = Partial<{
    _id: string;
} | {
    id: string;
} | {
    _id: {
        user: string;
    };
}>;
/**
 * Represents the base structure for all objects in the client.
 * Provides common functionality such as equality checks, cloning, and patching data.
 */
declare abstract class Base {
    readonly client: client;
    /** The unique identifier for the object. */
    id: string;
    /**
     * Creates a new Base instance.
     *
     * @param {client} client - The client instance.
     */
    constructor(client: client);
    /**
     * Compares this object with another to determine if they are equal.
     *
     * @param {this | null} [obj] - The object to compare with.
     * @returns {boolean} `true` if the objects are equal, otherwise `false`.
     */
    equals(obj?: this | null): boolean;
    /**
     * Updates the object with new data and returns a clone of the object.
     *
     * @param {PartialObject} data - The data to update the object with.
     * @param {string[]} [clear] - Fields to clear in the object.
     * @returns {this} A clone of the updated object.
     */
    _update(data: PartialObject, clear?: string[]): this;
    /**
     * Patches the object with new data.
     *
     * @param {PartialObject} data - The data to patch the object with.
     * @param {string[]} [_clear] - Fields to clear in the object.
     * @returns {this} The updated object.
     * @protected
     */
    protected _patch(data: PartialObject, _clear?: string[]): this;
    /**
     * Creates a deep clone of the object.
     *
     * @returns {this} A clone of the object.
     */
    _clone(): this;
}

declare class UUID extends null {
    static readonly ENCODING = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
    static readonly ENCODING_LENGTH: number;
    static readonly RANDOM_LENGTH = 16;
    static readonly TIME_LENGTH = 10;
    static readonly TIME_MAX: number;
    static get PROG(): number;
    private static time;
    private static hash;
    static generate(timestamp?: number): string;
    static timestampOf(id: string): Date;
}

/** A type that can be a BitField, number, string, or an array of these types.
 * @private
 */
type BitFieldResolvable = BitField | number | string | BitFieldResolvable[];
/**
 * Represents a bitfield that can be used to manage flags or permissions.
 */
declare class BitField {
    static FLAGS: Record<string, number>;
    bitfield: number;
    constructor(bits?: BitFieldResolvable);
    /**
     * Resolves a bitfield or an array of bitfields into a single number.
     * @param bit The bitfield or array of bitfields to resolve.
     * @returns The resolved bitfield as a number.
     */
    static resolve(bit: BitFieldResolvable): number;
    /**
     * Returns the class that this instance belongs to.
     * @returns The class of the bitfield.
     */
    get self(): {
        FLAGS: Record<string, number>;
        resolve(bit: BitFieldResolvable): number;
        new (bits?: BitFieldResolvable): BitField;
    };
    /**
     * Checks if any of the bits in the bitfield are set.
     * @param bit The bitfield or array of bitfields to check.
     * @returns True if any bits are set, false otherwise.
     */
    any(bit: BitFieldResolvable): boolean;
    /**
     * checks if a specific permission is set.
     */
    has(bit: BitFieldResolvable): boolean;
    /**
     * Returns an array of all the Permissions that are set in the bitfield.
     * @returns An array of flag names.
     */
    toArray(): string[];
    add(...bits: BitFieldResolvable[]): this;
    remove(...bits: BitFieldResolvable[]): this;
    freeze(): Readonly<this>;
    valueOf(): number;
    /**
     *
     * @returns A record of all flags and their boolean values indicating whether they are set.
     */
    serialize(): Record<string, boolean>;
    [Symbol.iterator](): Iterable<string>;
}

declare class RestClient {
    private readonly client;
    private rateLimitQueue;
    constructor(client: BaseClient);
    /**
     * Helper function to handle API requests.
     * @param method The HTTP method (GET, POST, PATCH, PUT, DELETE).
     * @param url The URL for the request.
     * @param body The request body (if applicable).
     * @param query Query parameters (if applicable).
     * @returns The API response.
     */
    private request;
    getConfig(): Promise<void>;
    private retryRequest;
    /**
     * GET request.
     * @param url The URL for the request.
     * @param query Query parameters (if applicable).
     * @returns The API response.
     */
    get<T>(url: string, query?: Record<string, string | number>): Promise<T>;
    /**
     * POST request.
     * @param url The URL for the request.
     * @param body The request body.
     * @param query Query parameters (if applicable).
     * @returns The API response.
     */
    post<T>(url: string, body?: any, query?: Record<string, string | number>): Promise<T>;
    /**
     * PATCH request.
     * @param url The URL for the request.
     * @param body The request body.
     * @param query Query parameters (if applicable).
     * @returns The API response.
     */
    patch<T>(url: string, body: any, query?: Record<string, string | number>): Promise<T>;
    /**
     * PUT request.
     * @param url The URL for the request.
     * @param body The request body.
     * @param query Query parameters (if applicable).
     * @returns The API response.
     */
    put<T>(url: string, body?: any, query?: Record<string, string | number>): Promise<T>;
    /**
     * DELETE request.
     * @param url The URL for the request.
     * @param query Query parameters (if applicable).
     * @returns The API response.
     */
    delete<T>(url: string, body?: any, query?: Record<string, string | number>): Promise<T>;
}

declare class CDNClient {
    private readonly client;
    private rateLimitQueue;
    constructor(client: BaseClient);
    /**
     * Helper function to handle API requests.
     * @param method The HTTP method (GET, POST, PATCH, PUT, DELETE).
     * @param url The URL for the request.
     * @param body The request body (if applicable).
     * @param query Query parameters (if applicable).
     * @returns The API response.
     */
    private request;
    private retryRequest;
    /**
     * POST request.
     * @param url The URL for the request.
     * @param data The request body.
     * @returns The API response.
     */
    post<T>(url: string, data: FormData): Promise<T>;
}

type ChannelPermissionsString = keyof typeof ChannelPermissions.FLAGS;
type UserPermissionsString = keyof typeof UserPermissions.FLAGS;
type ServerPermissionsString = keyof typeof ServerPermissions.FLAGS;
type ChannelPermissionsResolvable = number | ChannelPermissionsString | ChannelPermissions | ChannelPermissionsResolvable[];
type UserPermissionsResolvable = number | UserPermissionsString | UserPermissions | UserPermissionsResolvable[];
type ServerPermissionsResolvable = number | ServerPermissionsString | ServerPermissions | ServerPermissionsResolvable[];
declare interface ChannelPermissions {
    serialize(): Record<ChannelPermissionsString, boolean>;
    any(bit: ChannelPermissionsResolvable): boolean;
    add(...bits: ChannelPermissionsResolvable[]): this;
    remove(...bits: ChannelPermissionsResolvable[]): this;
    has(bit: ChannelPermissionsResolvable): boolean;
}
declare class ChannelPermissions extends BitField {
    static readonly FLAGS: {
        readonly VIEW_CHANNEL: number;
        readonly SEND_MESSAGE: number;
        readonly MANAGE_MESSAGE: number;
        readonly MANAGE_CHANNEL: number;
        readonly VOICE_CALL: number;
        readonly INVITE_OTHERS: number;
        readonly EMBED_LINKS: number;
        readonly UPLOAD_FILES: number;
    };
    constructor(bits?: ChannelPermissionsResolvable);
    static resolve(bit: ChannelPermissionsResolvable): number;
}
declare interface UserPermissions {
    serialize(): Record<UserPermissionsString, boolean>;
    any(bit: UserPermissionsResolvable): boolean;
    add(...bits: UserPermissionsResolvable[]): this;
    remove(...bits: UserPermissionsResolvable[]): this;
    has(bit: UserPermissionsResolvable): boolean;
}
declare class UserPermissions extends BitField {
    static readonly FLAGS: {
        readonly ACCESS: number;
        readonly VIEW_PROFILE: number;
        readonly SEND_MESSAGES: number;
        readonly INVITE: number;
    };
    constructor(bits?: UserPermissionsResolvable);
    static resolve(bit: UserPermissionsResolvable): number;
}
declare interface ServerPermissions {
    serialize(): Record<ServerPermissionsString, boolean>;
    any(bit: ServerPermissionsResolvable): boolean;
    add(...bits: ServerPermissionsResolvable[]): this;
    remove(...bits: ServerPermissionsResolvable[]): this;
    has(bit: ServerPermissionsResolvable): boolean;
}
declare class ServerPermissions extends BitField {
    static readonly FLAGS: {
        readonly VIEW_SERVER: number;
        readonly MANAGE_ROLES: number;
        readonly MANAGE_CHANNELS: number;
        readonly MANAGE_SERVER: number;
        readonly KICK_MEMBERS: number;
        readonly BAN_MEMBERS: number;
        readonly CHANGE_NICKNAME: number;
        readonly MANAGE_NICKNAMES: number;
        readonly CHANGE_AVATAR: number;
        readonly REMOVE_AVATARS: number;
    };
    constructor(bits?: ServerPermissionsResolvable);
    static resolve(bit: ServerPermissionsResolvable): number;
}
declare class FullPermissions extends BitField {
    static readonly FLAGS: {
        readonly ManageChannel: number;
        readonly ManageServer: number;
        readonly ManagePermissions: number;
        readonly ManageRole: number;
        readonly ManageCustomisation: number;
        readonly KickMembers: number;
        readonly BanMembers: number;
        readonly TimeoutMembers: number;
        readonly AssignRoles: number;
        readonly ChangeNickname: number;
        readonly ManageNicknames: number;
        readonly ChangeAvatar: number;
        readonly RemoveAvatars: number;
        readonly ViewChannel: number;
        readonly ReadMessageHistory: number;
        readonly SendMessage: number;
        readonly ManageMessages: number;
        readonly ManageWebhooks: number;
        readonly InviteOthers: number;
        readonly SendEmbeds: number;
        readonly UploadFiles: number;
        readonly Masquerade: number;
        readonly React: number;
        readonly Connect: number;
        readonly Speak: number;
        readonly Video: number;
        readonly MuteMembers: number;
        readonly DeafenMembers: number;
        readonly MoveMembers: number;
        readonly MentionEveryone: number;
        readonly MentionRoles: number;
        readonly GrantAll: 4503599627370495;
    };
    constructor(bits?: number | string | FullPermissions | Array<number | string | FullPermissions>);
    static resolve(bit: number | string | FullPermissions): number;
}
declare const DEFAULT_PERMISSION_DM: Readonly<ChannelPermissions>;

/**
 * Represents a webhook avatar attachment.
 */
interface WebhookAvatar {
    /** The unique identifier of the attachment. */
    _id: string;
    /** The tag associated with the attachment. */
    tag: string;
    /** The filename of the attachment. */
    filename: string;
    /** Additional metadata for the attachment. */
    metadata: any;
    /** The MIME type of the attachment. */
    content_type: string;
    /** The size of the attachment in bytes. */
    size: number;
}
/**
 * Represents data for a webhook creation event.
 */
interface WebhookCreateData {
    /** The unique identifier of the webhook. */
    webhookId: string;
    /** The ID of the channel the webhook belongs to. */
    channelId: string;
    /** The name of the webhook. */
    name: string;
    /** The ID of the user who created the webhook. */
    creatorId: string;
    /** The webhook's token. */
    token: string;
}
/**
 * Represents data for a webhook deletion event.
 */
interface WebhookDeleteData {
    /** The unique identifier of the webhook. */
    webhookId: string;
}
/**
 * Represents data for a webhook update event.
 */
interface WebhookUpdateData {
    /** The unique identifier of the webhook. */
    webhookId: string;
    /** The updated name of the webhook. */
    name: string;
    /** The updated avatar of the webhook, if any. */
    avatar: WebhookAvatar | undefined;
    /** Fields to remove from the webhook. */
    remove: string[];
}
/**
 * Represents the permissions that can be set for a role.
 */
type editablePermissions = {
    /**
     * Permissions to allow for the role.
     * Each key corresponds to a permission flag in FullPermissions.
     */
    a?: Array<keyof (typeof FullPermissions)["FLAGS"]>;
    /**
     * Permissions to deny for the role.
     * Each key corresponds to a permission flag in FullPermissions.
     */
    d?: Array<keyof (typeof FullPermissions)["FLAGS"]>;
};
/**
 * Represents a role that can be edited in a server.
 */
type editableRole = {
    /**
     * Name of the role.
     */
    name?: string;
    /**
     * Colour of the role, or `null` if no colour is set.
     */
    colour?: string | null;
    /**
     * Whether the role is displayed separately in the member list.
     */
    hoist?: boolean;
    /**
     * Rank of the role, used for ordering.
     */
    rank?: number;
    /**
     * Permissions to set for the role.
     * Format: { a: allow, d: deny }
     */
    permissions?: editablePermissions;
    /**
     * Fields to remove from the role.
     * Each key corresponds to a field in the Role type.
     */
    remove?: Array<keyof Role$1 & {
        [key: string]: unknown;
    }>;
};
interface createWebhookResponse {
    id: "string";
    name: "string";
    avatar: {
        _id: "string";
        tag: "string";
        filename: "string";
        metadata: {
            type: "File";
        };
        content_type: "string";
        size: 1;
        deleted: null;
        reported: null;
        message_id: null;
        user_id: null;
        server_id: null;
        object_id: null;
    };
    creator_id: "string";
    channel_id: "string";
    permissions: 0;
    token: null;
}
interface editWebhookOptions {
    name: string;
    avatar?: Readable | string | File;
    remove?: [];
}

/**
 * Represents the base class for all event handlers.
 * All event handlers must extend this class and implement the `handle` method.
 *  @private
 */
declare abstract class Event {
    protected readonly client: client;
    /**
     * Creates a new Event instance.
     *
     * @param {client} client - The client instance.
     */
    constructor(client: client);
    /**
     * Handles the event logic.
     * This method must be implemented by subclasses to define the behavior for the specific event.
     *
     * @param {unknown} data - The data associated with the event.
     * @returns {Promise<unknown | void>} A promise that resolves with the result of the event handling or `void`.
     */
    abstract handle(data: unknown): Awaited<unknown | void>;
}

/**
 * Data structure for user voice state update event.
 */
interface UserVoiceStateUpdateData {
    id: string;
    channel_id: string;
    data: {
        is_publishing: boolean;
        screensharing: boolean;
        camera: boolean;
    };
}

/**
 * Data structure for voice channel join event.
 */
interface VoiceChannelJoinData {
    id: string;
    state: voiceParticipant;
}

/**
 * Data structure for voice channel leave event.
 */
interface VoiceChannelLeaveData {
    id: string;
    user: string;
}

/**
 * Represents the events that the client can emit.
 */
interface ClientEvents {
    /** Emitted when a debug message is logged. */
    [Events.DEBUG]: [unknown];
    /** Emitted when a message is received. */
    [Events.MESSAGE]: [MessageStruct];
    /** Emitted when a message is deleted. */
    [Events.MESSAGE_DELETE]: [MessageStruct];
    /** Emitted when a message is updated. */
    [Events.MESSAGE_UPDATE]: [MessageStruct, MessageStruct];
    /** Emitted when a reaction is added to a message. */
    [Events.MESSAGE_REACT]: [MessageStruct];
    /** Emitted when a reaction is removed from a message. */
    [Events.MESSAGE_REACT_REMOVE]: [MessageStruct];
    /** Emitted when a message is bulk deleted. */
    [Events.MESSAGE_DELETE_BULK]: [string[]];
    /** Emitted when a channel is created. */
    [Events.CHANNEL_CREATE]: [Channel];
    /** Emitted when a channel is deleted. */
    [Events.CHANNEL_DELETE]: [Channel];
    /** Emitted when a channel is updated. */
    [Events.CHANNEL_UPDATE]: [Channel, Channel];
    /** Emitted when a server is created. */
    [Events.SERVER_CREATE]: [Server];
    /** Emitted when a server is deleted. */
    [Events.SERVER_DELETE]: [Server];
    /** Emitted when a server is updated. */
    [Events.SERVER_UPDATE]: [Server, Server];
    /** Emitted when a server member joins. */
    [Events.SERVER_MEMBER_JOIN]: [ServerMember];
    /** Emitted when a server member leaves. */
    [Events.SERVER_MEMBER_LEAVE]: [ServerMember];
    /** Emitted when a server member is updated. */
    [Events.SERVER_MEMBER_UPDATE]: [ServerMember, ServerMember];
    /** Emitted when a user is updated. */
    [Events.USER_UPDATE]: [User, User];
    /** Emitted when a user is typing. */
    [Events.TYPING_START]: [Channel, User];
    /** Emitted when a user stops typing. */
    [Events.TYPING_STOP]: [Channel, User];
    /** Emitted when a group member joins. */
    [Events.GROUP_JOIN]: [Channel, User];
    /** Emitted when a group member leaves. */
    [Events.GROUP_LEAVE]: [Channel, User];
    /** Emitted when the client is ready. */
    [Events.READY]: [client];
    /** Emitted when an error occurs. */
    [Events.ERROR]: [unknown];
    /** Emitted when a raw event is received. */
    [Events.RAW]: [unknown];
    /** emitted when a role is created */
    [Events.ROLE_CREATE]: [Role];
    /** emitted when a role is deleted */
    [Events.ROLE_DELETE]: [Role];
    /** emitted when a role is updated */
    [Events.ROLE_UPDATE]: [Role, Role];
    /** emitted when a webhook is created */
    [Events.WEBHOOKS_CREATE]: [WebhookCreateData];
    /** emitted when a webhook is deleted */
    [Events.WEBHOOKS_DELETE]: [WebhookDeleteData];
    /** emitted when a webhook is updated */
    [Events.WEBHOOKS_UPDATE]: [WebhookUpdateData];
    /** emitted when a user's voice state is updated */
    [Events.USER_VOICE_STATE_UPDATE]: [UserVoiceStateUpdateData];
    /** emitted when a user joins a voice channel */
    [Events.VOICE_CHANNEL_JOIN]: [VoiceChannelJoinData];
    /** emitted when a user leaves a voice channel */
    [Events.VOICE_CHANNEL_LEAVE]: [VoiceChannelLeaveData];
}
/**
 * Represents the options for configuring the client.
 */
interface clientOptions {
    /** Whether to fetch all members of a server. */
    fetchMembers?: boolean;
    /** events for the client to ignore.*/
    ignoreEvents?: string[];
    /** Whether to ignore bot messages. */
    ignoreBots?: boolean;
    /** wether to use X-Session-Token or X-Bot-Token*/
    isBot?: boolean;
    /** Configuration for REST API requests. */
    rest?: {
        /** The timeout for REST requests in milliseconds. */
        timeout?: number;
        /** The number of retries for failed REST requests. */
        retries?: number;
        /** URL for stoat API instance without trailing slash */
        instanceURL?: string;
        /** URL for stoat CDN instance without trailing slash */
        instanceCDNURL?: string;
    };
    MessageCache?: {
        /** The maximum size of the cache. */
        maxSize?: number;
    };
    /** Configuration for WebSocket connections. */
    ws?: {
        /** The interval for sending heartbeats in milliseconds. */
        heartbeatInterval?: number;
        /** Whether to automatically reconnect on disconnection. */
        reconnect?: boolean;
        /** URL for stoat WebSocket instance without trailing slash */
        instanceURL?: string;
    };
}
interface VoiceClientOptions {
    enabled?: boolean;
    nodes?: VoiceNode[];
}
interface VoiceNode {
    name: string;
    lat: number;
    lon: number;
    public_url: string;
}
/**
 * Represents the base client that provides core functionality for interacting with the API.
 *
 * @extends EventEmitter
 */
declare interface BaseClient {
    on<K extends keyof ClientEvents>(event: K, listener: (...args: ClientEvents[K]) => Awaited<void>): this;
    on<S extends string | symbol>(event: Exclude<S, keyof ClientEvents>, listener: (...args: any[]) => Awaited<void>): this;
    once<K extends keyof ClientEvents>(event: K, listener: (...args: ClientEvents[K]) => Awaited<void>): this;
    once<S extends string | symbol>(event: Exclude<S, keyof ClientEvents>, listener: (...args: any[]) => Awaited<void>): this;
    emit<K extends keyof ClientEvents>(event: K, ...args: ClientEvents[K]): boolean;
    emit<S extends string | symbol>(event: Exclude<S, keyof ClientEvents>, ...args: unknown[]): boolean;
    off<K extends keyof ClientEvents>(event: K, listener: (...args: ClientEvents[K]) => Awaited<void>): this;
    off<S extends string | symbol>(event: Exclude<S, keyof ClientEvents>, listener: (...args: any[]) => Awaited<void>): this;
    removeAllListeners<K extends keyof ClientEvents>(event?: K): this;
    removeAllListeners<S extends string | symbol>(event?: Exclude<S, keyof ClientEvents>): this;
}
/**
 * Represents the base client that provides core functionality for interacting with the API.
 *
 * @extends EventEmitter
 */
declare abstract class BaseClient extends EventEmitter {
    #private;
    /** The REST client for making API requests. */
    readonly api: RestClient;
    /** The CDN client for accessing media resources. */
    readonly cdn: CDNClient;
    /** The options for configuring the client. */
    options: clientOptions;
    voiceOptions: VoiceClientOptions;
    /** Track current voice connection to prevent AlreadyConnected errors */
    currentVoiceConnection: {
        channelId: string;
        playerId: string;
    } | null;
    /** Whether the client is a bot. */
    bot: boolean;
    /**
     * Creates a new BaseClient instance.
     *
     * @param {clientOptions} [options={}] - The options for configuring the client.
     */
    constructor(options?: clientOptions);
    /**
     * Emits a debug message.
     *
     * @param {unknown} msg - The debug message to emit.
     */
    debug(msg: unknown): void;
    /**
     * Sets the authentication token for the client.
     *
     * @param {string | null} token - The authentication token.
     */
    set token(token: string | null);
    /**
     * Gets the authentication token for the client.
     *
     * @returns {string | null} The authentication token, or `null` if not set.
     */
    get token(): string | null;
}

/**
 * Enum representing the client events that can be emitted.
 * @private
 */
declare enum Events {
    CHANNEL_CREATE = "channelCreate",
    CHANNEL_DELETE = "channelDelete",
    CHANNEL_UPDATE = "channelUpdate",
    DEBUG = "debug",
    ERROR = "error",
    GROUP_JOIN = "groupJoin",
    GROUP_LEAVE = "groupLeave",
    MESSAGE = "message",
    MESSAGE_DELETE = "messageDelete",
    MESSAGE_DELETE_BULK = "messageDeleteBulk",
    MESSAGE_UPDATE = "messageUpdate",
    MESSAGE_REACT = "messageReact",
    MESSAGE_REACT_REMOVE = "messageUnreact",
    RAW = "raw",
    READY = "ready",
    ROLE_CREATE = "roleCreate",
    ROLE_DELETE = "roleDelete",
    ROLE_UPDATE = "roleUpdate",
    SERVER_CREATE = "serverCreate",
    SERVER_DELETE = "serverDelete",
    SERVER_MEMBER_JOIN = "serverMemberJoin",
    SERVER_MEMBER_LEAVE = "serverMemberLeave",
    SERVER_MEMBER_UPDATE = "serverMemberUpdate",
    SERVER_UPDATE = "serverUpdate",
    TYPING_START = "typingStart",
    TYPING_STOP = "typingStop",
    USER_UPDATE = "userUpdate",
    WEBHOOKS_CREATE = "webhookCreate",
    WEBHOOKS_DELETE = "webhookDelete",
    WEBHOOKS_UPDATE = "webhookUpdate",
    USER_VOICE_STATE_UPDATE = "userVoiceStateUpdate",
    VOICE_CHANNEL_JOIN = "voiceChannelJoin",
    VOICE_CHANNEL_LEAVE = "voiceChannelLeave"
}
/**
 * Enum representing the WebSocket events used for communication.
 * @private
 */
declare enum WSEvents {
    AUTHENTICATE = "Authenticate",
    AUTHENTICATED = "Authenticated",
    BEGIN_TYPING = "BeginTyping",
    BULK = "Bulk",
    CHANNEL_ACK = "ChannelAck",
    CHANNEL_CREATE = "ChannelCreate",
    CHANNEL_DELETE = "ChannelDelete",
    CHANNEL_GROUP_JOIN = "ChannelGroupJoin",
    CHANNEL_GROUP_LEAVE = "ChannelGroupLeave",
    CHANNEL_START_TYPING = "ChannelStartTyping",
    CHANNEL_STOP_TYPING = "ChannelStopTyping",
    CHANNEL_UPDATE = "ChannelUpdate",
    END_TYPING = "EndTyping",
    ERROR = "Error",
    MESSAGE = "Message",
    MESSAGE_BULK_DELETE = "BulkMessageDelete",
    MESSAGE_DELETE = "MessageDelete",
    MESSAGE_UPDATE = "MessageUpdate",
    PING = "Ping",
    PONG = "Pong",
    READY = "Ready",
    SERVER_DELETE = "ServerDelete",
    SERVER_MEMBER_JOIN = "ServerMemberJoin",
    SERVER_MEMBER_LEAVE = "ServerMemberLeave",
    SERVER_MEMBER_UPDATE = "ServerMemberUpdate",
    SERVER_ROLE_DELETE = "ServerRoleDelete",
    SERVER_ROLE_UPDATE = "ServerRoleUpdate",
    SERVER_UPDATE = "ServerUpdate",
    USER_RELATIONSHIP = "UserRelationship",
    USER_UPDATE = "UserUpdate",
    WEBHOOKS_CREATE = "WebhooksCreate",
    WEBHOOKS_DELETE = "WebhooksDelete",
    WEBHOOKS_UPDATE = "WebhooksUpdate",
    VOICE_STATE_UPDATE = "VoiceStateUpdate",
    VOICE_CHANNEL_JOIN = "VoiceChannelJoin",
    VOICE_CHANNEL_LEAVE = "VoiceChannelLeave"
}
/**
 * Enum representing the types of channels supported by the client.
 */
declare enum ChannelTypes {
    DM = "DM",
    GROUP = "GROUP",
    TEXT = "TEXT",
    VOICE = "VOICE",
    NOTES = "NOTES"
}
/**
 * The default options for configuring the client.
 */
declare const DEFAULT_CLIENT_OPTIONS: clientOptions;
/** The base API URL for interacting with the Stoat API. */
declare const apiUrl = "https://api.stoat.chat";
/** The system user ID used for identifying system messages. */
declare const SYSTEM_USER_ID: string;

type BadgeString = keyof typeof Badges.FLAGS;
type BadgesResolvable = number | BadgeString | Badges | BadgesResolvable[];
declare interface Badges {
    serialize(): Record<BadgeString, boolean>;
    any(bit: BadgesResolvable): boolean;
    add(...bits: BadgesResolvable[]): this;
    remove(...bits: BadgesResolvable[]): this;
    has(bit: BadgesResolvable): boolean;
}
declare class Badges extends BitField {
    static readonly FLAGS: {
        readonly DEVELOPER: number;
        readonly TRANSLATOR: number;
        readonly SUPPORTER: number;
        readonly RESPONSIBLE_DISCLOSURE: number;
        readonly REVOLT_TEAM: number;
        readonly EARLY_ADOPTER: number;
    };
    constructor(bits?: BadgesResolvable);
    static resolve(bit: BadgesResolvable): number;
}

/**
 * Represents a user in the client.
 *
 * @extends Base
 */
declare class User extends Base {
    /** The username of the user. */
    username: string;
    /** The avatar of the user, or `null` if none is set. */
    avatar: Attachment | null;
    /** The presence status of the user. */
    presence: Presence;
    /** The badges associated with the user. */
    badges: Badges;
    /** Whether the user is a bot. */
    bot: boolean;
    /**
     * Creates a new User instance.
     *
     * @param {client} client - The client instance.
     * @param {APIUser} data - The raw data for the user from the API.
     */
    constructor(client: client, data: User$1);
    /**
     * Updates the user instance with new data from the API.
     *
     * @param {APIUser} data - The raw data for the user from the API.
     * @param {FieldsUser[]} [clear=[]] - Fields to clear in the user.
     * @returns {this} The updated user instance.
     * @protected
     */
    protected _patch(data: User$1, clear?: FieldsUser[]): this;
    /**
     * Gets the creation date of the user.
     *
     * @returns {Date} The date when the user was created.
     */
    get createdAt(): Date;
    /**
     * checks if the user is the owner of the bot.
     */
    get isOwner(): boolean;
    /**
     * Gets the creation timestamp of the user in milliseconds.
     *
     * @returns {number} The timestamp of when the user was created.
     */
    get createdTimestamp(): number;
    /**
     * Blocks the user.
     *
     * @returns {Promise<void>} A promise that resolves when the user is blocked.
     *
     * @example
     * ```typescript
     * await user.block();
     * ```
     */
    block(): Promise<void>;
    /**
     * Unblocks the user.
     *
     * @returns {Promise<void>} A promise that resolves when the user is unblocked.
     *
     * @example
     * ```typescript
     * await user.unblock();
     * ```
     */
    unblock(): Promise<void>;
    /**
     * Creates a direct message (DM) channel with the user.
     *
     * @returns {Promise<DMChannel>} A promise that resolves with the created DM channel.
     *
     * @example
     * ```typescript
     * const dmChannel = await user.createDM();
     * ```
     */
    createDM(): Promise<DMChannel>;
    avatarURL(): string | undefined;
    displayAvatarURL(): Promise<string>;
    /**
     * Fetches the latest data for the user from the API.
     *
     * @param {boolean} [force=false] - Whether to force a fetch even if the user is cached.
     * @returns {Promise<User>} A promise that resolves with the updated user instance.
     */
    fetch(force?: boolean): Promise<User>;
    /**
     * Converts the user to a string representation.
     *
     * @returns {string} A string representation of the user in the format `<@userId>`.
     */
    toString(): string;
}

/**
 * Represents a message in a channel.
 *
 * @extends Base
 */
declare class MessageStruct extends Base {
    /** The type of the message (e.g., TEXT, SYSTEM). */
    type: Uppercase<SystemMessage["type"]>;
    /** The content of the message. */
    content: string;
    /** The ID of the channel where the message was sent. */
    channelId: string;
    /** The ID of the user who authored the message. */
    authorId: string;
    /** An array of embeds included in the message. */
    embeds: Embed[];
    /** An array of file attachments included in the message. */
    attachments: File$1[];
    /** Mentions included in the message. */
    mentions: Mentions;
    /** The timestamp of when the message was last edited, or `null` if not edited. */
    editedTimestamp: number | null;
    /** the reactions and count on a message */
    reactions: Map<string, string[]>;
    /** Masquerade information for the message, Name and / or avatar override information */
    masquerade?: Masquerade;
    /** Webhook information for the message, Name and / or avatar override information */
    webhook?: {
        name: string;
        avatar: string | null;
    };
    /**
     * Creates a new Message instance.
     *
     * @param {client} client - The client instance.
     * @param {APIMessage} data - The raw data for the message from the API.
     */
    constructor(client: client, data: Message);
    /**
     * Updates the message instance with new data from the API.
     *
     * @param {APIMessage} data - The raw data for the message from the API.
     * @returns {this} The updated message instance.
     * @protected
     */
    protected _patch(data: Message): this;
    /**
     * Gets the creation date of the message.
     *
     * @returns {Date} The date when the message was created.
     */
    get createdAt(): Date;
    /**
     * Gets the creation timestamp of the message in milliseconds.
     *
     * @returns {number} The timestamp of when the message was created.
     */
    get createdTimestamp(): number;
    /**
     * Gets the date when the message was last edited.
     *
     * @returns {Date | null} The date of the last edit, or `null` if not edited.
     */
    get editedAt(): Date | null;
    /**
     * Checks if the message is a system message.
     *
     * @returns {boolean} `true` if the message is a system message, otherwise `false`.
     */
    get system(): boolean;
    /**
     * Retrieves the author of the message.
     *
     * @returns {User | ServerMember | null} The user who authored the message, or `null` if not found.
     */
    get author(): User | ServerMember | Partial<User & {
        isWebhook: boolean;
    }> | null;
    /**
     * Retrieves the channel where the message was sent.
     *
     * @returns {TextChannel | DMChannel | GroupChannel | VoiceChannel} The channel instance.
     */
    get channel(): TextChannel | DMChannel | GroupChannel | VoiceChannel;
    /**
     * Retrieves the server ID associated with the message, if any.
     *
     * @returns {string | null} The server ID, or `null` if the message is not in a server.
     */
    get serverId(): string | null;
    /**
     * Retrieves the server associated with the message, if any.
     *
     * @returns {Server | null} The server instance, or `null` if not found.
     */
    get server(): Server | null;
    /**
     * Retrieves the server member who authored the message, if any.
     *
     * @returns {ServerMember | null} The server member instance, or `null` if not found.
     */
    get member(): ServerMember | null;
    /**
     * Gets the URL of the message.
     *
     * @returns {string} The URL of the message.
     */
    get url(): string;
    /**
     * Acknowledges the message.
     *
     * @returns {Promise<void>} A promise that resolves when the message is acknowledged.
     */
    ack(): Promise<void>;
    /**
     * Deletes the message.
     *
     * @returns {Promise<void>} A promise that resolves when the message is deleted.
     */
    delete(): Promise<void>;
    /**
     * Replies to the message.
     *
     * @param {string} content - The content of the reply.
     * @param {boolean} [mention=true] - Whether to mention the original message author.
     * @returns {Promise<Message>} A promise that resolves with the sent reply message.
     */
    reply(content: MessageOptions | string, mention?: boolean): Promise<MessageStruct>;
    /**
     * Edits the message.
     *
     * @param {MessageEditOptions | string} options - The new content or edit options.
     * @returns {Promise<void>} A promise that resolves when the message is edited.
     */
    edit(options: MessageEditOptions | string): Promise<void>;
    /**
     * Fetches the latest data for the message.
     *
     * @returns {Promise<Message>} A promise that resolves with the updated message instance.
     */
    fetch(): Promise<MessageStruct>;
    /**
     * Adds a reaction to the message.
     *
     * @param {string} emoji - The emoji to react with.
     * @returns {Promise<void>} A promise that resolves when the reaction is added.
     */
    addReaction(emoji: string): Promise<void>;
    /**
     * Removes a reaction from the message.
     *
     * @param {string} emoji - The emoji to remove the reaction for.
     * @param {object} [options] - Options for removing the reaction.
     * @param {string} [options.user_id] - The user ID to remove the reaction for. If not provided, removes the reaction for the current user.
     * @param {boolean} [options.remove_all=false] - Whether to remove all of the specified reaction for the message.
     * @returns {Promise<void>} A promise that resolves when the reaction is removed.
     */
    removeReaction(emoji: string, options?: {
        user_id?: string;
        remove_all?: boolean;
    }): Promise<void>;
    /**
     * Removes all reactions from the message.
     *
     * @returns {Promise<void>} A promise that resolves when all reactions are removed.
     */
    removeAllReactions(): Promise<void>;
    /**
     * Checks if the message is in a server.
     *
     * @returns {boolean} `true` if the message is in a server, otherwise `false`.
     */
    inServer(): this is this & {
        serverId: string;
        server: Server;
        channel: TextChannel;
    };
    /**
     * Converts the message to a string representation.
     *
     * @returns {string} The content of the message.
     */
    toString(): string;
}

/**
 * Represents an attachment, such as a file or image, in a message or channel.
 *
 * @extends Base
 */
declare class Attachment extends Base {
    /** The filename of the attachment. */
    filename: string;
    /** The MIME type of the attachment (e.g., `image/png`, `application/pdf`). */
    type: string;
    /** The size of the attachment in bytes. */
    size: number;
    /** Metadata associated with the attachment (e.g., dimensions for images). */
    metadata: File$1["metadata"];
    /**
     * Creates a new Attachment instance.
     *
     * @param {client} client - The client instance.
     * @param {File} data - The raw data for the attachment from the API.
     */
    constructor(client: client, data: File$1);
    /**
     * Updates the attachment instance with new data from the API.
     *
     * @param {File} data - The raw data for the attachment from the API.
     * @returns {this} The updated attachment instance.
     * @protected
     */
    protected _patch(data: File$1): this;
}

/**
 * Enum representing the possible presence statuses of a user.
 */
declare enum Status {
    Online = "Online",
    Idle = "Idle",
    Focus = "Focus",
    Busy = "Busy",
    Invisible = "Invisible"
}
/**
 * Represents the presence of a user, including their status and custom text.
 *
 * @extends Base
 */
declare class Presence extends Base {
    /** The custom status text of the user, or `null` if none is set. */
    text: string | null;
    /** The current status of the user (e.g., Online, Idle, Busy, Invisible). */
    status: Status;
}

/**
 * Represents a server (guild) in the client.
 *
 * @extends Base
 */
declare class Server extends Base {
    /** The name of the server. */
    name: string;
    /** The description of the server, or `null` if none is set. */
    description: string | null;
    /** The ID of the user who owns the server. */
    ownerId: string;
    /** Manages the members of the server. */
    members: ServerMemberManager;
    /** Manages the channels of the server. */
    channels: ServerChannelManager;
    /** Manages the roles of the server. */
    roles: RoleManager;
    /** The icon of the server, or `null` if none is set. */
    icon: Attachment | null;
    /** The banner of the server, or `null` if none is set. */
    banner: Attachment | null;
    /** Whether analytics are enabled for the server. */
    analytics: boolean;
    /** Whether the server is discoverable. */
    discoverable: boolean;
    /** Whether the server is marked as NSFW (Not Safe For Work). */
    nsfw: boolean;
    /** The default permissions for the server. */
    permissions: FullPermissions;
    /** The categories in the server. */
    categories: Map<string, Category>;
    /** the emojies associated with the server */
    emojis: Map<string, Emoji>;
    /**
     * Creates a new Server instance.
     *
     * @param {client} client - The client instance.
     * @param {APIServer} data - The raw data for the server from the API.
     */
    constructor(client: client, data: Server$1);
    /**
     * Updates the server instance with new data from the API.
     *
     * @param {APIServer} data - The raw data for the server from the API.
     * @param {FieldsServer[]} [clear=[]] - Fields to clear in the server.
     * @returns {this} The updated server instance.
     * @protected
     */
    protected _patch(data: Server$1, clear?: FieldsServer[]): this;
    /**
     * Retrieves the current user's member instance in the server.
     *
     * @returns {ServerMember | null} The current user's member instance, or `null` if not found.
     */
    get me(): ServerMember | null;
    /**
     * Gets the creation date of the server.
     *
     * @returns {Date} The date when the server was created.
     */
    get createdAt(): Date;
    /**
     * Gets the creation timestamp of the server in milliseconds.
     *
     * @returns {number} The timestamp of when the server was created.
     */
    get createdTimestamp(): number;
    /**
     * Retrieves the owner of the server.
     *
     * @returns {User | null} The owner of the server, or `null` if not found.
     */
    get owner(): User | null;
    /**
     * Converts the server to a string representation.
     *
     * @returns {string} The name of the server.
     */
    toString(): string;
}

/**
 * Represents a role in a server.
 *
 * @extends Base
 */
declare class Role extends Base {
    server: Server;
    /** The name of the role. */
    name: string;
    /** The color of the role, or `null` if no color is set. */
    color: string | null;
    /** Whether the role is displayed separately in the member list. */
    hoist: boolean;
    /** The rank of the role, used for ordering. */
    rank: number;
    /** The permissions overwrite for the role. */
    overwrite: Overwrite;
    /**
     * Creates a new Role instance.
     *
     * @param {Server} server - The server this role belongs to.
     * @param {APIRole & { id: string }} data - The raw data for the role from the API.
     */
    constructor(server: Server, data: Role$1 & {
        id: string;
    });
    /**
     * Updates the role instance with new data from the API.
     *
     * @param {APIRole & { _id?: string }} data - The raw data for the role from the API.
     * @param {FieldsRole[]} [clear=[]] - Fields to clear in the role.
     * @returns {this} The updated role instance.
     * @protected
     */
    protected _patch(data: Role$1 & {
        _id?: string;
    }, clear?: FieldsRole[]): this;
    /**
     * Gets the date when the role was created.
     *
     * @returns {Date} The creation date of the role.
     */
    get createdAt(): Date;
    /**
     * Gets the timestamp of when the role was created.
     *
     * @returns {number} The creation timestamp of the role in milliseconds.
     */
    get createdTimestamp(): number;
    /**
     * Gets the permissions overwrite for the role.
     *
     * @returns {Overwrite} The permissions overwrite for the role.
     */
    get permissions(): Overwrite;
    /**
     * Deletes the role from the server.
     *
     * @returns {Promise<void>} A promise that resolves when the role is deleted.
     *
     * @example
     * ```typescript
     * await role.delete();
     * console.log("Role deleted successfully.");
     * ```
     */
    delete(): Promise<void>;
    edit(data: editableRole): Promise<Role>;
    /**
     * Converts the role to a string representation.
     *
     * @returns {string} A string representation of the role in the format `<@&roleId>`.
     */
    toString(): string;
}

/**
 * Represents a channel in the API.
 * @private
 */
type APIServerChannel = Extract<Channel$1, {
    channel_type: "TextChannel" | "VoiceChannel";
}>;

type ServerChannelResolvable = ServerChannel | APIServerChannel | string;
interface CreateChannelOptions {
    name: string;
    type?: "Text" | "Voice";
    description?: string;
    nsfw?: boolean;
    voice: {
        max_users?: number;
    };
}
declare class ServerChannelManager extends BaseManager<ServerChannel> {
    protected readonly server: Server;
    /** @private */
    holds: typeof ServerChannel;
    constructor(server: Server);
    /** @private */
    _add(data: APIServerChannel): ServerChannel;
    /**
     * Creates a new channel in the server.
     * @param options - Options for creating the channel.
     * @param options.name - The name of the channel to create.
     * @param [options.type="Text"] - The type of the channel to create. Can be "Text" or "Voice". Defaults to "Text".
     * @param [options.description] - The description of the channel to create. Only used for voice channels.
     * @returns A promise that resolves to the created channel.
     */
    create({ name, type, description, }: CreateChannelOptions): Promise<ServerChannel>;
    /**
     * fetch a channel from the server
     * @param channel The channel to fetch. Can be a string, a channel object, or an API channel object.
     * @param force Whether to force fetch the channel from the API. Defaults to true.
     * If set to false, the method will return the channel from the cache if it exists.
     * @returns A promise that resolves to the fetched channel
     */
    fetch(channel: ServerChannelResolvable, { force }?: {
        force?: boolean | undefined;
    }): Promise<ServerChannel>;
}

type MessageResolvable = MessageStruct | Message | string;
interface MessageReply {
    id: string;
    mention: boolean;
}
interface MessageOptions {
    content?: string;
    replies?: MessageReply[];
    attachments?: Readable[] | string[] | File$2[];
    embeds?: MessageEmbed[];
    masquerade?: Masquerade;
}
interface MessageEditOptions {
    content?: string;
    attachments?: string[];
    embeds?: MessageEmbed[];
}
interface MessageSearchOptions {
    query: string;
    limit?: number;
    before?: string;
    after?: string;
    sort?: MessageSort;
}
interface MessageQueryOptions {
    limit?: number;
    before?: string;
    after?: string;
    sort?: MessageSort;
    nearby?: string;
}
declare class MessageManager extends BaseManager<MessageStruct, Message> {
    protected readonly channel: Channel;
    /** @private */
    holds: typeof MessageStruct;
    constructor(channel: Channel, maxSize?: number);
    /**
     *
     * @param content The content to send. Can be a string or an object with the following properties:
     * - content: The content of the message
     * - replies: An array of message IDs to reply to
     * - attachments: An array of attachment URLs, Files, or ReadStreams
     * - embeds: An array of MessageEmbed objects
     * @returns Promise that resolves to the sent message
     */
    send(content: MessageOptions | string): Promise<MessageStruct>;
    /**
     * acknowledge a message to mark it as read (not important for bots)
     * @param message The message to acknowledge
     * @returns Promise that resolves when the message is acknowledged
     */
    ack(message: MessageResolvable): Promise<void>;
    /**
     * bulk delete messages from the channel
     * @param messages The messages to delete. Can be an array of message IDs or a Map of message IDs to Message objects.
     * @returns Promise that resolves when the messages are deleted
     */
    bulkDelete(messages: MessageResolvable[] | number | Map<string, MessageStruct>): Promise<void>;
    /**
     * delete a message from the channel
     * @param message The message to delete. Can be a Message object or a message ID.
     * @returns Promise that resolves when the message is deleted
     */
    delete(message: MessageResolvable): Promise<void>;
    /**
     * edit a message in the channel
     * @param message The message to edit. Can be a Message object or a message ID.
     * @param options The options to edit the message with. Can be a string or an object with the following properties:
     * - content: The new content of the message
     * - attachments: An array of attachment URLs
     * - embeds: An array of MessageEmbed objects
     * @returns Promise that resolves when the message is edited
     */
    edit(message: MessageResolvable, options: MessageEditOptions | string): Promise<void>;
    /**
     * search for messages in the channel
     * @param query The query to search for. Can be a string or an object with the following properties:
     * - query: The query to search for
     * - limit: The maximum number of messages to return
     * - before: The message ID to start searching from (exclusive)
     * - after: The message ID to stop searching at (exclusive)
     * - sort: The sort order of the results (asc or desc)
     * @returns Promise that resolves to a Map of message IDs to Message objects
     */
    search(query: MessageSearchOptions | string): Promise<Map<string, MessageStruct>>;
    /**
     * fetch a message from the channel
     * @param message The message to fetch. Can be a Message object, a message ID, or an object with the following properties:
     * - limit: The maximum number of messages to return
     * - before: The message ID to start fetching from (exclusive)
     * - after: The message ID to stop fetching at (exclusive)
     * @returns Promise that resolves to a Message object or a Map of message IDs to Message objects
     */
    fetch(message: MessageResolvable): Promise<MessageStruct>;
    fetch(query?: MessageQueryOptions): Promise<Map<string, MessageStruct>>;
    fetch(limit: number): Promise<Map<string, MessageStruct>>;
    /**
     * add a reaction to a message
     * @param message The message to react to. Can be a Message object or a message ID.
     * @param emoji emoji to react with. Can be a string or an Emoji object.
     * @returns Promise that resolves when the reaction is added
     */
    addReaction(message: MessageResolvable | string, emoji: string | Emoji): Promise<void>;
    /**
     *
     * @param message The message to unreact. Can be a Message object or a message ID.
     * @param emoji the emoji to unreact with. Can be a string or an Emoji object.
     * @param user_id The user ID to remove the reaction for. If not provided, removes the reaction for the current user.
     * @param remove_all Whether to remove all of the specified reaction for the message. Defaults to false.
     * @returns Promise that resolves when the reaction is removed
     */
    removeReaction(message: MessageResolvable | string, emoji: string | Emoji, user_id?: string, remove_all?: boolean): Promise<void>;
    /**
     * remove all reactions from a message
     * @param message The message to remove reactions from. Can be a Message object or a message ID.
     * @returns Promise that resolves when the reactions are removed
     */
    removeAllReactions(message: MessageResolvable | string): Promise<void>;
}

/**
 * Represents a generic communication channel in the client.
 * This abstract class provides a base structure and common functionality
 * for all types of channels, such as text, voice, group, and server channels.
 *
 * @abstract
 * @extends Base
 *
 * @property {ChannelTypes | "UNKNOWN"} type - The type of the channel. Defaults to "UNKNOWN".
 * @property {number} createdTimestamp - The timestamp (in milliseconds) when the channel was created.
 * @property {Date} createdAt - The date and time when the channel was created.
 */
declare abstract class Channel extends Base {
    type: ChannelTypes | "UNKNOWN";
    voice?: Map<string, voiceParticipant>;
    /**
     * Gets the timestamp (in milliseconds) when the channel was created.
     *
     * @returns {number} The timestamp of the channel's creation.
     */
    get createdTimestamp(): number;
    /**
     * Gets the date and time when the channel was created.
     *
     * @returns {Date} The creation date of the channel.
     */
    get createdAt(): Date;
    /**
     * Deletes the current channel instance from the client's channel collection.
     *
     * This method interacts with the client's channel management system to remove
     * the channel. Once deleted, the channel will no longer be accessible through
     * the client.
     *
     * @returns {Promise<void>} A promise that resolves when the channel has been successfully deleted.
     *
     * @example
     * ```typescript
     * const channel = client.channels.get('1234567890');
     * if (channel) {
     *   await channel.delete();
     *   console.log('Channel deleted successfully.');
     * }
     * ```
     */
    delete(): Promise<void>;
    /**
     * Checks if the channel is a text-based channel.
     *
     * @returns {boolean} True if the channel is a text-based channel, otherwise false.
     */
    isText(): this is TextChannel | GroupChannel | DMChannel;
    /**
     * Checks if the channel is a voice channel.
     *
     * @returns {boolean} True if the channel is a voice channel, otherwise false.
     */
    isVoice(): this is VoiceChannel;
    /**
     * Checks if the channel is a group channel.
     *
     * @returns {boolean} True if the channel is a group channel, otherwise false.
     */
    isGroup(): this is GroupChannel;
    /**
     * Checks if the channel is part of a server.
     *
     * @returns {boolean} True if the channel is a server channel, otherwise false.
     */
    inServer(): this is ServerChannel;
    /**
     * Converts the channel to a string representation.
     *
     * @returns {string} A string representation of the channel in the format `<#channelId>`.
     */
    toString(): string;
    /**
     * Fetches the latest data for the channel from the client's channel collection.
     *
     * @param {boolean} [force=true] - Whether to force a fetch even if the channel is cached.
     * @returns {Promise<Channel>} A promise that resolves with the updated channel instance.
     */
    fetch(force?: boolean): Promise<Channel>;
    edit(data: Partial<CreateChannelOptions>): Promise<{
        channel_type: string;
        _id: string;
        user: string;
    }>;
    /**
     * Sets role permissions for this channel.
     *
     * @param roleId - The ID of the role to set permissions for.
     * @param allow - Array of permissions to allow for the role.
     * @returns A promise that resolves when the permissions have been updated.
     *
     * @throws {TypeError} If the channel ID is invalid.
     *
     * @example
     * ```typescript
     * // Allow specific permissions
     * await channel.setRolePermissions(roleId, ["ViewChannel", "SendMessage"]);
     * ```
     */
    setRolePermissions(roleId: string, allow: editablePermissions["a"]): Promise<void>;
    /**
     * Sets role permissions for this channel.
     *
     * @param roleId - The ID of the role to set permissions for.
     * @param allow - Array of permissions to allow for the role.
     * @param deny - Array of permissions to deny for the role.
     * @returns A promise that resolves when the permissions have been updated.
     *
     * @throws {TypeError} If the channel ID is invalid.
     *
     * @example
     * ```typescript
     * // Set both allow and deny permissions
     * await channel.setRolePermissions(roleId, ["ViewChannel"], ["ManageMessages"]);
     * ```
     */
    setRolePermissions(roleId: string, allow: editablePermissions["a"], deny: editablePermissions["d"]): Promise<void>;
    /**
     * Sets role permissions for this channel.
     *
     * @param roleId - The ID of the role to set permissions for.
     * @param options - Object containing allow and/or deny permissions.
     * @returns A promise that resolves when the permissions have been updated.
     *
     * @throws {TypeError} If the channel ID is invalid or if both allow and deny are undefined.
     *
     * @example
     * ```typescript
     * // Allow specific permissions only
     * await channel.setRolePermissions(roleId, { allow: ["ViewChannel", "SendMessage"] });
     *
     * // Deny specific permissions only
     * await channel.setRolePermissions(roleId, { deny: ["ManageMessages"] });
     *
     * // Set both allow and deny permissions
     * await channel.setRolePermissions(roleId, {
     *   allow: ["ViewChannel"],
     *   deny: ["ManageMessages"]
     * });
     * ```
     */
    setRolePermissions(roleId: string, options: {
        allow?: editablePermissions["a"];
        deny?: editablePermissions["d"];
    }): Promise<void>;
    /**
     * Sets default permissions for this channel.
     *
     * @param allow - Array of permissions to allow by default.
     * @returns A promise that resolves when the permissions have been updated.
     *
     * @throws {TypeError} If the channel ID is invalid.
     *
     * @example
     * ```typescript
     * // Allow specific permissions
     * await channel.setDefaultPermissions(["ViewChannel", "SendMessage"]);
     * ```
     */
    setDefaultPermissions(allow: editablePermissions["a"]): Promise<void>;
    /**
     * Sets default permissions for this channel.
     *
     * @param options - Object containing allow and/or deny permissions.
     * @returns A promise that resolves when the permissions have been updated.
     *
     * @throws {TypeError} If the channel ID is invalid or if both allow and deny are undefined.
     *
     * @example
     * ```typescript
     * // Allow specific permissions only
     * await channel.setDefaultPermissions({ allow: ["ViewChannel", "SendMessage"] });
     *
     * // Deny specific permissions only
     * await channel.setDefaultPermissions({ deny: ["ManageMessages"] });
     *
     * // Set both allow and deny permissions
     * await channel.setDefaultPermissions({
     *   allow: ["ViewChannel"],
     *   deny: ["ManageMessages"]
     * });
     * ```
     */
    setDefaultPermissions(options: {
        allow?: editablePermissions["a"];
        deny?: editablePermissions["d"];
    }): Promise<void>;
    /**
     * Sets default permissions for this channel (legacy format).
     *
     * @param permissions - Object containing allow and deny permissions.
     * @returns A promise that resolves when the permissions have been updated.
     *
     * @throws {TypeError} If the channel ID is invalid.
     *
     * @example
     * ```typescript
     * // Legacy format
     * await channel.setDefaultPermissions({
     *   a: ["ViewChannel"],
     *   d: ["ManageMessages"]
     * });
     * ```
     */
    setDefaultPermissions(permissions: editablePermissions): Promise<void>;
    /**
     * Creates a new webhook in this channel.
     *
     * @param name - The name of the webhook
     * @param avatar - Optional avatar for the webhook. Can be a URL string, Readable stream, or File object
     * @returns Promise resolving to the created webhook response
     *
     * @example
     * ```typescript
     * const webhook = await channel.createWebhook("My Webhook", "https://example.com/avatar.png");
     * ```
     */
    createWebhook(name: string, avatar?: Readable | string | File): Promise<createWebhookResponse>;
    /**
     * Retrieves all webhooks for this channel.
     *
     * @returns Promise resolving to an array of webhook responses
     *
     * @example
     * ```typescript
     * const webhooks = await channel.getWebhooks();
     * console.log(`Found ${webhooks.length} webhooks`);
     * ```
     */
    getWebhooks(): Promise<createWebhookResponse[]>;
    /**
     * Retrieves a specific webhook by ID and token.
     *
     * @param webhookId - The ID of the webhook to retrieve
     * @param token - The token of the webhook
     * @returns Promise resolving to the webhook response
     *
     * @example
     * ```typescript
     * const webhook = await channel.getWebhook("webhookId", "webhookToken");
     * console.log(`Webhook name: ${webhook.name}`);
     * ```
     */
    getWebhook(webhookId: string, token: string): Promise<createWebhookResponse>;
    /**
     * Sends a message through a webhook in this channel.
     *
     * @param webhookId - The ID of the webhook to send the message through
     * @param token - The token of the webhook
     * @param content - The message content. Can be a string or MessageOptions object with attachments and embeds
     * @returns Promise resolving to the sent message
     *
     * @example
     * ```typescript
     * // Send a simple text message
     * await channel.sendWebhookMessage("webhookId", "token", "Hello, world!");
     *
     * // Send a message with embeds and attachments
     * await channel.sendWebhookMessage("webhookId", "token", {
     *   content: "Check out this image!",
     *   attachments: ["https://example.com/image.png"],
     *   embeds: [myEmbed]
     * });
     * ```
     */
    sendWebhookMessage(webhookId: string, token: string, content: MessageOptions | string): Promise<Message>;
    /**
     * Deletes a webhook.
     *
     * @param webhookId - The ID of the webhook to delete
     * @param token - The token of the webhook
     * @returns Promise that resolves when the webhook is deleted
     *
     * @example
     * ```typescript
     * await channel.deleteWebhook("webhookId", "webhookToken");
     * console.log("Webhook deleted successfully");
     * ```
     */
    deleteWebhook(webhookId: string, token: string): Promise<void>;
    /**
     * Edits a webhook's properties.
     *
     * @param webhookId - The ID of the webhook to edit
     * @param token - The token of the webhook
     * @param options - The options to edit on the webhook
     * @returns Promise resolving to the updated webhook response
     *
     * @example
     * ```typescript
     * const updatedWebhook = await channel.editWebhook("webhookId", "token", {
     *   name: "New Webhook Name",
     *   avatar: "https://example.com/new-avatar.png"
     * });
     * ```
     */
    editWebhook(webhookId: string, token: string, options: editWebhookOptions): Promise<createWebhookResponse>;
    /**
     * Retrieves partial information about a webhook using only its ID.
     * This method provides limited webhook information without requiring a token.
     *
     * @param webhookId - The ID of the webhook to retrieve partial information for
     * @returns Promise resolving to the webhook response with partial information
     *
     * @example
     * ```typescript
     * const partialWebhook = await channel.getPartialWebhook("webhookId");
     * console.log(`Webhook name: ${partialWebhook.name}`);
     * ```
     */
    getPartialWebhook(webhookId: string): Promise<createWebhookResponse>;
}

/**
 * Interface representing a text-based channel, which supports sending and managing messages.
 */
interface TextBasedChannel {
    /** Manages the messages in the channel. */
    messages: MessageManager;
    /** The ID of the last message sent in the channel, or `null` if no message exists. */
    lastMessageId: string | null;
    /** The last message sent in the channel, or `null` if no message exists. */
    lastMessage: MessageStruct | null;
    /**
     * Sends a message to the channel.
     *
     * @param {MessageOptions | string} options - The message content or options for the message.
     * @returns {Promise<Message>} A promise that resolves with the sent message.
     *
     * @example
     * ```typescript
     * await channel.send("Hello, world!");
     * ```
     */
    send(options: MessageOptions | string): Promise<MessageStruct>;
    /**
     * Deletes multiple messages from the channel.
     *
     * @param {MessageResolvable[] | Map<string, Message> | number} messages - The messages to delete. This can be an array of message resolvables, a map of messages, or a number indicating how many recent messages to delete.
     * @returns {Promise<void>} A promise that resolves when the messages have been successfully deleted.
     *
     * @example
     * ```typescript
     * await channel.bulkDelete(10); // Deletes the last 10 messages.
     * ```
     */
    bulkDelete(messages: MessageResolvable[] | Map<string, MessageStruct> | number): Promise<void>;
}

type APIDirectChannel = Extract<Channel$1, {
    channel_type: "DirectMessage";
}>;
/**
 * Represents a direct message (DM) channel between users.
 *
 * @extends Channel
 */
declare class DMChannel extends Channel implements TextBasedChannel {
    /** The type of the channel, which is always `DM` for direct message channels. */
    readonly type = ChannelTypes.DM;
    /** Whether the DM channel is currently active. */
    active: boolean;
    /** The default permissions for the DM channel. */
    permissions: Readonly<ChannelPermissions>;
    /** Manages the messages in this DM channel. */
    messages: MessageManager;
    /** The ID of the last message sent in this DM channel, if any. */
    lastMessageId: string | null;
    /**
     * Creates a new DMChannel instance.
     *
     * @param {client} client - The client instance.
     * @param {APIDirectChannel} data - The raw data for the DM channel from the API.
     */
    constructor(client: client, data: APIDirectChannel);
    /**
     * Updates the DM channel instance with new data from the API.
     *
     * @param {APIDirectChannel} data - The raw data for the DM channel from the API.
     * @returns {this} The updated DM channel instance.
     * @protected
     */
    protected _patch(data: APIDirectChannel): this;
    /**
     * Retrieves the last message sent in this DM channel.
     *
     * @returns {Message | null} The last message, or `null` if no message exists.
     */
    get lastMessage(): MessageStruct | null;
    /**
     * Deletes multiple messages from this DM channel.
     *
     * @param {MessageResolvable[] | Map<string, Message> | number} messages - The messages to delete. This can be an array of message resolvables, a map of messages, or a number indicating how many recent messages to delete.
     * @returns {Promise<void>} A promise that resolves when the messages have been successfully deleted.
     *
     * @example
     * ```typescript
     * await dmChannel.bulkDelete(10); // Deletes the last 10 messages.
     * ```
     */
    bulkDelete(messages: MessageResolvable[] | Map<string, MessageStruct> | number): Promise<void>;
    /**
     * Sends a message to this DM channel.
     *
     * @param {MessageOptions | string} options - The message content or options for the message.
     * @returns {Promise<Message>} A promise that resolves with the sent message.
     *
     * @example
     * ```typescript
     * await dmChannel.send("Hello, world!");
     * ```
     */
    send(options: MessageOptions | string): Promise<MessageStruct>;
}

/**
 * Events emitted by the AudioPlayer
 */
interface AudioPlayerEvents {
    connected: [channelId: string, serverId: string, roomName?: string];
    disconnected: [channelId: string, serverId: string, reason?: string];
    audioStart: [source: string, type: string];
    audioEnd: [source: string, type: string];
    audioError: [source: string, type: string, error: Error];
    volumeChanged: [oldVolume: number, newVolume: number];
    muted: [previousVolume: number];
    unmuted: [newVolume: number];
    trackPublished: [trackId: string];
    trackStopped: [trackId: string];
    conversionStart: [source: string, sampleRate: number, channels: number];
    conversionEnd: [source: string, samplesProcessed: number];
    conversionError: [source: string, error: Error];
    debug: [message: string, data?: any];
    error: [error: Error, context?: string];
}
declare interface AudioPlayer {
    on<K extends keyof AudioPlayerEvents>(event: K, listener: (...args: AudioPlayerEvents[K]) => void): this;
    off<K extends keyof AudioPlayerEvents>(event: K, listener: (...args: AudioPlayerEvents[K]) => void): this;
    removeAllListeners<K extends keyof AudioPlayerEvents>(event?: K): this;
}
declare class AudioPlayer extends EventEmitter {
    private readonly channelId;
    private readonly serverId;
    private readonly client;
    private _volume;
    private room?;
    private publications;
    private audioSources;
    private isConnected;
    private shouldStop;
    private isStreaming;
    constructor(channelId: string, serverId: string, client: client);
    /**
     * Get the channel ID this player is associated with
     */
    get channel(): string;
    /**
     * Get the server ID this player is associated with
     */
    get server(): string;
    /**
     * Get current volume level (0.0 to 2.0)
     */
    get volume(): number;
    /**
     * Check if the player is connected to a voice channel
     */
    get connected(): boolean;
    /**
     * Set volume level
     * @param level - Volume level from 0.0 (mute) to 2.0 (200%)
     */
    setVolume(level: number): void;
    /**
     * Increase volume by specified amount
     * @param amount - Amount to increase (default: 0.1)
     */
    increaseVolume(amount?: number): void;
    /**
     * Decrease volume by specified amount
     * @param amount - Amount to decrease (default: 0.1)
     */
    decreaseVolume(amount?: number): void;
    /**
     * Mute audio (set volume to 0)
     */
    mute(): void;
    /**
     * Unmute audio (restore to 100% if currently muted)
     */
    unmute(): void;
    /**
     * Apply volume to PCM audio data
     * @param pcmData - Int16Array audio data
     * @returns Modified PCM data with volume applied
     * @private
     */
    private applyVolume;
    /**
     * Check if a string is a valid URL
     * @param input - The string to check
     * @returns True if the input is a valid URL
     */
    private isUrl;
    /**
     * Check if a string is a valid file path that exists
     * @param input - The string to check
     * @returns True if the input is an existing file path
     * @private
     */
    private isFilePath;
    /**
     * Check if input is a Readable stream
     * @param input - The input to check
     * @returns True if the input is a Readable stream
     * @private
     */
    private isStream;
    /**
     * Connect to the voice channel
     */
    connect(targetChannelId?: string): Promise<void>;
    /**
     * Generic play method that automatically detects the input type and uses the appropriate play method
     * @param input - Can be a URL string, file path string, or Readable stream
     * @returns Promise that resolves when playback starts
     *
     * @example
     * ```typescript
     * // Play from URL
     * await player.play("https://example.com/audio.mp3");
     *
     * // Play from file path
     * await player.play("/path/to/audio.mp3");
     *
     * // Play from stream
     * await player.play(readableStream);
     * ```
     */
    play(input: string | Readable$1): Promise<void>;
    /**
     * Play audio from a URL (supports both files and streaming URLs like radio stations)
     * @private
     */
    private playFromUrl;
    /**
     * Play audio from a stream in real-time (for radio stations, live streams)
     */
    private playStreamingAudio;
    /**
     * Play audio from a finite stream (for regular audio files)
     * @private
     */
    private playFromStream; /**
     * Convert audio to PCM format using FFmpeg
     * @private
     */
    private convertAudioToPCM;
    /**
     * Publish PCM audio to the voice channel
     */
    private publishPCMAudio;
    /**
     * Play audio from a file
     * @private
     */
    private playFromFile;
    /**
     * Stop current audio playback
     */
    stop(trackName?: string): Promise<void>;
    /**
     * Disconnect from the voice channel
     */
    disconnect(): Promise<void>;
    /**
     * Handle unexpected disconnection
     * @private
     */
    private handleDisconnected;
    /**
     * Get player status information
     */
    getStatus(): {
        connected: boolean;
        volume: number;
        activeTracksCount: number;
        channelId: string;
        serverId: string;
    };
}

type APIGroupChannel = Extract<Channel$1, {
    channel_type: "Group";
}>;
/**
 * Represents a group channel, which allows multiple users to communicate.
 *
 * @extends Channel
 */
declare class GroupChannel extends Channel implements TextBasedChannel {
    /** The type of the channel, which is always `GROUP` for group channels. */
    readonly type = ChannelTypes.GROUP;
    /** The name of the group channel. */
    name: string;
    /** The description of the group channel, if any. */
    description: string | null;
    /** The ID of the user who owns the group channel. */
    ownerId: string;
    /** The permissions for the group channel. */
    permissions: Readonly<ChannelPermissions>;
    /** The icon of the group channel, if any. */
    icon: Attachment | null;
    /** Manages the messages in this group channel. */
    messages: MessageManager;
    /** The ID of the last message sent in this group channel, if any. */
    lastMessageId: string | null;
    /** A map of user IDs to their corresponding `User` instances in the group channel. */
    users: Map<string, User>;
    /** Whether the group channel is marked as NSFW (Not Safe For Work). */
    nsfw: boolean;
    /**
     * Creates a new GroupChannel instance.
     *
     * @param {client} client - The client instance.
     * @param {APIGroupChannel} data - The raw data for the group channel from the API.
     */
    constructor(client: client, data: APIGroupChannel);
    /**
     * Updates the group channel instance with new data from the API.
     *
     * @param {APIGroupChannel} data - The raw data for the group channel from the API.
     * @returns {this} The updated group channel instance.
     * @protected
     */
    protected _patch(data: APIGroupChannel): this;
    /**
     * Retrieves the last message sent in this group channel.
     *
     * @returns {Message | null} The last message, or `null` if no message exists.
     */
    get lastMessage(): MessageStruct | null;
    /**
     * Retrieves the owner of the group channel.
     *
     * @returns {User | null} The owner of the group channel, or `null` if not found.
     */
    get owner(): User | null;
    /**
     * Deletes multiple messages from this group channel.
     *
     * @param {MessageResolvable[] | Map<string, Message> | number} messages - The messages to delete. This can be an array of message resolvables, a map of messages, or a number indicating how many recent messages to delete.
     * @returns {Promise<void>} A promise that resolves when the messages have been successfully deleted.
     *
     * @example
     * ```typescript
     * await groupChannel.bulkDelete(10); // Deletes the last 10 messages.
     * ```
     */
    bulkDelete(messages: MessageResolvable[] | Map<string, MessageStruct> | number): Promise<void>;
    /**
     * Creates an invite for the group channel.
     *
     * @returns {Promise<Invite>} A promise that resolves with the created invite.
     *
     * @example
     * ```typescript
     * const invite = await groupChannel.createInvite();
     * console.log(`Invite created: ${invite}`);
     * ```
     */
    createInvite(): Promise<Invite>;
    /**
     * Adds a user to the group channel.
     *
     * @param {UserResolvable} user - The user to add to the group channel.
     * @returns {Promise<void>} A promise that resolves when the user has been successfully added.
     *
     * @example
     * ```typescript
     * await groupChannel.add(user);
     * ```
     */
    add(user: UserResolvable): Promise<void>;
    /**
     * Removes a user from the group channel.
     *
     * @param {UserResolvable} user - The user to remove from the group channel.
     * @returns {Promise<void>} A promise that resolves when the user has been successfully removed.
     *
     * @example
     * ```typescript
     * await groupChannel.remove(user);
     * ```
     */
    remove(user: UserResolvable): Promise<void>;
    /**
     * Leaves the group channel.
     *
     * @returns {Promise<void>} A promise that resolves when the group channel has been successfully left.
     *
     * @example
     * ```typescript
     * await groupChannel.leave();
     * ```
     */
    leave(): Promise<void>;
    /**
     * Sends a message to this group channel.
     *
     * @param {MessageOptions | string} options - The message content or options for the message.
     * @returns {Promise<Message>} A promise that resolves with the sent message.
     *
     * @example
     * ```typescript
     * await groupChannel.send("Hello, group!");
     * ```
     */
    send(options: MessageOptions | string): Promise<MessageStruct>;
    /**
     * Creates and connects an AudioPlayer to this voice channel in one step.
     * This is a convenience method that combines createPlayer() and connect().
     *
     * @returns {Promise<AudioPlayer>} A promise that resolves to a connected AudioPlayer
     *
     * @example
     * ```typescript
     * const voiceChannel = await client.channels.fetch('voice-channel-id') as VoiceChannel;
     * const player = await voiceChannel.connect();
     *
     * // Already connected, ready to play
     * await player.playFromUrl('https://example.com/music.mp3');
     * ```
     */
    connect(): Promise<AudioPlayer>;
    /** Disconnects the AudioPlayer from this voice channel's server. */
    disconnect(): Promise<void>;
    /** Stops the AudioPlayer in this voice channel's server. */
    stop(): Promise<void>;
    /** Plays audio through the AudioPlayer connected to this voice channel.
     * @param source - The audio source (URL, file path, or stream)
     */
    play(source: string): Promise<void>;
    /** Retrieves the AudioPlayer associated with this voice channel, if any.
     * @returns {Promise<AudioPlayer | null>} A promise that resolves to the AudioPlayer or null if not found
     */
    getPlayer(): Promise<AudioPlayer | null>;
}

/**
 * Represents an invite to a server or channel.
 *
 * @extends Base
 */
declare class Invite extends Base {
    /** The ID of the server associated with the invite, if any. */
    serverId: string | null;
    /** The ID of the user who created the invite. */
    inviterId: string;
    /** The ID of the channel associated with the invite. */
    channelId: string;
    /**
     * Creates a new Invite instance.
     *
     * @param {client} client - The client instance.
     * @param {APIInvite} data - The raw data for the invite from the API.
     */
    constructor(client: client, data: Invite$1);
    /**
     * Updates the invite instance with new data from the API.
     *
     * @param {APIInvite} data - The raw data for the invite from the API.
     * @returns {this} The updated invite instance.
     * @protected
     */
    protected _patch(data: Invite$1): this;
    /**
     * Retrieves the server associated with the invite.
     *
     * @returns {Server | null} The server associated with the invite, or `null` if not found.
     */
    get server(): Server | null;
    /**
     * Retrieves the channel associated with the invite.
     *
     * @returns {Channel | null} The channel associated with the invite, or `null` if not found.
     */
    get channel(): Channel | null;
    /**
     * Retrieves the user who created the invite.
     *
     * @returns {User | null} The user who created the invite, or `null` if not found.
     */
    get inviter(): User | null;
}

/**
 * Represents the mentions in a message, including users and server members.
 */
declare class Mentions {
    readonly message: MessageStruct;
    protected _users: string[];
    /** The client instance. */
    readonly client: client;
    /**
     * Creates a new Mentions instance.
     *
     * @param {Message} message - The message associated with the mentions.
     * @param {string[]} _users - An array of user IDs mentioned in the message.
     */
    constructor(message: MessageStruct, _users: string[]);
    /**
     * Checks if a specific user is mentioned in the message.
     *
     * @param {UserResolvable} user - The user to check.
     * @returns {boolean} `true` if the user is mentioned, otherwise `false`.
     * @throws {TypeError} Throws an error if the user cannot be resolved.
     *
     * @example
     * ```typescript
     * if (mentions.has(someUser)) {
     *   console.log("User is mentioned!");
     * }
     * ```
     */
    has(user: UserResolvable): boolean;
    /**
     * Retrieves the server members mentioned in the message.
     *
     * @returns {Map<string, ServerMember> | null} A map of user IDs to `ServerMember` instances, or `null` if the message is not in a server.
     *
     * @example
     * ```typescript
     * const members = mentions.members;
     * if (members) {
     *   members.forEach(member => console.log(member.displayName));
     * }
     * ```
     */
    get members(): Map<string, ServerMember> | null;
    /**
     * Retrieves the users mentioned in the message.
     *
     * @returns {Map<string, User>} A map of user IDs to `User` instances.
     *
     * @example
     * ```typescript
     * const users = mentions.users;
     * users.forEach(user => console.log(user.username));
     * ```
     */
    get users(): Map<string, User>;
}

type Embed = Embed$1;
type EmbedImage = Extract<Embed, {
    type: "Image";
}>;
type EmbedVideo = Extract<Embed, {
    type: "Video";
}>;
type EmbedSpecial = Special;
/**
 * Represents a message embed, which can include rich content such as titles, descriptions, URLs, and media.
 */
declare class MessageEmbed {
    #private;
    /**
     * Sets the title of the embed.
     *
     * @param {string} title - The title to set.
     * @returns {this} The updated `MessageEmbed` instance.
     */
    setTitle(title: string): this;
    /**
     * Sets the icon URL of the embed.
     *
     * @param {string} iconURL - The URL of the icon to set.
     * @returns {this} The updated `MessageEmbed` instance.
     */
    setIcon(iconURL: string): this;
    /**
     * Sets the color of the embed.
     *
     * @param {string} color - The color to set (e.g., a hex code).
     * @returns {this} The updated `MessageEmbed` instance.
     */
    setColor(color: string): this;
    /**
     * Sets the description of the embed.
     *
     * @param {string} description - The description to set.
     * @returns {this} The updated `MessageEmbed` instance.
     */
    setDescription(description: string): this;
    /**
     * Sets the URL of the embed.
     *
     * @param {string} url - The URL to set.
     * @returns {this} The updated `MessageEmbed` instance.
     */
    setURL(url: string): this;
    /**
     * Sets the media (e.g., image or video) of the embed.
     *
     * @param {Readable | string | File} media - The media URL, File or Stream to set.
     * @returns {this} The updated `MessageEmbed` instance.
     */
    setMedia(media: Readable | string | File$2): this;
    /**
     *
     * @param client The client instance used to send the embed.
     * @returns SendableEmbed
     * Converts the embed to a JSON object that can be sent to the API, including media handling.
     */
    toJSONWithMedia(client: client): Promise<SendableEmbed>;
    /**
     * Converts the embed to a JSON object that can be sent to the API.
     *
     * @returns {SendableEmbed} The JSON representation of the embed.
     */
    toJSON(): SendableEmbed;
}

type APINotesChannel = Extract<Channel$1, {
    channel_type: "SavedMessages";
}>;
/**
 * Represents a notes channel, which is used for saving personal messages.
 *
 * @extends Channel
 */
declare class NotesChannel extends Channel implements TextBasedChannel {
    /** The type of the channel, which is always `NOTES` for notes channels. */
    readonly type = ChannelTypes.NOTES;
    /** The ID of the user associated with the notes channel. */
    userId: string;
    /** The ID of the last message sent in this notes channel, if any. */
    lastMessageId: string | null;
    /** Manages the messages in this notes channel. */
    messages: MessageManager;
    /**
     * Creates a new NotesChannel instance.
     *
     * @param {client} client - The client instance.
     * @param {APINotesChannel} data - The raw data for the notes channel from the API.
     */
    constructor(client: client, data: APINotesChannel);
    /**
     * Updates the notes channel instance with new data from the API.
     *
     * @param {APINotesChannel} data - The raw data for the notes channel from the API.
     * @returns {this} The updated notes channel instance.
     * @protected
     */
    protected _patch(data: APINotesChannel): this;
    /**
     * Sends a message to this notes channel.
     *
     * @param {MessageOptions | string} options - The message content or options for the message.
     * @returns {Promise<Message>} A promise that resolves with the sent message.
     *
     * @example
     * ```typescript
     * await notesChannel.send("This is a saved message.");
     * ```
     */
    send(options: MessageOptions | string): Promise<MessageStruct>;
    /**
     * Deletes multiple messages from this notes channel.
     *
     * @param {MessageResolvable[] | Map<string, Message> | number} messages - The messages to delete. This can be an array of message resolvables, a map of messages, or a number indicating how many recent messages to delete.
     * @returns {Promise<void>} A promise that resolves when the messages have been successfully deleted.
     *
     * @example
     * ```typescript
     * await notesChannel.bulkDelete(5); // Deletes the last 5 messages.
     * ```
     */
    bulkDelete(messages: MessageResolvable[] | Map<string, MessageStruct> | number): Promise<void>;
    /**
     * Retrieves the last message sent in this notes channel.
     *
     * @returns {Message | null} The last message, or `null` if no message exists.
     */
    get lastMessage(): MessageStruct | null;
    /**
     * Retrieves the user associated with this notes channel.
     *
     * @returns {User} The user associated with the notes channel.
     */
    get user(): User;
}

interface Overwrite {
    allow: FullPermissions;
    deny: FullPermissions;
}
/**
 * Represents a server channel, which can be a text or voice channel.
 *
 * @extends Channel
 */
declare class ServerChannel extends Channel {
    /** The name of the channel. */
    name: string;
    /** The ID of the server this channel belongs to. */
    serverId: string;
    /** The description of the channel, or `null` if none is set. */
    description: string | null;
    /** The icon of the channel, or `null` if none is set. */
    icon: Attachment | null;
    /** Manages the messages in this Server channel. */
    messages: MessageManager;
    /** The permission overwrites for the channel. */
    overwrites: Map<string, Overwrite>;
    /** Whether the channel is marked as NSFW (Not Safe For Work). */
    nsfw: boolean;
    /**
     * Creates a new ServerChannel instance.
     *
     * @param {client} client - The client instance.
     * @param {APIServerChannel} data - The raw data for the server channel from the API.
     */
    constructor(client: client, data: APIServerChannel);
    /**
     * Updates the server channel instance with new data from the API.
     *
     * @param {APIServerChannel} data - The raw data for the server channel from the API.
     * @param {FieldsChannel[]} [clear=[]] - Fields to clear in the channel.
     * @returns {this} The updated server channel instance.
     * @protected
     */
    protected _patch(data: APIServerChannel, clear?: FieldsChannel[]): this;
    /**
     * Creates an invite for the server channel.
     *
     * @returns {Promise<Invite>} A promise that resolves with the created invite.
     *
     * @example
     * ```typescript
     * const invite = await serverChannel.createInvite();
     * console.log(`Invite created: ${invite}`);
     * ```
     */
    createInvite(): Promise<Invite>;
    /**
     * Retrieves the server this channel belongs to.
     *
     * @returns {Server} The server instance.
     */
    get server(): Server;
    /**
     * Sends a message to this Server channel.
     *
     * @param {MessageOptions | string} options - The message content or options for the message.
     * @returns {Promise<Message>} A promise that resolves with the sent message.
     *
     * @example
     * ```typescript
     * await serverChannel.send("Hello, world!");
     * ```
     */
    send(options: MessageOptions | string): Promise<MessageStruct>;
    /**
     * Retrieves the category this channel belongs to, if any.
     *
     * @returns {Category | null} The category instance, or `null` if the channel is not in a category.
     */
    get category(): Category | null;
}

/**
 * Represents a member of a server.
 *
 * @extends Base
 */
declare class ServerMember extends Base {
    /** The ID of the server this member belongs to. */
    serverId: string;
    /** The nickname of the member, or `null` if none is set. */
    nickname: string | null;
    /** The avatar of the member, or `null` if none is set. */
    avatar: Attachment | null;
    /** roles assigned to the member */
    roles: Role[];
    /**
     * Creates a new ServerMember instance.
     *
     * @param {client} client - The client instance.
     * @param {APIMember} data - The raw data for the server member from the API.
     */
    constructor(client: client, data: Member);
    /**
     * Updates the server member instance with new data from the API.
     *
     * @param {APIMember} data - The raw data for the server member from the API.
     * @param {FieldsMember[]} [clear=[]] - Fields to clear in the server member.
     * @returns {this} The updated server member instance.
     * @protected
     */
    protected _patch(data: Member, clear?: FieldsMember[]): this;
    /**
     * Sets the nickname of the server member.
     *
     * @param {string} [nickname] - The new nickname to set, or `undefined` to clear the nickname.
     * @returns {Promise<this>} A promise that resolves with the updated server member instance.
     *
     * @example
     * ```typescript
     * await member.setNickname("NewNickname");
     * ```
     */
    setNickname(nickname?: string): Promise<this>;
    /**
     * adds a role to the server member.
     * @param roleId - The ID of the role to add to the member.
     * @returns
     */
    addRole(roleId: string): Promise<this>;
    /**
     * Removes a role from the server member.
     *
     * @param {string} roleId - The ID of the role to remove from the member.
     * @returns {Promise<this>} A promise that resolves with the updated server member instance.
     *
     * @example
     * ```typescript
     * await member.removeRole("roleId");
     * ```
     */
    removeRole(roleId: string): Promise<this>;
    /**
     * Bans the server member.
     *
     * @param {string} [reason] - The reason for the ban.
     * @returns {Promise<void>} A promise that resolves when the member is banned.
     *
     * @example
     * ```typescript
     * await member.ban("Violation of rules");
     * ```
     */
    ban(reason?: string): Promise<void>;
    /**
     * Kicks the server member.
     *
     * @returns {Promise<void>} A promise that resolves when the member is kicked.
     *
     * @example
     * ```typescript
     * await member.kick();
     * ```
     */
    kick(): Promise<void>;
    /**
     * Leaves the server.
     *
     * @returns {Promise<void>} A promise that resolves when the member leaves the server.
     *
     * @example
     * ```typescript
     * await member.leave();
     * ```
     */
    leave(): Promise<void>;
    /**
     * Gets the effective permissions for this server member based on their roles.
     *
     * The permissions are calculated by:
     * 1. Starting with a base FullPermissions with no permissions
     * 2. For each role the member has, applying the role's allow permissions
     * 3. For each role the member has, removing the role's deny permissions
     *
     * @returns {FullPermissions} The effective permissions for this member
     *
     * @example
     * ```typescript
     * const permissions = member.getPermissions();
     * console.log(permissions.has('MANAGE_MESSAGES')); // true or false
     * ```
     */
    permissions(): FullPermissions;
    /**
     * Checks if this server member has a specific permission.
     *
     * @param {string | number | FullPermissions} permission - The permission to check for
     * @returns {boolean} Whether the member has the permission
     *
     * @example
     * ```typescript
     * if (member.hasPermission('MANAGE_MESSAGES')) {
     *   // Member can manage messages
     * }
     * ```
     *
     * note this works on the same basis as stoats permissions checking
     */
    hasPermission(permission: string | number | FullPermissions): boolean;
    /**
     * Retrieves the user associated with this server member.
     *
     * @returns {User} The user instance.
     */
    get user(): User;
    /**
     * Gets the username of the user.
     *
     * @returns {string} The username of the user.
     */
    get username(): string;
    /**
     * Gets whether the user is a bot.
     *
     * @returns {boolean} Whether the user is a bot.
     */
    get bot(): boolean;
    /**
     * Retrieves the server this member belongs to.
     *
     * @returns {Server} The server instance.
     */
    get server(): Server;
    /**
     * Converts the server member to a string representation.
     *
     * @returns {string} A string representation of the server member in the format `<@userId>`.
     */
    toString(): string;
    /**
     * Sets a timeout for the server member.
     * @param duration - The duration of the timeout as a Date object.
     * @returns A promise that resolves when the timeout is set.
     */
    timeout(duration: Date): Promise<void>;
}

type APITextChannel = Extract<Channel$1, {
    channel_type: "TextChannel";
}>;
/**
 * Represents a text channel in a server.
 *
 * @extends ServerChannel
 */
declare class TextChannel extends ServerChannel implements TextBasedChannel {
    /** The ID of the last message sent in this text channel, if any. */
    lastMessageId: string | null;
    /** Manages the messages in this text channel. */
    messages: MessageManager;
    /** The type of the channel, which is always `TEXT` for text channels. */
    readonly type = ChannelTypes.TEXT;
    /**
     * Creates a new TextChannel instance.
     *
     * @param {client} client - The client instance.
     * @param {APITextChannel} data - The raw data for the text channel from the API.
     */
    constructor(client: client, data: APITextChannel);
    /**
     * Updates the text channel instance with new data from the API.
     *
     * @param {APITextChannel} data - The raw data for the text channel from the API.
     * @returns {this} The updated text channel instance.
     * @protected
     */
    protected _patch(data: APITextChannel): this;
    /**
     * Retrieves the last message sent in this text channel.
     *
     * @returns {Message | null} The last message, or `null` if no message exists.
     */
    get lastMessage(): MessageStruct | null;
    /**
     * Sends a message to this text channel.
     *
     * @param {MessageOptions | string} options - The message content or options for the message.
     * @returns {Promise<Message>} A promise that resolves with the sent message.
     *
     * @example
     * ```typescript
     * await textChannel.send("Hello, world!");
     * ```
     */
    send(options: MessageOptions | string): Promise<MessageStruct>;
    /**
     * Deletes multiple messages from this text channel.
     *
     * @param {MessageResolvable[] | Map<string, Message> | number} messages - The messages to delete. This can be an array of message resolvables, a map of messages, or a number indicating how many recent messages to delete.
     * @returns {Promise<void>} A promise that resolves when the messages have been successfully deleted.
     *
     * @example
     * ```typescript
     * await textChannel.bulkDelete(10); // Deletes the last 10 messages.
     * ```
     */
    bulkDelete(messages: MessageResolvable[] | Map<string, MessageStruct> | number): Promise<void>;
}

type APIVoiceChannel = Extract<Channel$1, {
    channel_type: "VoiceChannel";
}>;
type Voice = {
    id: string;
    participants: voiceParticipant[];
};
type voiceParticipant = {
    id: string;
    joined_at: string;
    is_receving: boolean;
    is_publishing: boolean;
    screensharing: boolean;
    camera: boolean;
};
/**
 * Represents a voice channel in a server.
 *
 * @extends ServerChannel
 */
declare class VoiceChannel extends ServerChannel {
    /** The type of the channel, which is always `VOICE` for voice channels. */
    readonly type = ChannelTypes.VOICE;
    voice?: Map<string, voiceParticipant>;
    /**
     * Creates a new VoiceChannel instance.
     *
     * @param {client} client - The client instance.
     * @param {APIVoiceChannel} data - The raw data for the voice channel from the API.
     */
    constructor(client: client, data: APIVoiceChannel);
    /**
     * Updates the voice channel instance with new data from the API.
     *
     * @param {APIVoiceChannel} data - The raw data for the voice channel from the API.
     * @returns {this} The updated voice channel instance.
     * @protected
     */
    protected _patch(data: APIVoiceChannel): this;
    /**
     * Acknowledges the voice channel.
     *
     * @throws {TypeError} Throws an error because voice channels cannot be acknowledged.
     *
     * @example
     * ```typescript
     * try {
     *   await voiceChannel.ack();
     * } catch (error) {
     *   console.error(error.message); // "Cannot ack voice channel"
     * }
     * ```
     */
    ack(): Promise<void>;
    /**
     * Creates and connects an AudioPlayer to this voice channel in one step.
     * This is a convenience method that combines createPlayer() and connect().
     *
     * @returns {Promise<AudioPlayer>} A promise that resolves to a connected AudioPlayer
     *
     * @example
     * ```typescript
     * const voiceChannel = await client.channels.fetch('voice-channel-id') as VoiceChannel;
     * const player = await voiceChannel.connect();
     *
     * // Already connected, ready to play
     * await player.playFromUrl('https://example.com/music.mp3');
     * ```
     */
    connect(): Promise<AudioPlayer>;
    /** Disconnects the AudioPlayer from this voice channel's server. */
    disconnect(): Promise<void>;
    /** Stops the AudioPlayer in this voice channel's server. */
    stop(): Promise<void>;
    /** Plays audio through the AudioPlayer connected to this voice channel.
     * @param source - The audio source (URL, file path, or stream)
     */
    play(source: string): Promise<void>;
    /** Retrieves the AudioPlayer associated with this voice channel, if any.
     * @returns {Promise<AudioPlayer | null>} A promise that resolves to the AudioPlayer or null if not found
     */
    getPlayer(): Promise<AudioPlayer | null>;
}

/**
 * Represents a category in a server, which groups multiple channels together.
 *
 * @extends Base
 */
declare class Category extends Base {
    readonly server: Server;
    /** The name of the category. */
    name: string;
    /** An array of channel IDs that belong to this category. */
    protected _children: string[];
    /**
     * Creates a new Category instance.
     *
     * @param {Server} server - The server this category belongs to.
     * @param {APICategory} data - The raw data for the category from the API.
     */
    constructor(server: Server, data: Category$1);
    /**
     * Updates the category instance with new data from the API.
     *
     * @param {APICategory} data - The raw data for the category from the API.
     * @returns {this} The updated category instance.
     * @protected
     */
    protected _patch(data: Category$1): this;
    /**
     * Retrieves the channels that belong to this category.
     *
     * @returns {Map<string, ServerChannel>} A map of channel IDs to their corresponding `ServerChannel` instances.
     */
    get children(): Map<string, ServerChannel>;
    /**
     * Converts the category to a string representation.
     *
     * @returns {string} The name of the category.
     */
    toString(): string;
}

/**
 * Represents an emoji in the client.
 *
 * @extends Base
 */
declare class Emoji extends Base {
    /** The parent object of the emoji, which can be a server or other entity. */
    parent?: {
        type: string;
        id: string;
    } | null;
    /** The ID of the user who created the emoji, or `null` if not available. */
    creator_id?: string | null;
    /** The name of the emoji, or `null` if not set. */
    name?: string | null;
    /**
     * Creates a new Emoji instance.
     *
     * @param {client} client - The client instance.
     * @param {Emoji} data - The raw data for the emoji.
     */
    constructor(client: client, data: Emoji);
    /**
     * Retrieves the user who created the emoji.
     *
     * @returns {User | null} The creator of the emoji, or `null` if not found.
     */
    get creator(): User | null;
    /**
     * Retrieves the server associated with the emoji, if any.
     *
     * @returns {Server | null} The server instance, or `null` if the emoji is not associated with a server.
     */
    get server(): Server | null;
}

type UserResolvable = User | User$1 | MessageStruct | string;
declare class UserManager extends BaseManager<User, User$1> {
    /** @private */
    holds: typeof User;
    /**
     *
     * @param user The user to fetch
     * @returns A promise that resolves when the user is fetched
     */
    fetch(user: UserResolvable, { force }?: {
        force?: boolean | undefined;
    }): Promise<User>;
    /**
     * get a user form cache
     * @param resolvable The user to resolve
     * @returns The user or null if it cannot be resolved
     */
    resolve(resolvable: MessageStruct | User): User | null;
    resolve(resolvable: string | User$1): User | null;
    /**
     * get a user id form cache
     * @param resolvable The user to resolve
     * @returns The user id or null if it cannot be resolved
     */
    resolveId(resolvable: UserResolvable): string | null;
}

/**
 * Manages webhooks for the client.
 * Provides methods for creating, managing, and sending messages through webhooks.
 */
declare class WebhookManager {
    protected readonly client: client;
    /**
     * Creates a new WebhookManager instance.
     *
     * @param client - The client instance this manager belongs to
     */
    constructor(client: client);
    /**
     * Creates a new webhook in the specified channel.
     *
     * @param channelId - The ID of the channel where the webhook will be created
     * @param name - The name of the webhook
     * @param avatar - Optional avatar for the webhook. Can be a URL string, Readable stream, or File object
     * @returns Promise resolving to the created webhook response
     *
     * @example
     * ```typescript
     * const webhook = await client.webhooks.create("channelId", "My Webhook", "https://example.com/avatar.png");
     * ```
     */
    create(channelId: string, name: string, avatar?: Readable | string | File): Promise<createWebhookResponse>;
    /**
     * Retrieves all webhooks for the specified channel.
     *
     * @param channelId - The ID of the channel to get webhooks from
     * @returns Promise resolving to an array of webhook responses
     *
     * @example
     * ```typescript
     * const webhooks = await client.webhooks.getAll("channelId");
     * console.log(`Found ${webhooks.length} webhooks`);
     * ```
     */
    getAll(channelId: string): Promise<createWebhookResponse[]>;
    /**
     * Retrieves a specific webhook by ID and token.
     *
     * @param webhookId - The ID of the webhook to retrieve
     * @param token - The token of the webhook
     * @returns Promise resolving to the webhook response
     *
     * @example
     * ```typescript
     * const webhook = await client.webhooks.get("webhookId", "webhookToken");
     * console.log(`Webhook name: ${webhook.name}`);
     * ```
     */
    get(webhookId: string, token: string): Promise<createWebhookResponse>;
    /**
     * Sends a message through a webhook.
     *
     * @param webhookId - The ID of the webhook to send the message through
     * @param token - The token of the webhook
     * @param content - The message content. Can be a string or MessageOptions object with attachments and embeds
     * @returns Promise resolving to the sent message
     *
     * @example
     * ```typescript
     * // Send a simple text message
     * await client.webhooks.send("webhookId", "token", "Hello, world!");
     *
     * // Send a message with embeds and attachments
     * await client.webhooks.send("webhookId", "token", {
     *   content: "Check out this image!",
     *   attachments: ["https://example.com/image.png"],
     *   embeds: [myEmbed]
     * });
     * ```
     */
    send(webhookId: string, token: string, content: MessageOptions | string): Promise<Message>;
    /**
     * Deletes a webhook.
     *
     * @param webhookId - The ID of the webhook to delete
     * @param token - The token of the webhook
     * @returns Promise that resolves when the webhook is deleted
     *
     * @example
     * ```typescript
     * await client.webhooks.delete("webhookId", "webhookToken");
     * console.log("Webhook deleted successfully");
     * ```
     */
    delete(webhookId: string, token: string): Promise<void>;
    /**
     * Edits a webhook's properties.
     *
     * @param webhookId - The ID of the webhook to edit
     * @param token - The token of the webhook
     * @param options - The options to edit on the webhook
     * @returns Promise resolving to the updated webhook response
     *
     * @example
     * ```typescript
     * const updatedWebhook = await client.webhooks.edit("webhookId", "token", {
     *   name: "New Webhook Name",
     *   avatar: "https://example.com/new-avatar.png"
     * });
     * ```
     */
    edit(webhookId: string, token: string, options: editWebhookOptions): Promise<createWebhookResponse>;
    /**
     * Retrieves partial information about a webhook using only its ID.
     * This method provides limited webhook information without requiring a token.
     *
     * @param webhookId - The ID of the webhook to retrieve partial information for
     * @returns Promise resolving to the webhook response with partial information
     *
     * @example
     * ```typescript
     * const partialWebhook = await client.webhooks.getPartial("webhookId");
     * console.log(`Webhook name: ${partialWebhook.name}`);
     * ```
     */
    getPartial(webhookId: string): Promise<createWebhookResponse>;
}

/**
 * Represents the client user, which is the authenticated user or bot.
 *
 * @extends User
 */
declare class ClientUser extends User {
    /** The notes channel associated with the client user, if any. */
    notes: NotesChannel | null;
    owner: string | null;
    constructor(client: client, data: User$1);
    /**
     * Updates the username of the client user.
     *
     * @param {string} username - The new username to set.
     * @param {string} [password] - The current password of the user (required for non-bot accounts).
     * @returns {Promise<void>} A promise that resolves when the username has been successfully updated.
     * @throws {Error} Throws an error if the client user is a bot and a password is provided.
     *
     * @example
     * ```typescript
     * await clientUser.setUsername("NewUsername", "CurrentPassword");
     * ```
     */
    setUsername(username: string, password?: string): Promise<void>;
    setStatus(text?: string | null): Promise<void>;
    setStatus(presence?: Status): Promise<void>;
    /**
     * Updates the status of the client user.
     *
     * @param {string | null} [text] - The status text to set, or `null` to clear the status.
     * @param {Status} [presence] - The presence status (e.g., online, idle, etc.).
     * @returns {Promise<void>} A promise that resolves when the status has been successfully updated.
     *
     * @example
     * ```typescript
     * await clientUser.setStatus("Available", "Online");
     * ```
     */
    setStatus(text?: string | null, presence?: keyof typeof Status): Promise<void>;
}

/**
 * Manages the registration and retrieval of events for the client.
 * @private
 * @extends Event
 */
declare class EventManager {
    #private;
    protected readonly client: client;
    /**
     * Creates a new EventManager instance.
     *
     * @param {client} client - The client instance.
     */
    constructor(client: client);
    /**
     * Registers an event with the manager.
     *
     * @param {new (client: client) => CustomEvent} Event - The event class to register.
     */
    register(Event: new (client: client) => Event): void;
    /**
     * Retrieves a registered event by its name.
     *
     * @param {string} name - The name of the event to retrieve.
     * @returns {CustomEvent | null} The event instance, or `null` if not found.
     */
    get(name: string): Event | null;
}

/**
 * VoiceClient acts as a factory for creating AudioPlayer instances.
 * Users manage the AudioPlayer instances themselves rather than the VoiceClient managing them internally.
 * This design gives users full control over their voice connections and audio playback.
 */
declare class VoiceClient {
    private readonly client;
    /** Map of active audio players by server ID */
    private readonly players;
    constructor(client: client);
    /**
     * Creates a new AudioPlayer instance for the specified voice channel.
     *
     * @param channelId - The ID of the voice channel to connect to
     * @param serverId - The ID of the server containing the voice channel
     * @returns A new AudioPlayer instance that the user can manage
     *
     * @example
     * ```typescript
     * // Create a player for a specific voice channel
     * const player = client.voice.createPlayer('voice-channel-id', 'server-id');
     *
     * // Set up event listeners
     * player.on('connected', () => {
     *   console.log('Connected to voice channel!');
     * });
     *
     * player.on('audioStart', (source, type) => {
     *   console.log(`Started playing ${type}: ${source}`);
     * });
     *
     * // Connect and play audio
     * await player.connect();
     * await player.playFromFile('./music.mp3');
     *
     * // The user is responsible for managing the player lifecycle
     * await player.disconnect();
     * ```
     */
    createPlayer(channelId: string, serverId: string): AudioPlayer;
    /**
     * Creates a new AudioPlayer instance and immediately connects it to the voice channel.
     * This is a convenience method that combines createPlayer() and connect().
     *
     * @param channelId - The ID of the voice channel to connect to
     * @param serverId - The ID of the server containing the voice channel
     * @returns A new connected AudioPlayer instance
     *
     * @example
     * ```typescript
     * // Create and connect in one step
     * const player = await client.voice.connectToChannel('voice-channel-id', 'server-id');
     *
     * // Player is already connected and ready to use
     * await player.playFromUrl('https://example.com/music.mp3');
     * ```
     */
    connectToChannel(channelId: string, serverId: string): Promise<AudioPlayer>;
    /**
     * Disconnects the AudioPlayer from the specified server.
     *
     * @param serverId - The ID of the server to disconnect from
     */
    disconnectFromChannel(serverId: string): Promise<void>;
    /**
     * Stops the AudioPlayer in the specified server.
     *
     * @param serverId - The ID of the server whose player should be stopped
     */
    stopPlayerInChannel(serverId: string): Promise<void>;
}

/**
 * Represents the WebSocket client used for real-time communication with the API.
 */
declare class WebSocketClient {
    protected readonly client: client;
    /** The interval for sending heartbeats, in milliseconds. */
    heartbeatInterval?: number;
    /** The timestamp of the last ping sent, in milliseconds. */
    lastPingTimestamp?: number;
    /** Whether the last pong acknowledgment was received. */
    lastPongAck?: boolean;
    /** The WebSocket connection instance. */
    socket?: WebSocket | null;
    /** Whether the WebSocket client is connected. */
    connected: boolean;
    /** A promise representing the reconnecting process, or `null` if not reconnecting. */
    reconnecting: Promise<unknown> | null;
    /** Whether the WebSocket client is ready. */
    ready: boolean;
    /** The number of reconnection attempts made. */
    retryCount: number;
    /**
     * Creates a new WebSocketClient instance.
     *
     * @param {client} client - The client instance.
     */
    constructor(client: client);
    /**
     * Logs a debug message.
     *
     * @param {unknown} message - The message to log.
     * @private
     */
    private debug;
    /**
     * Sends data through the WebSocket connection.
     *
     * @param {unknown} data - The data to send.
     * @returns {Promise<void>} A promise that resolves when the data is sent.
     * @throws {Error} Throws an error if the WebSocket is not open.
     */
    send(data: unknown): Promise<void>;
    /**
     * Handles the WebSocket connection opening.
     *
     * @private
     */
    private onOpen;
    /**
     * Gets the current ping (latency) of the WebSocket connection.
     *
     * @returns {number} The ping in milliseconds, or `-0` if the WebSocket is not connected.
     */
    get ping(): number;
    /**
     * Sets the heartbeat interval for the WebSocket connection.
     *
     * @param {number} time - The interval time in milliseconds. Use `-1` to clear the interval.
     */
    setHeartbeatTimer(time: number): void;
    /**
     * Sends a heartbeat to the server to keep the connection alive.
     */
    sendHeartbeat(): void;
    /**
     * Handles WebSocket errors.
     *
     * @param {unknown} event - The error event.
     * @private
     */
    private onError;
    /**
     * Handles incoming WebSocket messages.
     *
     * @param {{ data: unknown }} param0 - The message event containing the data.
     * @private
     */
    private onMessage;
    /**
     * Handles the WebSocket connection closing.
     *
     * @param {{ code: number; reason: string }} event - The close event containing the code and reason.
     * @private
     */
    private onClose;
    /**
     * Handles incoming WebSocket packets.
     *
     * @param {any} packet - The packet data.
     * @private
     */
    private onPacket;
    /**
     * Connects to the WebSocket server.
     *
     * @returns {Promise<this>} A promise that resolves when the connection is established.
     */
    connect(): Promise<this>;
    /**
     * Destroys the WebSocket connection and clears its state.
     *
     * @returns {Promise<void>} A promise that resolves when the connection is destroyed.
     */
    destroy(isUserInitiated?: boolean): Promise<void>;
}

/**
 * Represents the main client for interacting with the API.
 *
 * @extends BaseClient
 */
declare class client extends BaseClient {
    /** The WebSocket client used for real-time communication. */
    protected readonly ws: WebSocketClient;
    /** Manages the channels in the client. */
    readonly channels: ChannelManager;
    /** Manages the servers in the client. */
    readonly servers: ServerManager;
    /** Manages the users in the client. */
    readonly users: UserManager;
    /** Manages the events in the client. */
    readonly events: EventManager;
    /** Manages the webhooks in the client. */
    readonly webhooks: WebhookManager;
    /** Manages the voice connections in the client. */
    readonly voice: VoiceClient;
    /** The authenticated user, or `null` if not logged in. */
    user: ClientUser | null;
    /** The timestamp when the client became ready, or `null` if not ready. */
    readyAt: Date | null;
    /**
     * Initializes the client.
     * @private
     */
    init(): Promise<void>;
    /**
     * Gets the timestamp when the client became ready.
     *
     * @returns {number | null} The ready timestamp in milliseconds, or `null` if not ready.
     */
    get readyTimestamp(): number | null;
    /**
     * Gets the uptime of the client in milliseconds.
     *
     * @returns {number | null} The uptime in milliseconds, or `null` if the client is not ready.
     */
    get upTime(): number | null;
    /**
     * Logs the client into the API using the provided token.
     *
     * @param {string} token - The authentication token.
     * @returns {Promise<void>} A promise that resolves when the client is logged in.
     * @throws {Error} Throws an error if the token is not provided or if the WebSocket connection fails.
     *
     * @example
     * ```typescript
     * await client.login("your-token-here");
     * ```
     */
    login(token: string): Promise<void>;
    /**
     * Destroys the client, disconnecting it from the API and clearing its state.
     *
     * @returns {Promise<void>} A promise that resolves when the client is destroyed.
     *
     * @example
     * ```typescript
     * await client.destroy();
     * ```
     */
    destroy(): Promise<void>;
    /**
     * Checks if the client is ready.
     *
     * @returns {boolean} `true` if the client is ready, otherwise `false`.
     *
     * @example
     * ```typescript
     * if (client.isReady()) {
     *   console.log("Client is ready!");
     * }
     * ```
     */
    isReady(): boolean;
}

declare abstract class BaseManager<Holds extends {
    id: string;
}, R = unknown> {
    protected readonly client: client;
    /** Shared default max size for all managers (can be changed globally). */
    static defaultMaxSize: number;
    /** Insertion ordered cache of items this manager holds. */
    readonly cache: Map<string, Holds>;
    /** Instance level max size (can be changed per manager instance). */
    protected maxSize: number;
    /** @private */
    Holds: any;
    constructor(client: client, maxSize?: number);
    /**
     * Adds a raw object to the cache, constructing the holdable class.
     * Automatically evicts oldest entries if the max size is exceeded.
     * @private
     */
    _add(raw: R): Holds;
    /** Remove an entry by id.
     * @private
     */
    _remove(id: string): void;
    /** Adjust the maximum size for this manager at runtime. */
    setMaxSize(size: number): void;
    /** Force eviction until cache size is within the limit. */
    protected enforceMaxSize(): void;
    abstract readonly holds: (new (...args: any[]) => Holds) | null;
    resolve(resolvable: Holds): Holds | null;
    resolve(resolvable: string | R): Holds | null;
    resolve(resolvable: string | R | Holds): Holds | null;
    resolveId(resolvable: string | Holds | R): string | null;
    valueOf(): this["cache"];
}

type ChannelResolvable = Channel | Channel$1 | string;
declare class ChannelManager extends BaseManager<Channel, Channel$1> {
    /** @private */
    holds: null;
    /** @private */
    _add(data: Channel$1 & {
        voice?: any;
    }): Channel;
    _remove(id: string): void;
    /**
     * used to delete a channel
     *
     * @param channel The channel to delete
     * @returns A promise that resolves when the channel is deleted
     */
    delete(channel: ChannelResolvable): Promise<void>;
    /**
     * used to fetch a channel
     *
     * @param channel The channel to fetch
     * @param force Whether to force fetch the channel using the api or return it form cache if able
     * @returns A promise that resolves with the fetched channel
     */
    fetch(channel: ChannelResolvable, { force }?: {
        force?: boolean | undefined;
    }): Promise<Channel>;
    /**
     * resolves a channel from a string or a channel object
     * @param channel The channel to resolve
     * @returns the resolved channel or null if not found
     */
    resolve(channel: ChannelResolvable): Channel | null;
    /**
     * resolves a channel id from a string or a channel object
     * @param channel The channel to resolve
     * @returns the resolved channel id or null if not found
     */
    resolveId(channel: ChannelResolvable): string | null;
}

type ServerResolvable = Server | Server$1 | string;
interface EditServerOptions {
    name?: string;
    description?: string;
}
declare class ServerManager extends BaseManager<Server, Server$1> {
    /** @private */
    readonly holds: typeof Server;
    /** @private */
    _remove(id: string): void;
    /**
     * edits a server
     * @param server The server to edit
     * @param options The options to edit the server with
     * @param options.name The name of the server
     * @param options.description The description of the server
     * @returns A promise that resolves when the server is edited
     */
    edit(server: ServerResolvable, options: EditServerOptions): Promise<void>;
    /**
     * leaves a server
     * @param server the server to leave
     */
    delete(server: ServerResolvable): Promise<void>;
    fetch(server: ServerResolvable, { force }?: {
        force?: boolean | undefined;
    }): Promise<Server>;
}

type RoleResolvable = Role | string;
declare class RoleManager extends BaseManager<Role, Role$1 & {
    id: string;
}> {
    protected readonly server: Server;
    /** @private */
    holds: typeof Role;
    constructor(server: Server);
    /** @private */
    _add(data: Role$1 & {
        id: string;
    }): Role;
    /**
     * creates a new role in the server
     * @param name The name of the role to create
     * @returns
     */
    create(name: string): Promise<Role>;
    /**
     * deletes a role from the server
     * @param role the role to delete
     * @returns A promise that resolves when the role is deleted
     */
    delete(role: RoleResolvable): Promise<void>;
    /**
     *
     * @param role the role to edit
     * @param data data to edit the role with
     * @param data.permissions The permissions to set for the role, in the format { a: allow, d: deny }
     * @param data.name The name of the role
     * @param data.colour The color of the role, or `null` if no color is set
     * @param data.hoist Whether the role is displayed separately in the member list
     * @param data.rank The rank of the role, used for ordering
     * @param data.remove Fields to remove from the role
     * @returns Role
     * @throws {TypeError} If the role ID is invalid
     */
    edit(role: RoleResolvable, data: editableRole): Promise<Role>;
}

type ServerMemberResolvable = ServerMember | User | Member | string;
interface EditServerMemberOptions {
    nickname?: string;
    avatar?: string;
    roles?: string[];
    timeout?: Date | number;
}
declare class ServerMemberManager extends BaseManager<ServerMember, Member> {
    protected readonly server: Server;
    /** @private */
    holds: typeof ServerMember;
    constructor(server: Server);
    /**
     * edit selected member in the server
     * @param member The member to edit
     * @param options The options to edit the member with
     * @param options.nickname The nickname of the member to set
     * @param options.avatar The avatar of the member to set
     * @param options.roles The roles of the member to set
     * @returns A promise that resolves when the member is edited
     */
    edit(member: ServerMemberResolvable, options: EditServerMemberOptions): Promise<void>;
    /**
     * ban selected member in the server
     * @param member The member to ban
     * @param reason the reason for the ban
     * @returns A promise that resolves when the member is banned
     */
    ban(member: ServerMemberResolvable, reason?: string): Promise<void>;
    /**
     * kick selected member in the server
     * @param member The member to kick
     * @returns A promise that resolves when the member is kicked
     */
    kick(member: ServerMemberResolvable): Promise<void>;
    /**
     * unban selected member in the server
     * @param member The member to unban
     * @returns A promise that resolves when the member is unbanned
     */
    unban(member: ServerMemberResolvable): Promise<void>;
    /**
     * set timeout for a member in the server
     * @param member The member to set the timeout for
     * @param duration The duration of the timeout as a Date object
     * @returns A promise that resolves when the timeout is set
     */
    timeout(member: string, duration: Date): Promise<void>;
    /**
     * fetch a member from the server
     * @param member The member to fetch
     * @returns A promise that resolves with the fetched member
     */
    fetch(member: ServerMemberResolvable): Promise<ServerMember>;
    fetch(): Promise<Map<string, ServerMember>>;
    /**
     * resolves a member from a string or a member object
     * @param member The member to resolve
     * @returns The id of the member or null if it cannot be resolved
     */
    resolveId(member: ServerMemberResolvable): string | null;
}

export { Attachment, AudioPlayer, type AudioPlayerEvents, type BadgeString, Badges, type BadgesResolvable, Base, BaseManager, BitField, type BitFieldResolvable, Category, Channel, ChannelManager, ChannelPermissions, type ChannelPermissionsResolvable, type ChannelPermissionsString, type ChannelResolvable, ChannelTypes, type CreateChannelOptions, DEFAULT_CLIENT_OPTIONS, DEFAULT_PERMISSION_DM, DMChannel, type EditServerMemberOptions, type EditServerOptions, type Embed, type EmbedImage, type EmbedSpecial, type EmbedVideo, Emoji, Events, FullPermissions, GroupChannel, Invite, Mentions, type MessageEditOptions, MessageEmbed, MessageManager, type MessageOptions, type MessageQueryOptions, type MessageReply, type MessageResolvable, type MessageSearchOptions, MessageStruct, NotesChannel, type Overwrite, type PartialObject, Presence, Role, RoleManager, type RoleResolvable, SYSTEM_USER_ID, Server, ServerChannel, ServerChannelManager, type ServerChannelResolvable, ServerManager, ServerMember, ServerMemberManager, type ServerMemberResolvable, ServerPermissions, type ServerPermissionsResolvable, type ServerPermissionsString, type ServerResolvable, Status, TextChannel, UUID, User, UserManager, UserPermissions, type UserPermissionsResolvable, type UserPermissionsString, type UserResolvable, type Voice, VoiceChannel, WSEvents, apiUrl, client, type voiceParticipant };
