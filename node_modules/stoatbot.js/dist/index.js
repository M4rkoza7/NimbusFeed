"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : /* @__PURE__ */ Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __pow = Math.pow;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __await = function(promise, isYieldStar) {
  this[0] = promise;
  this[1] = isYieldStar;
};
var __yieldStar = (value) => {
  var obj = value[__knownSymbol("asyncIterator")], isAwait = false, method, it = {};
  if (obj == null) {
    obj = value[__knownSymbol("iterator")]();
    method = (k) => it[k] = (x) => obj[k](x);
  } else {
    obj = obj.call(value);
    method = (k) => it[k] = (v) => {
      if (isAwait) {
        isAwait = false;
        if (k === "throw") throw v;
        return v;
      }
      isAwait = true;
      return {
        done: false,
        value: new __await(new Promise((resolve) => {
          var x = obj[k](v);
          if (!(x instanceof Object)) __typeError("Object expected");
          resolve(x);
        }), 1)
      };
    };
  }
  return it[__knownSymbol("iterator")] = () => it, method("next"), "throw" in obj ? method("throw") : it.throw = (x) => {
    throw x;
  }, "return" in obj && method("return"), it;
};

// src/index.ts
var index_exports = {};
__export(index_exports, {
  Attachment: () => Attachment,
  AudioPlayer: () => AudioPlayer,
  Badges: () => Badges,
  Base: () => Base,
  BaseManager: () => BaseManager,
  BitField: () => BitField,
  Category: () => Category,
  Channel: () => Channel,
  ChannelManager: () => ChannelManager,
  ChannelPermissions: () => ChannelPermissions,
  ChannelTypes: () => ChannelTypes,
  DEFAULT_CLIENT_OPTIONS: () => DEFAULT_CLIENT_OPTIONS,
  DEFAULT_PERMISSION_DM: () => DEFAULT_PERMISSION_DM,
  DMChannel: () => DMChannel3,
  Emoji: () => Emoji2,
  Events: () => Events,
  FullPermissions: () => FullPermissions,
  GroupChannel: () => GroupChannel2,
  Invite: () => Invite,
  Mentions: () => Mentions,
  MessageEmbed: () => MessageEmbed,
  MessageManager: () => MessageManager,
  MessageStruct: () => MessageStruct,
  NotesChannel: () => NotesChannel,
  Presence: () => Presence,
  Role: () => Role,
  RoleManager: () => RoleManager,
  SYSTEM_USER_ID: () => SYSTEM_USER_ID,
  Server: () => Server2,
  ServerChannel: () => ServerChannel,
  ServerChannelManager: () => ServerChannelManager,
  ServerManager: () => ServerManager,
  ServerMember: () => ServerMember3,
  ServerMemberManager: () => ServerMemberManager,
  ServerPermissions: () => ServerPermissions,
  Status: () => Status,
  TextChannel: () => TextChannel2,
  UUID: () => UUID,
  User: () => User,
  UserManager: () => UserManager,
  UserPermissions: () => UserPermissions,
  VoiceChannel: () => VoiceChannel2,
  WSEvents: () => WSEvents,
  apiUrl: () => apiUrl,
  client: () => client2
});
module.exports = __toCommonJS(index_exports);

// src/managers/baseManager.ts
var _BaseManager = class _BaseManager {
  constructor(client3, maxSize = _BaseManager.defaultMaxSize) {
    this.client = client3;
    /** Insertion ordered cache of items this manager holds. */
    this.cache = /* @__PURE__ */ new Map();
    this.maxSize = maxSize;
  }
  /**
   * Adds a raw object to the cache, constructing the holdable class.
   * Automatically evicts oldest entries if the max size is exceeded.
   * @private
   */
  _add(raw) {
    if (!this.holds) throw new Error("Holds is not defined");
    const obj = new this.holds(this.client, raw);
    this.cache.set(obj.id, obj);
    this.enforceMaxSize();
    return obj;
  }
  /** Remove an entry by id.
   * @private
   */
  _remove(id) {
    this.cache.delete(id);
  }
  /** Adjust the maximum size for this manager at runtime. */
  setMaxSize(size) {
    if (!Number.isFinite(size) || size < -1)
      throw new RangeError("maxSize must be a non-negative finite number");
    this.maxSize = size;
    this.enforceMaxSize();
  }
  /** Force eviction until cache size is within the limit. */
  enforceMaxSize() {
    if (this.maxSize === -1) return;
    if (this.maxSize === 0) {
      this.cache.clear();
      return;
    }
    while (this.cache.size > this.maxSize) {
      const oldestKey = this.cache.keys().next().value;
      if (oldestKey === void 0) break;
      this.cache.delete(oldestKey);
    }
  }
  resolve(resolvable) {
    var _a;
    const id = this.resolveId(resolvable);
    if (id) return (_a = this.cache.get(id)) != null ? _a : null;
    return null;
  }
  resolveId(resolvable) {
    var _a;
    if (resolvable == null) return null;
    if (typeof resolvable === "string") return resolvable;
    if (this.holds && resolvable instanceof this.holds) return resolvable.id;
    const raw = resolvable;
    if (typeof raw === "object" && "_id" in raw) (_a = raw._id) != null ? _a : null;
    return null;
  }
  valueOf() {
    return this.cache;
  }
};
/** Shared default max size for all managers (can be changed globally). */
_BaseManager.defaultMaxSize = -1;
var BaseManager = _BaseManager;

// src/utils/bitField.ts
var DEFAULT_BIT = 0;
var _BitField = class _BitField {
  constructor(bits = DEFAULT_BIT) {
    this.bitfield = DEFAULT_BIT;
    this.bitfield = this.self.resolve(bits);
  }
  /**
   * Resolves a bitfield or an array of bitfields into a single number.
   * @param bit The bitfield or array of bitfields to resolve.
   * @returns The resolved bitfield as a number.
   */
  static resolve(bit) {
    if (bit instanceof _BitField) return bit.bitfield;
    if (typeof bit === "number" && bit >= DEFAULT_BIT) return bit;
    if (Array.isArray(bit)) {
      return bit.map((p) => this.resolve(p)).reduce((prev, p) => prev | p, DEFAULT_BIT);
    }
    if (typeof this.FLAGS[bit] !== "undefined") return this.FLAGS[bit];
    throw new Error("BITFIELD_INVALID");
  }
  /**
   * Returns the class that this instance belongs to.
   * @returns The class of the bitfield.
   */
  get self() {
    return this.constructor;
  }
  /**
   * Checks if any of the bits in the bitfield are set.
   * @param bit The bitfield or array of bitfields to check.
   * @returns True if any bits are set, false otherwise.
   */
  any(bit) {
    bit = this.self.resolve(bit);
    return (this.bitfield & bit) !== DEFAULT_BIT;
  }
  /**
   * checks if a specific permission is set.
   */
  has(bit) {
    bit = this.self.resolve(bit);
    return (this.bitfield & bit) === bit;
  }
  /**
   * Returns an array of all the Permissions that are set in the bitfield.
   * @returns An array of flag names.
   */
  toArray() {
    return Object.keys(this.self.FLAGS).filter((bit) => this.has(bit));
  }
  add(...bits) {
    let total = 0;
    for (const bit of bits) {
      total |= this.self.resolve(bit);
    }
    if (Object.isFrozen(this)) {
      return new this.self(this.bitfield | total);
    }
    this.bitfield |= total;
    return this;
  }
  remove(...bits) {
    let total = 0;
    for (const bit of bits) {
      total |= this.self.resolve(bit);
    }
    if (Object.isFrozen(this)) {
      return new this.self(this.bitfield & ~total);
    }
    this.bitfield &= ~total;
    return this;
  }
  freeze() {
    return Object.freeze(this);
  }
  valueOf() {
    return this.bitfield;
  }
  /**
   *
   * @returns A record of all flags and their boolean values indicating whether they are set.
   */
  serialize() {
    const serialized = {};
    for (const [flag, bit] of Object.entries(this.self.FLAGS)) {
      serialized[flag] = this.has(bit);
    }
    return serialized;
  }
  *[Symbol.iterator]() {
    yield* __yieldStar(this.toArray());
  }
};
_BitField.FLAGS = {};
var BitField = _BitField;

// src/struct/base.ts
var Base = class _Base {
  /**
   * Creates a new Base instance.
   *
   * @param {client} client - The client instance.
   */
  constructor(client3) {
    this.client = client3;
  }
  /**
   * Compares this object with another to determine if they are equal.
   *
   * @param {this | null} [obj] - The object to compare with.
   * @returns {boolean} `true` if the objects are equal, otherwise `false`.
   */
  equals(obj) {
    if (!obj) return false;
    for (const key in obj) {
      const a = obj[key], b = this[key];
      if (a instanceof _Base && !a.equals(b)) return false;
      if (a instanceof BitField && a.bitfield !== b.bitfield)
        return false;
      if (typeof a === "object" && a !== null) continue;
      if (a !== b) return false;
    }
    return true;
  }
  /**
   * Updates the object with new data and returns a clone of the object.
   *
   * @param {PartialObject} data - The data to update the object with.
   * @param {string[]} [clear] - Fields to clear in the object.
   * @returns {this} A clone of the updated object.
   */
  _update(data, clear) {
    const clone = this._clone();
    this._patch(data, clear);
    return clone;
  }
  /**
   * Patches the object with new data.
   *
   * @param {PartialObject} data - The data to patch the object with.
   * @param {string[]} [_clear] - Fields to clear in the object.
   * @returns {this} The updated object.
   * @protected
   */
  _patch(data, _clear) {
    if ("id" in data) this.id = data.id;
    if ("_id" in data) {
      if (typeof data._id === "string") this.id = data._id;
      if (typeof data._id === "object") this.id = data._id.user;
    }
    return this;
  }
  /**
   * Creates a deep clone of the object.
   *
   * @returns {this} A clone of the object.
   */
  _clone() {
    const clone = Object.assign(Object.create(this), this);
    for (const key in clone) {
      const prop = clone[key];
      if (prop instanceof _Base) clone[key] = prop._clone();
    }
    return clone;
  }
};

// src/utils/UUID.ts
var import_crypto = require("crypto");
var _UUID = class _UUID extends null {
  static get PROG() {
    return (0, import_crypto.randomBytes)(1).readUInt8() / 255;
  }
  static time(now = Date.now()) {
    let mod, result = "";
    for (let i = this.TIME_LENGTH; i > 0; i--) {
      mod = now % this.ENCODING_LENGTH;
      result = this.ENCODING.charAt(mod) + result;
      now = (now - mod) / this.ENCODING_LENGTH;
    }
    return result;
  }
  static hash() {
    let result = "";
    for (let i = this.RANDOM_LENGTH; i > 0; i--) {
      let random = Math.floor(this.PROG * this.ENCODING_LENGTH);
      if (random === this.ENCODING_LENGTH) {
        random = this.ENCODING_LENGTH - 1;
      }
      result = this.ENCODING.charAt(random) + result;
    }
    return result;
  }
  static generate(timestamp = Date.now()) {
    return this.time(timestamp) + this.hash();
  }
  static timestampOf(id) {
    const timestamp = id.slice(0, this.TIME_LENGTH).split("").reverse().reduce((carry, char, index) => {
      const encodingIndex = this.ENCODING.indexOf(char);
      if (encodingIndex === -1) {
        throw new Error("invalid character found: " + char);
      }
      return carry += encodingIndex * Math.pow(this.ENCODING_LENGTH, index);
    }, 0);
    return new Date(timestamp);
  }
};
_UUID.ENCODING = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
_UUID.ENCODING_LENGTH = _UUID.ENCODING.length;
_UUID.RANDOM_LENGTH = 16;
_UUID.TIME_LENGTH = 10;
_UUID.TIME_MAX = Math.pow(2, 48) - 1;
var UUID = _UUID;

// src/utils/constants.ts
var Events = /* @__PURE__ */ ((Events2) => {
  Events2["CHANNEL_CREATE"] = "channelCreate";
  Events2["CHANNEL_DELETE"] = "channelDelete";
  Events2["CHANNEL_UPDATE"] = "channelUpdate";
  Events2["DEBUG"] = "debug";
  Events2["ERROR"] = "error";
  Events2["GROUP_JOIN"] = "groupJoin";
  Events2["GROUP_LEAVE"] = "groupLeave";
  Events2["MESSAGE"] = "message";
  Events2["MESSAGE_DELETE"] = "messageDelete";
  Events2["MESSAGE_DELETE_BULK"] = "messageDeleteBulk";
  Events2["MESSAGE_UPDATE"] = "messageUpdate";
  Events2["MESSAGE_REACT"] = "messageReact";
  Events2["MESSAGE_REACT_REMOVE"] = "messageUnreact";
  Events2["RAW"] = "raw";
  Events2["READY"] = "ready";
  Events2["ROLE_CREATE"] = "roleCreate";
  Events2["ROLE_DELETE"] = "roleDelete";
  Events2["ROLE_UPDATE"] = "roleUpdate";
  Events2["SERVER_CREATE"] = "serverCreate";
  Events2["SERVER_DELETE"] = "serverDelete";
  Events2["SERVER_MEMBER_JOIN"] = "serverMemberJoin";
  Events2["SERVER_MEMBER_LEAVE"] = "serverMemberLeave";
  Events2["SERVER_MEMBER_UPDATE"] = "serverMemberUpdate";
  Events2["SERVER_UPDATE"] = "serverUpdate";
  Events2["TYPING_START"] = "typingStart";
  Events2["TYPING_STOP"] = "typingStop";
  Events2["USER_UPDATE"] = "userUpdate";
  Events2["WEBHOOKS_CREATE"] = "webhookCreate";
  Events2["WEBHOOKS_DELETE"] = "webhookDelete";
  Events2["WEBHOOKS_UPDATE"] = "webhookUpdate";
  Events2["USER_VOICE_STATE_UPDATE"] = "userVoiceStateUpdate";
  Events2["VOICE_CHANNEL_JOIN"] = "voiceChannelJoin";
  Events2["VOICE_CHANNEL_LEAVE"] = "voiceChannelLeave";
  return Events2;
})(Events || {});
var WSEvents = /* @__PURE__ */ ((WSEvents2) => {
  WSEvents2["AUTHENTICATE"] = "Authenticate";
  WSEvents2["AUTHENTICATED"] = "Authenticated";
  WSEvents2["BEGIN_TYPING"] = "BeginTyping";
  WSEvents2["BULK"] = "Bulk";
  WSEvents2["CHANNEL_ACK"] = "ChannelAck";
  WSEvents2["CHANNEL_CREATE"] = "ChannelCreate";
  WSEvents2["CHANNEL_DELETE"] = "ChannelDelete";
  WSEvents2["CHANNEL_GROUP_JOIN"] = "ChannelGroupJoin";
  WSEvents2["CHANNEL_GROUP_LEAVE"] = "ChannelGroupLeave";
  WSEvents2["CHANNEL_START_TYPING"] = "ChannelStartTyping";
  WSEvents2["CHANNEL_STOP_TYPING"] = "ChannelStopTyping";
  WSEvents2["CHANNEL_UPDATE"] = "ChannelUpdate";
  WSEvents2["END_TYPING"] = "EndTyping";
  WSEvents2["ERROR"] = "Error";
  WSEvents2["MESSAGE"] = "Message";
  WSEvents2["MESSAGE_BULK_DELETE"] = "BulkMessageDelete";
  WSEvents2["MESSAGE_DELETE"] = "MessageDelete";
  WSEvents2["MESSAGE_UPDATE"] = "MessageUpdate";
  WSEvents2["PING"] = "Ping";
  WSEvents2["PONG"] = "Pong";
  WSEvents2["READY"] = "Ready";
  WSEvents2["SERVER_DELETE"] = "ServerDelete";
  WSEvents2["SERVER_MEMBER_JOIN"] = "ServerMemberJoin";
  WSEvents2["SERVER_MEMBER_LEAVE"] = "ServerMemberLeave";
  WSEvents2["SERVER_MEMBER_UPDATE"] = "ServerMemberUpdate";
  WSEvents2["SERVER_ROLE_DELETE"] = "ServerRoleDelete";
  WSEvents2["SERVER_ROLE_UPDATE"] = "ServerRoleUpdate";
  WSEvents2["SERVER_UPDATE"] = "ServerUpdate";
  WSEvents2["USER_RELATIONSHIP"] = "UserRelationship";
  WSEvents2["USER_UPDATE"] = "UserUpdate";
  WSEvents2["WEBHOOKS_CREATE"] = "WebhooksCreate";
  WSEvents2["WEBHOOKS_DELETE"] = "WebhooksDelete";
  WSEvents2["WEBHOOKS_UPDATE"] = "WebhooksUpdate";
  WSEvents2["VOICE_STATE_UPDATE"] = "VoiceStateUpdate";
  WSEvents2["VOICE_CHANNEL_JOIN"] = "VoiceChannelJoin";
  WSEvents2["VOICE_CHANNEL_LEAVE"] = "VoiceChannelLeave";
  return WSEvents2;
})(WSEvents || {});
var ChannelTypes = /* @__PURE__ */ ((ChannelTypes2) => {
  ChannelTypes2["DM"] = "DM";
  ChannelTypes2["GROUP"] = "GROUP";
  ChannelTypes2["TEXT"] = "TEXT";
  ChannelTypes2["VOICE"] = "VOICE";
  ChannelTypes2["NOTES"] = "NOTES";
  return ChannelTypes2;
})(ChannelTypes || {});
var DEFAULT_CLIENT_OPTIONS = {
  fetchMembers: true,
  rest: {
    timeout: 15e3,
    retries: 3
  },
  MessageCache: {
    maxSize: 1e3
  },
  ws: {
    heartbeatInterval: 3e4,
    reconnect: true
  }
};
var apiUrl = "https://api.stoat.chat";
var SYSTEM_USER_ID = "0".repeat(UUID.TIME_LENGTH + UUID.RANDOM_LENGTH);

// src/utils/permissions.ts
var ChannelPermissions = class extends BitField {
  constructor(bits) {
    super(bits);
  }
  static resolve(bit) {
    return super.resolve(bit);
  }
};
ChannelPermissions.FLAGS = {
  VIEW_CHANNEL: __pow(1, 0),
  SEND_MESSAGE: __pow(1, 22),
  MANAGE_MESSAGE: __pow(1, 2),
  MANAGE_CHANNEL: __pow(1, 3),
  VOICE_CALL: __pow(1, 4),
  INVITE_OTHERS: __pow(1, 5),
  EMBED_LINKS: __pow(1, 6),
  UPLOAD_FILES: __pow(1, 7)
};
var UserPermissions = class extends BitField {
  constructor(bits) {
    super(bits);
  }
  static resolve(bit) {
    return super.resolve(bit);
  }
};
UserPermissions.FLAGS = {
  ACCESS: __pow(1, 0),
  VIEW_PROFILE: __pow(1, 1),
  SEND_MESSAGES: __pow(1, 2),
  INVITE: __pow(1, 3)
};
var ServerPermissions = class extends BitField {
  constructor(bits) {
    super(bits);
  }
  static resolve(bit) {
    return super.resolve(bit);
  }
};
ServerPermissions.FLAGS = {
  VIEW_SERVER: __pow(1, 0),
  MANAGE_ROLES: __pow(1, 1),
  MANAGE_CHANNELS: __pow(1, 2),
  MANAGE_SERVER: __pow(1, 3),
  KICK_MEMBERS: __pow(1, 4),
  BAN_MEMBERS: __pow(1, 5),
  CHANGE_NICKNAME: __pow(1, 12),
  MANAGE_NICKNAMES: __pow(1, 13),
  CHANGE_AVATAR: __pow(1, 14),
  REMOVE_AVATARS: __pow(1, 15)
};
var FullPermissions = class extends BitField {
  constructor(bits) {
    super(bits);
  }
  static resolve(bit) {
    return super.resolve(bit);
  }
};
FullPermissions.FLAGS = {
  // * Generic permissions
  /// Manage the channel or channels on the server
  ManageChannel: __pow(2, 0),
  /// Manage the server
  ManageServer: __pow(2, 1),
  /// Manage permissions on servers or channels
  ManagePermissions: __pow(2, 2),
  /// Manage roles on server
  ManageRole: __pow(2, 3),
  /// Manage server customisation (includes emoji)
  ManageCustomisation: __pow(2, 4),
  // * Member permissions
  /// Kick other members below their ranking
  KickMembers: __pow(2, 6),
  /// Ban other members below their ranking
  BanMembers: __pow(2, 7),
  /// Timeout other members below their ranking
  TimeoutMembers: __pow(2, 8),
  /// Assign roles to members below their ranking
  AssignRoles: __pow(2, 9),
  /// Change own nickname
  ChangeNickname: __pow(2, 10),
  /// Change or remove other's nicknames below their ranking
  ManageNicknames: __pow(2, 11),
  /// Change own avatar
  ChangeAvatar: __pow(2, 12),
  /// Remove other's avatars below their ranking
  RemoveAvatars: __pow(2, 13),
  // * Channel permissions
  /// View a channel
  ViewChannel: __pow(2, 20),
  /// Read a channel's past message history
  ReadMessageHistory: __pow(2, 21),
  /// Send a message in a channel
  SendMessage: __pow(2, 22),
  /// Delete messages in a channel
  ManageMessages: __pow(2, 23),
  /// Manage webhook entries on a channel
  ManageWebhooks: __pow(2, 24),
  /// Create invites to this channel
  InviteOthers: __pow(2, 25),
  /// Send embedded content in this channel
  SendEmbeds: __pow(2, 26),
  /// Send attachments and media in this channel
  UploadFiles: __pow(2, 27),
  /// Masquerade messages using custom nickname and avatar
  Masquerade: __pow(2, 28),
  /// React to messages with emoji
  React: __pow(2, 29),
  // * Voice permissions
  /// Connect to a voice channel
  Connect: __pow(2, 30),
  /// Speak in a voice call
  Speak: __pow(2, 31),
  /// Share video in a voice call
  Video: __pow(2, 32),
  /// Mute other members with lower ranking in a voice call
  MuteMembers: __pow(2, 33),
  /// Deafen other members with lower ranking in a voice call
  DeafenMembers: __pow(2, 34),
  /// Move members between voice channels
  MoveMembers: __pow(2, 35),
  // * Mention permissions
  /// Mention @everyone or @online
  MentionEveryone: __pow(2, 37),
  /// Mention a role
  MentionRoles: __pow(2, 38),
  // * Grant all permissions
  /// Safely grant all permissions
  GrantAll: 4503599627370495
};
var DEFAULT_PERMISSION_DM = new ChannelPermissions([
  "VIEW_CHANNEL",
  "VIEW_CHANNEL",
  "MANAGE_CHANNEL",
  "VOICE_CALL",
  "EMBED_LINKS",
  "UPLOAD_FILES"
]).freeze();

// src/utils/badges.ts
var Badges = class extends BitField {
  constructor(bits) {
    super(bits);
  }
  static resolve(bit) {
    return super.resolve(bit);
  }
};
Badges.FLAGS = {
  DEVELOPER: 1 << 0,
  TRANSLATOR: 1 << 1,
  SUPPORTER: 1 << 2,
  RESPONSIBLE_DISCLOSURE: 1 << 3,
  REVOLT_TEAM: 1 << 4,
  EARLY_ADOPTER: 1 << 8
};

// src/struct/user.ts
var User = class extends Base {
  /**
   * Creates a new User instance.
   *
   * @param {client} client - The client instance.
   * @param {APIUser} data - The raw data for the user from the API.
   */
  constructor(client3, data) {
    super(client3);
    /** The avatar of the user, or `null` if none is set. */
    this.avatar = null;
    /** The presence status of the user. */
    this.presence = new Presence(this.client);
    /** Whether the user is a bot. */
    this.bot = false;
    this._patch(data);
  }
  /**
   * Updates the user instance with new data from the API.
   *
   * @param {APIUser} data - The raw data for the user from the API.
   * @param {FieldsUser[]} [clear=[]] - Fields to clear in the user.
   * @returns {this} The updated user instance.
   * @protected
   */
  _patch(data, clear = []) {
    var _a, _b;
    super._patch(data);
    if (data.username) {
      this.username = data.username;
    }
    if (data.bot) {
      this.bot = true;
    }
    if (typeof data.badges === "number") {
      this.badges = new Badges(data.badges).freeze();
    }
    if (data.avatar) {
      this.avatar = new Attachment(this.client, data.avatar);
    }
    if (data.status) {
      this.presence.status = data.status.presence ? (_a = Status[data.status.presence]) != null ? _a : "Invisible" /* Invisible */ : "Invisible" /* Invisible */;
      this.presence.text = (_b = data.status.text) != null ? _b : null;
    }
    for (const field of clear) {
      if (field === "Avatar") this.avatar = null;
      if (field === "StatusText") this.presence.text = null;
      if (field === "StatusPresence") this.presence.status = "Invisible" /* Invisible */;
    }
    return this;
  }
  /**
   * Gets the creation date of the user.
   *
   * @returns {Date} The date when the user was created.
   */
  get createdAt() {
    return UUID.timestampOf(this.id);
  }
  /**
   * checks if the user is the owner of the bot.
   */
  get isOwner() {
    var _a;
    return this.id === ((_a = this.client.user) == null ? void 0 : _a.owner);
  }
  /**
   * Gets the creation timestamp of the user in milliseconds.
   *
   * @returns {number} The timestamp of when the user was created.
   */
  get createdTimestamp() {
    return this.createdAt.getTime();
  }
  /**
   * Blocks the user.
   *
   * @returns {Promise<void>} A promise that resolves when the user is blocked.
   *
   * @example
   * ```typescript
   * await user.block();
   * ```
   */
  block() {
    return __async(this, null, function* () {
      yield this.client.api.put(`/users/${this.id}/block`);
    });
  }
  /**
   * Unblocks the user.
   *
   * @returns {Promise<void>} A promise that resolves when the user is unblocked.
   *
   * @example
   * ```typescript
   * await user.unblock();
   * ```
   */
  unblock() {
    return __async(this, null, function* () {
      yield this.client.api.delete(`/users/${this.id}/block`);
    });
  }
  /**
   * Creates a direct message (DM) channel with the user.
   *
   * @returns {Promise<DMChannel>} A promise that resolves with the created DM channel.
   *
   * @example
   * ```typescript
   * const dmChannel = await user.createDM();
   * ```
   */
  createDM() {
    return __async(this, null, function* () {
      const data = yield this.client.api.get(`/users/${this.id}/dm`);
      return this.client.channels._add(data);
    });
  }
  avatarURL() {
    var _a, _b, _c;
    if (!((_a = this.avatar) == null ? void 0 : _a.id)) return void 0;
    return `${(_b = this.client.options.rest) == null ? void 0 : _b.instanceCDNURL}/avatars/${(_c = this.avatar) == null ? void 0 : _c.id}`;
  }
  displayAvatarURL() {
    return __async(this, null, function* () {
      var _a, _b;
      const defaultAvatar = `${(_a = this.client.options.rest) == null ? void 0 : _a.instanceCDNURL}/users/${this.id}/default_avatar`;
      return (_b = this.avatarURL()) != null ? _b : defaultAvatar;
    });
  }
  /**
   * Fetches the latest data for the user from the API.
   *
   * @param {boolean} [force=false] - Whether to force a fetch even if the user is cached.
   * @returns {Promise<User>} A promise that resolves with the updated user instance.
   */
  fetch(force = false) {
    return this.client.users.fetch(this, { force });
  }
  /**
   * Converts the user to a string representation.
   *
   * @returns {string} A string representation of the user in the format `<@userId>`.
   */
  toString() {
    return `<@${this.id}>`;
  }
};

// src/struct/message.ts
var MessageStruct = class extends Base {
  /**
   * Creates a new Message instance.
   *
   * @param {client} client - The client instance.
   * @param {APIMessage} data - The raw data for the message from the API.
   */
  constructor(client3, data) {
    super(client3);
    /** The type of the message (e.g., TEXT, SYSTEM). */
    this.type = "TEXT";
    /** The content of the message. */
    this.content = "";
    /** The ID of the channel where the message was sent. */
    this.channelId = "";
    /** The ID of the user who authored the message. */
    this.authorId = "";
    /** An array of embeds included in the message. */
    this.embeds = [];
    /** An array of file attachments included in the message. */
    this.attachments = [];
    /** Mentions included in the message. */
    this.mentions = new Mentions(this, []);
    /** The timestamp of when the message was last edited, or `null` if not edited. */
    this.editedTimestamp = null;
    /** the reactions and count on a message */
    this.reactions = /* @__PURE__ */ new Map();
    this._patch(data);
  }
  /**
   * Updates the message instance with new data from the API.
   *
   * @param {APIMessage} data - The raw data for the message from the API.
   * @returns {this} The updated message instance.
   * @protected
   */
  _patch(data) {
    var _a;
    super._patch(data);
    if (Array.isArray(data.embeds)) {
      this.embeds = data.embeds;
    }
    if (Array.isArray(data.attachments)) {
      this.attachments = data.attachments;
    }
    if (Array.isArray(data.mentions)) {
      this.mentions = new Mentions(this, data.mentions);
    }
    if (data.author) {
      this.authorId = data.author;
    }
    if (data.channel) {
      this.channelId = data.channel;
    }
    if (data.webhook) {
      this.webhook = {
        name: data.webhook.name,
        avatar: (_a = data.webhook.avatar) != null ? _a : null
      };
    }
    if (typeof data.content === "string") {
      this.content = data.content;
    }
    if (data.system) {
      this.type = data.system.type.toUpperCase();
    }
    if (data.edited) {
      this.editedTimestamp = Date.parse(data.edited);
    }
    return this;
  }
  /**
   * Gets the creation date of the message.
   *
   * @returns {Date} The date when the message was created.
   */
  get createdAt() {
    return UUID.timestampOf(this.id);
  }
  /**
   * Gets the creation timestamp of the message in milliseconds.
   *
   * @returns {number} The timestamp of when the message was created.
   */
  get createdTimestamp() {
    return this.createdAt.getTime();
  }
  /**
   * Gets the date when the message was last edited.
   *
   * @returns {Date | null} The date of the last edit, or `null` if not edited.
   */
  get editedAt() {
    return this.editedTimestamp ? new Date(this.editedTimestamp) : null;
  }
  /**
   * Checks if the message is a system message.
   *
   * @returns {boolean} `true` if the message is a system message, otherwise `false`.
   */
  get system() {
    return this.type !== "TEXT";
  }
  /**
   * Retrieves the author of the message.
   *
   * @returns {User | ServerMember | null} The user who authored the message, or `null` if not found.
   */
  get author() {
    var _a, _b, _c, _d;
    if (this.webhook) {
      return {
        bot: true,
        username: this.webhook.name,
        isWebhook: true
      };
    }
    if (this.inServer()) {
      return (_c = (_b = (_a = this.server) == null ? void 0 : _a.members.cache.get(this.authorId)) != null ? _b : this.client.users.cache.get(this.authorId)) != null ? _c : null;
    }
    return (_d = this.client.users.cache.get(this.authorId)) != null ? _d : null;
  }
  /**
   * Retrieves the channel where the message was sent.
   *
   * @returns {TextChannel | DMChannel | GroupChannel | VoiceChannel} The channel instance.
   */
  get channel() {
    const channel = this.client.channels.cache.get(this.channelId);
    switch (channel == null ? void 0 : channel.type) {
      case "TEXT" /* TEXT */:
        return channel;
      case "DM" /* DM */:
        return channel;
      case "GROUP" /* GROUP */:
        return channel;
      case "VOICE" /* VOICE */:
        return channel;
      default:
        return channel;
    }
  }
  /**
   * Retrieves the server ID associated with the message, if any.
   *
   * @returns {string | null} The server ID, or `null` if the message is not in a server.
   */
  get serverId() {
    const channel = this.channel;
    return channel.inServer() ? channel.serverId : null;
  }
  /**
   * Retrieves the server associated with the message, if any.
   *
   * @returns {Server | null} The server instance, or `null` if not found.
   */
  get server() {
    var _a;
    return (_a = this.client.servers.cache.get(this.serverId)) != null ? _a : null;
  }
  /**
   * Retrieves the server member who authored the message, if any.
   *
   * @returns {ServerMember | null} The server member instance, or `null` if not found.
   */
  get member() {
    var _a, _b;
    return (_b = (_a = this.server) == null ? void 0 : _a.members.cache.get(this.authorId)) != null ? _b : null;
  }
  /**
   * Gets the URL of the message.
   *
   * @returns {string} The URL of the message.
   */
  get url() {
    return `https://app.stoat.chat/${this.serverId ? `server/${this.serverId}` : ""}/channel/${this.channelId}/${this.id}`;
  }
  /**
   * Acknowledges the message.
   *
   * @returns {Promise<void>} A promise that resolves when the message is acknowledged.
   */
  ack() {
    return this.channel.messages.ack(this);
  }
  /**
   * Deletes the message.
   *
   * @returns {Promise<void>} A promise that resolves when the message is deleted.
   */
  delete() {
    return this.channel.messages.delete(this);
  }
  /**
   * Replies to the message.
   *
   * @param {string} content - The content of the reply.
   * @param {boolean} [mention=true] - Whether to mention the original message author.
   * @returns {Promise<Message>} A promise that resolves with the sent reply message.
   */
  reply(content, mention = true) {
    return this.channel.messages.send(__spreadProps(__spreadValues({}, typeof content === "object" ? content : { content }), {
      replies: [{ id: this.id, mention }]
    }));
  }
  /**
   * Edits the message.
   *
   * @param {MessageEditOptions | string} options - The new content or edit options.
   * @returns {Promise<void>} A promise that resolves when the message is edited.
   */
  edit(options) {
    return this.channel.messages.edit(this, options);
  }
  /**
   * Fetches the latest data for the message.
   *
   * @returns {Promise<Message>} A promise that resolves with the updated message instance.
   */
  fetch() {
    return this.channel.messages.fetch(this.id);
  }
  /**
   * Adds a reaction to the message.
   *
   * @param {string} emoji - The emoji to react with.
   * @returns {Promise<void>} A promise that resolves when the reaction is added.
   */
  addReaction(emoji) {
    return this.channel.messages.addReaction(this, emoji);
  }
  /**
   * Removes a reaction from the message.
   *
   * @param {string} emoji - The emoji to remove the reaction for.
   * @param {object} [options] - Options for removing the reaction.
   * @param {string} [options.user_id] - The user ID to remove the reaction for. If not provided, removes the reaction for the current user.
   * @param {boolean} [options.remove_all=false] - Whether to remove all of the specified reaction for the message.
   * @returns {Promise<void>} A promise that resolves when the reaction is removed.
   */
  removeReaction(emoji, options) {
    var _a, _b;
    return this.channel.messages.removeReaction(
      this,
      emoji,
      (_a = options == null ? void 0 : options.user_id) != null ? _a : void 0,
      (_b = options == null ? void 0 : options.remove_all) != null ? _b : false
    );
  }
  /**
   * Removes all reactions from the message.
   *
   * @returns {Promise<void>} A promise that resolves when all reactions are removed.
   */
  removeAllReactions() {
    return this.channel.messages.removeAllReactions(this);
  }
  /**
   * Checks if the message is in a server.
   *
   * @returns {boolean} `true` if the message is in a server, otherwise `false`.
   */
  inServer() {
    return this.channel.inServer();
  }
  /**
   * Converts the message to a string representation.
   *
   * @returns {string} The content of the message.
   */
  toString() {
    return this.content;
  }
};

// src/struct/attachment.ts
var Attachment = class extends Base {
  /**
   * Creates a new Attachment instance.
   *
   * @param {client} client - The client instance.
   * @param {File} data - The raw data for the attachment from the API.
   */
  constructor(client3, data) {
    super(client3);
    this._patch(data);
  }
  /**
   * Updates the attachment instance with new data from the API.
   *
   * @param {File} data - The raw data for the attachment from the API.
   * @returns {this} The updated attachment instance.
   * @protected
   */
  _patch(data) {
    super._patch(data);
    if (data.filename) this.filename = data.filename;
    if (data.content_type) this.type = data.content_type;
    if (typeof data.size === "number") this.size = data.size;
    if (data.metadata) this.metadata = data.metadata;
    return this;
  }
};

// src/struct/presence.ts
var Status = /* @__PURE__ */ ((Status2) => {
  Status2["Online"] = "Online";
  Status2["Idle"] = "Idle";
  Status2["Focus"] = "Focus";
  Status2["Busy"] = "Busy";
  Status2["Invisible"] = "Invisible";
  return Status2;
})(Status || {});
var Presence = class extends Base {
  constructor() {
    super(...arguments);
    /** The custom status text of the user, or `null` if none is set. */
    this.text = null;
    /** The current status of the user (e.g., Online, Idle, Busy, Invisible). */
    this.status = "Invisible" /* Invisible */;
  }
};

// src/struct/server.ts
var Server2 = class extends Base {
  /**
   * Creates a new Server instance.
   *
   * @param {client} client - The client instance.
   * @param {APIServer} data - The raw data for the server from the API.
   */
  constructor(client3, data) {
    super(client3);
    /** The description of the server, or `null` if none is set. */
    this.description = null;
    /** Manages the members of the server. */
    this.members = new ServerMemberManager(this);
    /** Manages the channels of the server. */
    this.channels = new ServerChannelManager(this);
    /** Manages the roles of the server. */
    this.roles = new RoleManager(this);
    /** The icon of the server, or `null` if none is set. */
    this.icon = null;
    /** The banner of the server, or `null` if none is set. */
    this.banner = null;
    /** Whether analytics are enabled for the server. */
    this.analytics = false;
    /** Whether the server is discoverable. */
    this.discoverable = false;
    /** Whether the server is marked as NSFW (Not Safe For Work). */
    this.nsfw = false;
    /** The categories in the server. */
    this.categories = /* @__PURE__ */ new Map();
    /** the emojies associated with the server */
    this.emojis = /* @__PURE__ */ new Map();
    this._patch(data);
  }
  /**
   * Updates the server instance with new data from the API.
   *
   * @param {APIServer} data - The raw data for the server from the API.
   * @param {FieldsServer[]} [clear=[]] - Fields to clear in the server.
   * @returns {this} The updated server instance.
   * @protected
   */
  _patch(data, clear = []) {
    var _a;
    super._patch(data);
    if (Array.isArray(data.categories)) {
      this.categories.clear();
      for (const cat of data.categories) {
        const category = new Category(this, cat);
        this.categories.set(category.id, category);
      }
    }
    if (data.icon) {
      this.icon = new Attachment(this.client, data.icon);
    }
    if (data.banner) {
      this.banner = new Attachment(this.client, data.banner);
    }
    if (data.owner) {
      this.ownerId = data.owner;
    }
    if (data.name) {
      this.name = data.name;
    }
    if ("description" in data) {
      this.description = (_a = data.description) != null ? _a : null;
    }
    if (Array.isArray(data.channels)) {
      for (const id of data.channels) {
        const channel = this.client.channels.cache.get(id);
        if (channel == null ? void 0 : channel.inServer()) this.channels.cache.set(channel.id, channel);
      }
    }
    if (typeof data.roles === "object") {
      for (const [id, raw] of Object.entries(data.roles)) {
        this.roles._add(Object.assign(raw, { id }));
      }
    }
    if (typeof data.default_permissions === "number") {
      this.permissions = new FullPermissions(data.default_permissions).freeze();
    }
    if (typeof data.analytics === "boolean") this.analytics = data.analytics;
    if (typeof data.discoverable === "boolean") {
      this.discoverable = data.discoverable;
    }
    if (typeof data.nsfw === "boolean") this.nsfw = data.nsfw;
    for (const field of clear) {
      if (field === "Icon") this.icon = null;
      if (field === "Description") this.description = null;
      if (field === "Banner") this.banner = null;
    }
    return this;
  }
  /**
   * Retrieves the current user's member instance in the server.
   *
   * @returns {ServerMember | null} The current user's member instance, or `null` if not found.
   */
  get me() {
    var _a, _b;
    return (_b = this.members.cache.get((_a = this.client.user) == null ? void 0 : _a.id)) != null ? _b : null;
  }
  /**
   * Gets the creation date of the server.
   *
   * @returns {Date} The date when the server was created.
   */
  get createdAt() {
    return UUID.timestampOf(this.id);
  }
  /**
   * Gets the creation timestamp of the server in milliseconds.
   *
   * @returns {number} The timestamp of when the server was created.
   */
  get createdTimestamp() {
    return this.createdAt.getTime();
  }
  /**
   * Retrieves the owner of the server.
   *
   * @returns {User | null} The owner of the server, or `null` if not found.
   */
  get owner() {
    var _a;
    return (_a = this.client.users.cache.get(this.ownerId)) != null ? _a : null;
  }
  //   iconURL(options?: { size: number }): string | null {
  //     return this.icon
  //       ? this.client.api.cdn.icon(this.icon.id, options?.size)
  //       : null;
  //   }
  //   bannerURL(options?: { size: number }): string | null {
  //     return this.banner
  //       ? this.client.api.cdn.banner(this.banner.id, options?.size)
  //       : null;
  //   }
  /**
   * Converts the server to a string representation.
   *
   * @returns {string} The name of the server.
   */
  toString() {
    return this.name;
  }
};

// src/struct/role.ts
var Role = class extends Base {
  /**
   * Creates a new Role instance.
   *
   * @param {Server} server - The server this role belongs to.
   * @param {APIRole & { id: string }} data - The raw data for the role from the API.
   */
  constructor(server, data) {
    super(server.client);
    this.server = server;
    /** The color of the role, or `null` if no color is set. */
    this.color = null;
    /** Whether the role is displayed separately in the member list. */
    this.hoist = false;
    this._patch(data);
  }
  /**
   * Updates the role instance with new data from the API.
   *
   * @param {APIRole & { _id?: string }} data - The raw data for the role from the API.
   * @param {FieldsRole[]} [clear=[]] - Fields to clear in the role.
   * @returns {this} The updated role instance.
   * @protected
   */
  _patch(data, clear = []) {
    var _a;
    super._patch(data);
    if (data.name) this.name = data.name;
    if (typeof data.hoist === "boolean") this.hoist = data.hoist;
    if (typeof data.rank === "number") this.rank = data.rank;
    if ("colour" in data) this.color = (_a = data.colour) != null ? _a : null;
    if (data.permissions) {
      const { a, d } = data.permissions;
      this.overwrite = {
        allow: new FullPermissions(a),
        deny: new FullPermissions(d)
      };
    }
    for (const field of clear) {
      if (field === "Colour") this.color = null;
    }
    return this;
  }
  /**
   * Gets the date when the role was created.
   *
   * @returns {Date} The creation date of the role.
   */
  get createdAt() {
    return UUID.timestampOf(this.id);
  }
  /**
   * Gets the timestamp of when the role was created.
   *
   * @returns {number} The creation timestamp of the role in milliseconds.
   */
  get createdTimestamp() {
    return this.createdAt.getTime();
  }
  /**
   * Gets the permissions overwrite for the role.
   *
   * @returns {Overwrite} The permissions overwrite for the role.
   */
  get permissions() {
    return this.overwrite;
  }
  /**
   * Deletes the role from the server.
   *
   * @returns {Promise<void>} A promise that resolves when the role is deleted.
   *
   * @example
   * ```typescript
   * await role.delete();
   * console.log("Role deleted successfully.");
   * ```
   */
  delete() {
    return this.server.roles.delete(this);
  }
  edit(data) {
    return this.server.roles.edit(this, data);
  }
  /**
   * Converts the role to a string representation.
   *
   * @returns {string} A string representation of the role in the format `<@&roleId>`.
   */
  toString() {
    return `<@&${this.id}>`;
  }
};

// src/struct/channel.ts
var Channel = class extends Base {
  constructor() {
    super(...arguments);
    this.type = "UNKNOWN";
    this.voice = /* @__PURE__ */ new Map();
  }
  /**
   * Gets the timestamp (in milliseconds) when the channel was created.
   *
   * @returns {number} The timestamp of the channel's creation.
   */
  get createdTimestamp() {
    return this.createdAt.getTime();
  }
  /**
   * Gets the date and time when the channel was created.
   *
   * @returns {Date} The creation date of the channel.
   */
  get createdAt() {
    return UUID.timestampOf(this.id);
  }
  /**
   * Deletes the current channel instance from the client's channel collection.
   *
   * This method interacts with the client's channel management system to remove
   * the channel. Once deleted, the channel will no longer be accessible through
   * the client.
   *
   * @returns {Promise<void>} A promise that resolves when the channel has been successfully deleted.
   *
   * @example
   * ```typescript
   * const channel = client.channels.get('1234567890');
   * if (channel) {
   *   await channel.delete();
   *   console.log('Channel deleted successfully.');
   * }
   * ```
   */
  delete() {
    return this.client.channels.delete(this);
  }
  /**
   * Checks if the channel is a text-based channel.
   *
   * @returns {boolean} True if the channel is a text-based channel, otherwise false.
   */
  isText() {
    return "messages" in this;
  }
  /**
   * Checks if the channel is a voice channel.
   *
   * @returns {boolean} True if the channel is a voice channel, otherwise false.
   */
  isVoice() {
    return this.type === "VOICE" /* VOICE */;
  }
  /**
   * Checks if the channel is a group channel.
   *
   * @returns {boolean} True if the channel is a group channel, otherwise false.
   */
  isGroup() {
    return this.type === "GROUP" /* GROUP */;
  }
  /**
   * Checks if the channel is part of a server.
   *
   * @returns {boolean} True if the channel is a server channel, otherwise false.
   */
  inServer() {
    return "serverId" in this;
  }
  /**
   * Converts the channel to a string representation.
   *
   * @returns {string} A string representation of the channel in the format `<#channelId>`.
   */
  toString() {
    return `<#${this.id}>`;
  }
  /**
   * Fetches the latest data for the channel from the client's channel collection.
   *
   * @param {boolean} [force=true] - Whether to force a fetch even if the channel is cached.
   * @returns {Promise<Channel>} A promise that resolves with the updated channel instance.
   */
  fetch(force = true) {
    return this.client.channels.fetch(this, { force });
  }
  edit(data) {
    return __async(this, null, function* () {
      const id = this.id;
      if (!id) {
        throw new TypeError("INVALID_ID");
      }
      const response = yield this.client.api.patch(`/channels/${id}`, {
        body: data
      });
      return response;
    });
  }
  // Implementation
  setRolePermissions(roleId, allowOrOptions, deny) {
    return __async(this, null, function* () {
      const id = this.id;
      if (!id) {
        throw new TypeError("INVALID_ID");
      }
      let allow;
      let denyPermissions;
      if (Array.isArray(allowOrOptions)) {
        allow = allowOrOptions;
        denyPermissions = deny;
      } else if (allowOrOptions && typeof allowOrOptions === "object") {
        allow = allowOrOptions.allow;
        denyPermissions = allowOrOptions.deny;
        if (allow === void 0 && denyPermissions === void 0) {
          throw new TypeError(
            "At least one of 'allow' or 'deny' must be provided in options"
          );
        }
      } else {
        throw new TypeError("Invalid arguments provided");
      }
      const requestBody = {
        allow: 0,
        deny: 0
      };
      if (allow !== void 0) {
        requestBody.allow = new FullPermissions(allow).bitfield;
      }
      if (denyPermissions !== void 0) {
        requestBody.deny = new FullPermissions(denyPermissions).bitfield;
      }
      yield this.client.api.put(`/channels/${id}/permissions/${roleId}`, {
        body: { permissions: requestBody }
      });
    });
  }
  // Implementation
  setDefaultPermissions(allowOrOptionsOrPermissions) {
    return __async(this, null, function* () {
      const id = this.id;
      if (!id) {
        throw new TypeError("INVALID_ID");
      }
      let allow;
      let deny;
      if (Array.isArray(allowOrOptionsOrPermissions)) {
        allow = allowOrOptionsOrPermissions;
      } else if (allowOrOptionsOrPermissions && typeof allowOrOptionsOrPermissions === "object") {
        if ("a" in allowOrOptionsOrPermissions || "d" in allowOrOptionsOrPermissions) {
          const legacyPerms = allowOrOptionsOrPermissions;
          allow = legacyPerms.a;
          deny = legacyPerms.d;
        } else {
          const options = allowOrOptionsOrPermissions;
          allow = options.allow;
          deny = options.deny;
          if (allow === void 0 && deny === void 0) {
            throw new TypeError(
              "At least one of 'allow' or 'deny' must be provided in options"
            );
          }
        }
      } else {
        throw new TypeError("Invalid arguments provided");
      }
      const requestBody = {};
      if (allow !== void 0) {
        requestBody.allow = new FullPermissions(allow).bitfield;
      }
      if (deny !== void 0) {
        requestBody.deny = new FullPermissions(deny).bitfield;
      }
      if (requestBody.allow === void 0) {
        requestBody.allow = 0;
      }
      if (requestBody.deny === void 0) {
        requestBody.deny = 0;
      }
      yield this.client.api.put(`/channels/${id}/permissions/default`, {
        body: { permissions: requestBody }
      });
    });
  }
  /**
   * Creates a new webhook in this channel.
   *
   * @param name - The name of the webhook
   * @param avatar - Optional avatar for the webhook. Can be a URL string, Readable stream, or File object
   * @returns Promise resolving to the created webhook response
   *
   * @example
   * ```typescript
   * const webhook = await channel.createWebhook("My Webhook", "https://example.com/avatar.png");
   * ```
   */
  createWebhook(name, avatar) {
    return __async(this, null, function* () {
      return this.client.webhooks.create(this.id, name, avatar);
    });
  }
  /**
   * Retrieves all webhooks for this channel.
   *
   * @returns Promise resolving to an array of webhook responses
   *
   * @example
   * ```typescript
   * const webhooks = await channel.getWebhooks();
   * console.log(`Found ${webhooks.length} webhooks`);
   * ```
   */
  getWebhooks() {
    return __async(this, null, function* () {
      return this.client.webhooks.getAll(this.id);
    });
  }
  /**
   * Retrieves a specific webhook by ID and token.
   *
   * @param webhookId - The ID of the webhook to retrieve
   * @param token - The token of the webhook
   * @returns Promise resolving to the webhook response
   *
   * @example
   * ```typescript
   * const webhook = await channel.getWebhook("webhookId", "webhookToken");
   * console.log(`Webhook name: ${webhook.name}`);
   * ```
   */
  getWebhook(webhookId, token) {
    return __async(this, null, function* () {
      return this.client.webhooks.get(webhookId, token);
    });
  }
  /**
   * Sends a message through a webhook in this channel.
   *
   * @param webhookId - The ID of the webhook to send the message through
   * @param token - The token of the webhook
   * @param content - The message content. Can be a string or MessageOptions object with attachments and embeds
   * @returns Promise resolving to the sent message
   *
   * @example
   * ```typescript
   * // Send a simple text message
   * await channel.sendWebhookMessage("webhookId", "token", "Hello, world!");
   *
   * // Send a message with embeds and attachments
   * await channel.sendWebhookMessage("webhookId", "token", {
   *   content: "Check out this image!",
   *   attachments: ["https://example.com/image.png"],
   *   embeds: [myEmbed]
   * });
   * ```
   */
  sendWebhookMessage(webhookId, token, content) {
    return __async(this, null, function* () {
      return this.client.webhooks.send(webhookId, token, content);
    });
  }
  /**
   * Deletes a webhook.
   *
   * @param webhookId - The ID of the webhook to delete
   * @param token - The token of the webhook
   * @returns Promise that resolves when the webhook is deleted
   *
   * @example
   * ```typescript
   * await channel.deleteWebhook("webhookId", "webhookToken");
   * console.log("Webhook deleted successfully");
   * ```
   */
  deleteWebhook(webhookId, token) {
    return __async(this, null, function* () {
      return this.client.webhooks.delete(webhookId, token);
    });
  }
  /**
   * Edits a webhook's properties.
   *
   * @param webhookId - The ID of the webhook to edit
   * @param token - The token of the webhook
   * @param options - The options to edit on the webhook
   * @returns Promise resolving to the updated webhook response
   *
   * @example
   * ```typescript
   * const updatedWebhook = await channel.editWebhook("webhookId", "token", {
   *   name: "New Webhook Name",
   *   avatar: "https://example.com/new-avatar.png"
   * });
   * ```
   */
  editWebhook(webhookId, token, options) {
    return __async(this, null, function* () {
      return this.client.webhooks.edit(webhookId, token, options);
    });
  }
  /**
   * Retrieves partial information about a webhook using only its ID.
   * This method provides limited webhook information without requiring a token.
   *
   * @param webhookId - The ID of the webhook to retrieve partial information for
   * @returns Promise resolving to the webhook response with partial information
   *
   * @example
   * ```typescript
   * const partialWebhook = await channel.getPartialWebhook("webhookId");
   * console.log(`Webhook name: ${partialWebhook.name}`);
   * ```
   */
  getPartialWebhook(webhookId) {
    return __async(this, null, function* () {
      return this.client.webhooks.getPartial(webhookId);
    });
  }
};

// src/struct/dmChannel.ts
var DMChannel3 = class extends Channel {
  /**
   * Creates a new DMChannel instance.
   *
   * @param {client} client - The client instance.
   * @param {APIDirectChannel} data - The raw data for the DM channel from the API.
   */
  constructor(client3, data) {
    super(client3);
    /** The type of the channel, which is always `DM` for direct message channels. */
    this.type = "DM" /* DM */;
    /** The default permissions for the DM channel. */
    this.permissions = DEFAULT_PERMISSION_DM;
    /** Manages the messages in this DM channel. */
    this.messages = new MessageManager(this);
    /** The ID of the last message sent in this DM channel, if any. */
    this.lastMessageId = null;
    this._patch(data);
  }
  /**
   * Updates the DM channel instance with new data from the API.
   *
   * @param {APIDirectChannel} data - The raw data for the DM channel from the API.
   * @returns {this} The updated DM channel instance.
   * @protected
   */
  _patch(data) {
    super._patch(data);
    if (typeof data.active === "boolean") this.active = data.active;
    if (data.last_message_id) this.lastMessageId = data.last_message_id;
    return this;
  }
  /**
   * Retrieves the last message sent in this DM channel.
   *
   * @returns {Message | null} The last message, or `null` if no message exists.
   */
  get lastMessage() {
    var _a;
    if (!this.lastMessageId) return null;
    return (_a = this.messages.cache.get(this.lastMessageId)) != null ? _a : null;
  }
  /**
   * Deletes multiple messages from this DM channel.
   *
   * @param {MessageResolvable[] | Map<string, Message> | number} messages - The messages to delete. This can be an array of message resolvables, a map of messages, or a number indicating how many recent messages to delete.
   * @returns {Promise<void>} A promise that resolves when the messages have been successfully deleted.
   *
   * @example
   * ```typescript
   * await dmChannel.bulkDelete(10); // Deletes the last 10 messages.
   * ```
   */
  bulkDelete(messages) {
    return this.messages.bulkDelete(messages);
  }
  /**
   * Sends a message to this DM channel.
   *
   * @param {MessageOptions | string} options - The message content or options for the message.
   * @returns {Promise<Message>} A promise that resolves with the sent message.
   *
   * @example
   * ```typescript
   * await dmChannel.send("Hello, world!");
   * ```
   */
  send(options) {
    return this.messages.send(options);
  }
};

// src/struct/groupChannel.ts
var GroupChannel2 = class extends Channel {
  /**
   * Creates a new GroupChannel instance.
   *
   * @param {client} client - The client instance.
   * @param {APIGroupChannel} data - The raw data for the group channel from the API.
   */
  constructor(client3, data) {
    super(client3);
    /** The type of the channel, which is always `GROUP` for group channels. */
    this.type = "GROUP" /* GROUP */;
    /** The description of the group channel, if any. */
    this.description = null;
    /** The icon of the group channel, if any. */
    this.icon = null;
    /** Manages the messages in this group channel. */
    this.messages = new MessageManager(this);
    /** The ID of the last message sent in this group channel, if any. */
    this.lastMessageId = null;
    /** A map of user IDs to their corresponding `User` instances in the group channel. */
    this.users = /* @__PURE__ */ new Map();
    /** Whether the group channel is marked as NSFW (Not Safe For Work). */
    this.nsfw = false;
    this._patch(data);
  }
  /**
   * Updates the group channel instance with new data from the API.
   *
   * @param {APIGroupChannel} data - The raw data for the group channel from the API.
   * @returns {this} The updated group channel instance.
   * @protected
   */
  _patch(data) {
    var _a;
    super._patch(data);
    if ("description" in data) {
      this.description = (_a = data.description) != null ? _a : null;
    }
    if (Array.isArray(data.recipients)) {
      this.users.clear();
      for (const userId of data.recipients) {
        const user = this.client.users.cache.get(userId);
        if (user) this.users.set(user.id, user);
      }
    }
    if (typeof data.permissions === "number") {
      this.permissions = new ChannelPermissions(data.permissions).freeze();
    }
    if (data.owner) {
      this.ownerId = data.owner;
    }
    if (data.icon) {
      this.icon = new Attachment(this.client, data.icon);
    }
    if (data.name) {
      this.name = data.name;
    }
    if (data.last_message_id) this.lastMessageId = data.last_message_id;
    if (typeof data.nsfw === "boolean") this.nsfw = data.nsfw;
    return this;
  }
  /**
   * Retrieves the last message sent in this group channel.
   *
   * @returns {Message | null} The last message, or `null` if no message exists.
   */
  get lastMessage() {
    var _a;
    if (!this.lastMessageId) return null;
    return (_a = this.messages.cache.get(this.lastMessageId)) != null ? _a : null;
  }
  /**
   * Retrieves the owner of the group channel.
   *
   * @returns {User | null} The owner of the group channel, or `null` if not found.
   */
  get owner() {
    var _a;
    return (_a = this.client.users.cache.get(this.ownerId)) != null ? _a : null;
  }
  /**
   * Deletes multiple messages from this group channel.
   *
   * @param {MessageResolvable[] | Map<string, Message> | number} messages - The messages to delete. This can be an array of message resolvables, a map of messages, or a number indicating how many recent messages to delete.
   * @returns {Promise<void>} A promise that resolves when the messages have been successfully deleted.
   *
   * @example
   * ```typescript
   * await groupChannel.bulkDelete(10); // Deletes the last 10 messages.
   * ```
   */
  bulkDelete(messages) {
    return this.messages.bulkDelete(messages);
  }
  /**
   * Creates an invite for the group channel.
   *
   * @returns {Promise<Invite>} A promise that resolves with the created invite.
   *
   * @example
   * ```typescript
   * const invite = await groupChannel.createInvite();
   * console.log(`Invite created: ${invite}`);
   * ```
   */
  createInvite() {
    return __async(this, null, function* () {
      const data = yield this.client.api.post(`/channels/${this.id}/invites`, {});
      return new Invite(
        this.client,
        data
      );
    });
  }
  /**
   * Adds a user to the group channel.
   *
   * @param {UserResolvable} user - The user to add to the group channel.
   * @returns {Promise<void>} A promise that resolves when the user has been successfully added.
   *
   * @example
   * ```typescript
   * await groupChannel.add(user);
   * ```
   */
  add(user) {
    return __async(this, null, function* () {
      const id = this.client.users.resolveId(user);
      if (!id) throw new TypeError("INVALID_TYPE");
      yield this.client.api.put(`/channels/${this.id}/recipients/${id}`);
    });
  }
  /**
   * Removes a user from the group channel.
   *
   * @param {UserResolvable} user - The user to remove from the group channel.
   * @returns {Promise<void>} A promise that resolves when the user has been successfully removed.
   *
   * @example
   * ```typescript
   * await groupChannel.remove(user);
   * ```
   */
  remove(user) {
    return __async(this, null, function* () {
      const id = this.client.users.resolveId(user);
      if (!id) throw new TypeError("INVALID_TYPE");
      yield this.client.api.delete(`/channels/${this.id}/recipients/${id}`);
    });
  }
  /**
   * Leaves the group channel.
   *
   * @returns {Promise<void>} A promise that resolves when the group channel has been successfully left.
   *
   * @example
   * ```typescript
   * await groupChannel.leave();
   * ```
   */
  leave() {
    return super.delete();
  }
  /**
   * Sends a message to this group channel.
   *
   * @param {MessageOptions | string} options - The message content or options for the message.
   * @returns {Promise<Message>} A promise that resolves with the sent message.
   *
   * @example
   * ```typescript
   * await groupChannel.send("Hello, group!");
   * ```
   */
  send(options) {
    return this.messages.send(options);
  }
  /**
   * Creates and connects an AudioPlayer to this voice channel in one step.
   * This is a convenience method that combines createPlayer() and connect().
   *
   * @returns {Promise<AudioPlayer>} A promise that resolves to a connected AudioPlayer
   *
   * @example
   * ```typescript
   * const voiceChannel = await client.channels.fetch('voice-channel-id') as VoiceChannel;
   * const player = await voiceChannel.connect();
   *
   * // Already connected, ready to play
   * await player.playFromUrl('https://example.com/music.mp3');
   * ```
   */
  connect() {
    return __async(this, null, function* () {
      return this.client.voice.connectToChannel(this.id, this.id);
    });
  }
  /** Disconnects the AudioPlayer from this voice channel's server. */
  disconnect() {
    return __async(this, null, function* () {
      return this.client.voice.disconnectFromChannel(this.id);
    });
  }
  /** Stops the AudioPlayer in this voice channel's server. */
  stop() {
    return __async(this, null, function* () {
      return this.client.voice.stopPlayerInChannel(this.id);
    });
  }
  /** Plays audio through the AudioPlayer connected to this voice channel.
   * @param source - The audio source (URL, file path, or stream)
   */
  play(source) {
    return __async(this, null, function* () {
      const player = yield this.getPlayer();
      if (!player) throw new Error("No active player found for this channel");
      return player.play(source);
    });
  }
  /** Retrieves the AudioPlayer associated with this voice channel, if any.
   * @returns {Promise<AudioPlayer | null>} A promise that resolves to the AudioPlayer or null if not found
   */
  getPlayer() {
    return __async(this, null, function* () {
      const player = this.client.voice["players"].get(this.id);
      return player != null ? player : null;
    });
  }
  //   iconURL(options?: { size: number }): string | null {
  //     if (!this.icon) return null;
  //     return this.client.api.cdn.icon(this.icon.id, options?.size);
  //   }
};

// src/struct/invite.ts
var Invite = class extends Base {
  /**
   * Creates a new Invite instance.
   *
   * @param {client} client - The client instance.
   * @param {APIInvite} data - The raw data for the invite from the API.
   */
  constructor(client3, data) {
    super(client3);
    /** The ID of the server associated with the invite, if any. */
    this.serverId = null;
    this._patch(data);
  }
  /**
   * Updates the invite instance with new data from the API.
   *
   * @param {APIInvite} data - The raw data for the invite from the API.
   * @returns {this} The updated invite instance.
   * @protected
   */
  _patch(data) {
    super._patch(data);
    if (data.channel) this.channelId = data.channel;
    if (data.creator) this.inviterId = data.channel;
    return this;
  }
  /**
   * Retrieves the server associated with the invite.
   *
   * @returns {Server | null} The server associated with the invite, or `null` if not found.
   */
  get server() {
    var _a;
    return (_a = this.client.servers.cache.get(this.serverId)) != null ? _a : null;
  }
  /**
   * Retrieves the channel associated with the invite.
   *
   * @returns {Channel | null} The channel associated with the invite, or `null` if not found.
   */
  get channel() {
    var _a;
    return (_a = this.client.channels.cache.get(this.channelId)) != null ? _a : null;
  }
  /**
   * Retrieves the user who created the invite.
   *
   * @returns {User | null} The user who created the invite, or `null` if not found.
   */
  get inviter() {
    var _a;
    return (_a = this.client.users.cache.get(this.inviterId)) != null ? _a : null;
  }
  //   toString(): string {
  //     return this.client.api.cdn.invite(this.id);
  //   }
};

// src/struct/mentions.ts
var Mentions = class {
  /**
   * Creates a new Mentions instance.
   *
   * @param {Message} message - The message associated with the mentions.
   * @param {string[]} _users - An array of user IDs mentioned in the message.
   */
  constructor(message, _users) {
    this.message = message;
    this._users = _users;
    this.client = message.client;
  }
  /**
   * Checks if a specific user is mentioned in the message.
   *
   * @param {UserResolvable} user - The user to check.
   * @returns {boolean} `true` if the user is mentioned, otherwise `false`.
   * @throws {TypeError} Throws an error if the user cannot be resolved.
   *
   * @example
   * ```typescript
   * if (mentions.has(someUser)) {
   *   console.log("User is mentioned!");
   * }
   * ```
   */
  has(user) {
    const id = this.client.users.resolveId(user);
    if (!id) throw new TypeError("INVALID_TYPE");
    return this._users.includes(id);
  }
  /**
   * Retrieves the server members mentioned in the message.
   *
   * @returns {Map<string, ServerMember> | null} A map of user IDs to `ServerMember` instances, or `null` if the message is not in a server.
   *
   * @example
   * ```typescript
   * const members = mentions.members;
   * if (members) {
   *   members.forEach(member => console.log(member.displayName));
   * }
   * ```
   */
  get members() {
    const server = this.message.server;
    if (!server) return null;
    const members = /* @__PURE__ */ new Map();
    for (const userId of this._users) {
      const member = server.members.cache.get(userId);
      if (member) members.set(member.id, member);
    }
    return members;
  }
  /**
   * Retrieves the users mentioned in the message.
   *
   * @returns {Map<string, User>} A map of user IDs to `User` instances.
   *
   * @example
   * ```typescript
   * const users = mentions.users;
   * users.forEach(user => console.log(user.username));
   * ```
   */
  get users() {
    const users = /* @__PURE__ */ new Map();
    for (const userId of this._users) {
      const user = this.client.users.cache.get(userId);
      if (user) users.set(user.id, user);
    }
    return users;
  }
};

// src/struct/messageEmbed.ts
var import_stream = require("stream");
var import_axios = __toESM(require("axios"));
var import_form_data = __toESM(require("form-data"));
var import_node_buffer = require("buffer");
var _url, _title, _description, _icon_url, _color, _media;
var MessageEmbed = class {
  constructor() {
    __privateAdd(this, _url);
    __privateAdd(this, _title);
    __privateAdd(this, _description);
    __privateAdd(this, _icon_url);
    __privateAdd(this, _color);
    __privateAdd(this, _media);
  }
  /**
   * Sets the title of the embed.
   *
   * @param {string} title - The title to set.
   * @returns {this} The updated `MessageEmbed` instance.
   */
  setTitle(title) {
    __privateSet(this, _title, title);
    return this;
  }
  /**
   * Sets the icon URL of the embed.
   *
   * @param {string} iconURL - The URL of the icon to set.
   * @returns {this} The updated `MessageEmbed` instance.
   */
  setIcon(iconURL) {
    __privateSet(this, _icon_url, iconURL);
    return this;
  }
  /**
   * Sets the color of the embed.
   *
   * @param {string} color - The color to set (e.g., a hex code).
   * @returns {this} The updated `MessageEmbed` instance.
   */
  setColor(color) {
    __privateSet(this, _color, color);
    return this;
  }
  /**
   * Sets the description of the embed.
   *
   * @param {string} description - The description to set.
   * @returns {this} The updated `MessageEmbed` instance.
   */
  setDescription(description) {
    __privateSet(this, _description, description);
    return this;
  }
  /**
   * Sets the URL of the embed.
   *
   * @param {string} url - The URL to set.
   * @returns {this} The updated `MessageEmbed` instance.
   */
  setURL(url) {
    __privateSet(this, _url, url);
    return this;
  }
  /**
   * Sets the media (e.g., image or video) of the embed.
   *
   * @param {Readable | string | File} media - The media URL, File or Stream to set.
   * @returns {this} The updated `MessageEmbed` instance.
   */
  setMedia(media) {
    __privateSet(this, _media, media);
    return this;
  }
  /**
   *
   * @param client The client instance used to send the embed.
   * @returns SendableEmbed
   * Converts the embed to a JSON object that can be sent to the API, including media handling.
   */
  toJSONWithMedia(client3) {
    return __async(this, null, function* () {
      const embed = {
        title: __privateGet(this, _title),
        icon_url: __privateGet(this, _icon_url),
        colour: __privateGet(this, _color),
        description: __privateGet(this, _description),
        url: __privateGet(this, _url)
      };
      if (__privateGet(this, _media)) {
        let att = __privateGet(this, _media);
        const data = new import_form_data.default();
        if (typeof att === "string") {
          const readableStream = yield import_axios.default.get(att, {
            responseType: "stream"
          });
          data.append("file", readableStream.data, {
            filename: att.split("/").pop()
          });
        }
        if (att instanceof import_stream.Readable) {
          data.append("file", att);
        }
        if (att instanceof import_node_buffer.File) {
          const buffer = Buffer.from(yield att.arrayBuffer());
          data.append("file", buffer, { filename: att.name });
        }
        yield client3.cdn.post("/attachments", data).then((attachment) => {
          const { id } = attachment;
          embed.media = id;
        });
      }
      return embed;
    });
  }
  /**
   * Converts the embed to a JSON object that can be sent to the API.
   *
   * @returns {SendableEmbed} The JSON representation of the embed.
   */
  toJSON() {
    var _a;
    return {
      title: __privateGet(this, _title),
      icon_url: __privateGet(this, _icon_url),
      colour: __privateGet(this, _color),
      description: __privateGet(this, _description),
      url: __privateGet(this, _url),
      media: (_a = __privateGet(this, _media)) == null ? void 0 : _a.toString()
    };
  }
};
_url = new WeakMap();
_title = new WeakMap();
_description = new WeakMap();
_icon_url = new WeakMap();
_color = new WeakMap();
_media = new WeakMap();

// src/struct/notesChannel.ts
var NotesChannel = class extends Channel {
  /**
   * Creates a new NotesChannel instance.
   *
   * @param {client} client - The client instance.
   * @param {APINotesChannel} data - The raw data for the notes channel from the API.
   */
  constructor(client3, data) {
    super(client3);
    /** The type of the channel, which is always `NOTES` for notes channels. */
    this.type = "NOTES" /* NOTES */;
    /** The ID of the last message sent in this notes channel, if any. */
    this.lastMessageId = null;
    /** Manages the messages in this notes channel. */
    this.messages = new MessageManager(this);
    this._patch(data);
  }
  /**
   * Updates the notes channel instance with new data from the API.
   *
   * @param {APINotesChannel} data - The raw data for the notes channel from the API.
   * @returns {this} The updated notes channel instance.
   * @protected
   */
  _patch(data) {
    super._patch(data);
    if (data.user) {
      this.userId = data.user;
    }
    return this;
  }
  /**
   * Sends a message to this notes channel.
   *
   * @param {MessageOptions | string} options - The message content or options for the message.
   * @returns {Promise<Message>} A promise that resolves with the sent message.
   *
   * @example
   * ```typescript
   * await notesChannel.send("This is a saved message.");
   * ```
   */
  send(options) {
    return this.messages.send(options);
  }
  /**
   * Deletes multiple messages from this notes channel.
   *
   * @param {MessageResolvable[] | Map<string, Message> | number} messages - The messages to delete. This can be an array of message resolvables, a map of messages, or a number indicating how many recent messages to delete.
   * @returns {Promise<void>} A promise that resolves when the messages have been successfully deleted.
   *
   * @example
   * ```typescript
   * await notesChannel.bulkDelete(5); // Deletes the last 5 messages.
   * ```
   */
  bulkDelete(messages) {
    return this.messages.bulkDelete(messages);
  }
  /**
   * Retrieves the last message sent in this notes channel.
   *
   * @returns {Message | null} The last message, or `null` if no message exists.
   */
  get lastMessage() {
    var _a;
    if (!this.lastMessageId) return null;
    return (_a = this.messages.cache.get(this.lastMessageId)) != null ? _a : null;
  }
  /**
   * Retrieves the user associated with this notes channel.
   *
   * @returns {User} The user associated with the notes channel.
   */
  get user() {
    return this.client.user;
  }
};

// src/struct/serverChannel.ts
var ServerChannel = class extends Channel {
  /**
   * Creates a new ServerChannel instance.
   *
   * @param {client} client - The client instance.
   * @param {APIServerChannel} data - The raw data for the server channel from the API.
   */
  constructor(client3, data) {
    super(client3);
    /** The description of the channel, or `null` if none is set. */
    this.description = null;
    /** The icon of the channel, or `null` if none is set. */
    this.icon = null;
    /** Manages the messages in this Server channel. */
    this.messages = new MessageManager(this);
    /** The permission overwrites for the channel. */
    this.overwrites = /* @__PURE__ */ new Map();
    /** Whether the channel is marked as NSFW (Not Safe For Work). */
    this.nsfw = false;
    this._patch(data);
  }
  /**
   * Updates the server channel instance with new data from the API.
   *
   * @param {APIServerChannel} data - The raw data for the server channel from the API.
   * @param {FieldsChannel[]} [clear=[]] - Fields to clear in the channel.
   * @returns {this} The updated server channel instance.
   * @protected
   */
  _patch(data, clear = []) {
    var _a;
    super._patch(data);
    if (data.name) this.name = data.name;
    if (data.server) this.serverId = data.server;
    if ("description" in data) this.description = (_a = data.description) != null ? _a : null;
    if (data.icon) this.icon = new Attachment(this.client, data.icon);
    if (typeof data.nsfw === "boolean") this.nsfw = data.nsfw;
    if (data.role_permissions) {
      this.overwrites.clear();
      for (const [id, { a, d }] of Object.entries(data.role_permissions)) {
        this.overwrites.set(id, {
          allow: new FullPermissions(a),
          deny: new FullPermissions(d)
        });
      }
    }
    for (const field of clear) {
      if (field === "Icon") this.icon = null;
      if (field === "Description") this.description = null;
    }
    return this;
  }
  /**
   * Creates an invite for the server channel.
   *
   * @returns {Promise<Invite>} A promise that resolves with the created invite.
   *
   * @example
   * ```typescript
   * const invite = await serverChannel.createInvite();
   * console.log(`Invite created: ${invite}`);
   * ```
   */
  createInvite() {
    return __async(this, null, function* () {
      const data = yield this.client.api.post(`/channels/${this.id}/invites`, {});
      return new Invite(
        this.client,
        data
      );
    });
  }
  //   iconURL(options?: { size: number }): string | null {
  //     return this.icon
  //       ? this.client.api.cdn.icon(this.icon.id, options?.size)
  //       : null;
  //   }
  /**
   * Retrieves the server this channel belongs to.
   *
   * @returns {Server} The server instance.
   */
  get server() {
    return this.client.servers.cache.get(this.serverId);
  }
  /**
   * Sends a message to this Server channel.
   *
   * @param {MessageOptions | string} options - The message content or options for the message.
   * @returns {Promise<Message>} A promise that resolves with the sent message.
   *
   * @example
   * ```typescript
   * await serverChannel.send("Hello, world!");
   * ```
   */
  send(options) {
    return this.messages.send(options);
  }
  /**
   * Retrieves the category this channel belongs to, if any.
   *
   * @returns {Category | null} The category instance, or `null` if the channel is not in a category.
   */
  get category() {
    var _a;
    return (_a = Array.from(this.server.categories.values()).find(
      (cat) => cat.children.has(this.id)
    )) != null ? _a : null;
  }
};

// src/struct/serverMember.ts
var ServerMember3 = class extends Base {
  /**
   * Creates a new ServerMember instance.
   *
   * @param {client} client - The client instance.
   * @param {APIMember} data - The raw data for the server member from the API.
   */
  constructor(client3, data) {
    super(client3);
    /** The nickname of the member, or `null` if none is set. */
    this.nickname = null;
    /** The avatar of the member, or `null` if none is set. */
    this.avatar = null;
    /** roles assigned to the member */
    this.roles = [];
    this._patch(data);
  }
  /**
   * Updates the server member instance with new data from the API.
   *
   * @param {APIMember} data - The raw data for the server member from the API.
   * @param {FieldsMember[]} [clear=[]] - Fields to clear in the server member.
   * @returns {this} The updated server member instance.
   * @protected
   */
  _patch(data, clear = []) {
    var _a;
    super._patch(data);
    if ("nickname" in data) {
      this.nickname = (_a = data.nickname) != null ? _a : null;
    }
    if (data.avatar) {
      this.avatar = new Attachment(this.client, data.avatar);
    }
    if (data._id) {
      this.serverId = data._id.server;
      this.id = data._id.user;
    }
    if (Array.isArray(data.roles)) {
      if (!data.roles.length) this.roles = [];
      else {
        this.roles = data.roles.map((roleId) => {
          const role = this.server.roles.cache.get(roleId);
          if (!role) {
            throw new Error(
              `Role with ID ${roleId} not found in server ${this.serverId}`
            );
          }
          return role;
        });
      }
    }
    for (const field of clear) {
      if (field === "Avatar") this.avatar = null;
      if (field === "Nickname") this.nickname = null;
    }
    return this;
  }
  /**
   * Sets the nickname of the server member.
   *
   * @param {string} [nickname] - The new nickname to set, or `undefined` to clear the nickname.
   * @returns {Promise<this>} A promise that resolves with the updated server member instance.
   *
   * @example
   * ```typescript
   * await member.setNickname("NewNickname");
   * ```
   */
  setNickname(nickname) {
    return __async(this, null, function* () {
      yield this.server.members.edit(this, { nickname });
      return this;
    });
  }
  /**
   * adds a role to the server member.
   * @param roleId - The ID of the role to add to the member.
   * @returns
   */
  addRole(roleId) {
    return __async(this, null, function* () {
      const currentRoles = this.roles.map((role) => role.id);
      if (currentRoles.includes(roleId)) {
        return this;
      }
      yield this.server.members.edit(this, {
        roles: [...currentRoles, roleId]
      });
      return this;
    });
  }
  /**
   * Removes a role from the server member.
   *
   * @param {string} roleId - The ID of the role to remove from the member.
   * @returns {Promise<this>} A promise that resolves with the updated server member instance.
   *
   * @example
   * ```typescript
   * await member.removeRole("roleId");
   * ```
   */
  removeRole(roleId) {
    return __async(this, null, function* () {
      const currentRoles = this.roles.map((role) => role.id);
      if (!currentRoles.includes(roleId)) {
        return this;
      }
      yield this.server.members.edit(this, {
        roles: currentRoles.filter((id) => id !== roleId)
      });
      return this;
    });
  }
  /**
   * Bans the server member.
   *
   * @param {string} [reason] - The reason for the ban.
   * @returns {Promise<void>} A promise that resolves when the member is banned.
   *
   * @example
   * ```typescript
   * await member.ban("Violation of rules");
   * ```
   */
  ban(reason) {
    return this.server.members.ban(this, reason);
  }
  /**
   * Kicks the server member.
   *
   * @returns {Promise<void>} A promise that resolves when the member is kicked.
   *
   * @example
   * ```typescript
   * await member.kick();
   * ```
   */
  kick() {
    return this.server.members.kick(this);
  }
  /**
   * Leaves the server.
   *
   * @returns {Promise<void>} A promise that resolves when the member leaves the server.
   *
   * @example
   * ```typescript
   * await member.leave();
   * ```
   */
  leave() {
    return this.client.servers.delete(this.serverId);
  }
  /**
   * Gets the effective permissions for this server member based on their roles.
   *
   * The permissions are calculated by:
   * 1. Starting with a base FullPermissions with no permissions
   * 2. For each role the member has, applying the role's allow permissions
   * 3. For each role the member has, removing the role's deny permissions
   *
   * @returns {FullPermissions} The effective permissions for this member
   *
   * @example
   * ```typescript
   * const permissions = member.getPermissions();
   * console.log(permissions.has('MANAGE_MESSAGES')); // true or false
   * ```
   */
  permissions() {
    var _a, _b;
    let permissions = new FullPermissions();
    for (const role of this.roles) {
      if ((_a = role.overwrite) == null ? void 0 : _a.allow) {
        permissions = permissions.add(role.overwrite.allow);
      }
    }
    for (const role of this.roles) {
      if ((_b = role.overwrite) == null ? void 0 : _b.deny) {
        permissions = permissions.remove(role.overwrite.deny);
      }
    }
    return permissions;
  }
  /**
   * Checks if this server member has a specific permission.
   *
   * @param {string | number | FullPermissions} permission - The permission to check for
   * @returns {boolean} Whether the member has the permission
   *
   * @example
   * ```typescript
   * if (member.hasPermission('MANAGE_MESSAGES')) {
   *   // Member can manage messages
   * }
   * ```
   *
   * note this works on the same basis as stoats permissions checking
   */
  hasPermission(permission) {
    var _a;
    if (((_a = this.client.servers.cache.get(this.serverId)) == null ? void 0 : _a.ownerId) === this.id)
      return true;
    return this.permissions().has(permission);
  }
  //   async displayAvatarURL(options?: { size: number }): Promise<string> {
  //     return await this.user.displayAvatarURL(options);
  //   }
  /**
   * Retrieves the user associated with this server member.
   *
   * @returns {User} The user instance.
   */
  get user() {
    return this.client.users.cache.get(this.id);
  }
  /**
   * Gets the username of the user.
   *
   * @returns {string} The username of the user.
   */
  get username() {
    return this.user.username;
  }
  /**
   * Gets whether the user is a bot.
   *
   * @returns {boolean} Whether the user is a bot.
   */
  get bot() {
    var _a;
    return (_a = this.user.bot) != null ? _a : false;
  }
  /**
   * Retrieves the server this member belongs to.
   *
   * @returns {Server} The server instance.
   */
  get server() {
    return this.client.servers.cache.get(this.serverId);
  }
  /**
   * Converts the server member to a string representation.
   *
   * @returns {string} A string representation of the server member in the format `<@userId>`.
   */
  toString() {
    return `<@${this.id}>`;
  }
  /**
   * Sets a timeout for the server member.
   * @param duration - The duration of the timeout as a Date object.
   * @returns A promise that resolves when the timeout is set.
   */
  timeout(duration) {
    return this.server.members.edit(this, { timeout: duration });
  }
};

// src/struct/textChannel.ts
var TextChannel2 = class extends ServerChannel {
  /**
   * Creates a new TextChannel instance.
   *
   * @param {client} client - The client instance.
   * @param {APITextChannel} data - The raw data for the text channel from the API.
   */
  constructor(client3, data) {
    super(client3, data);
    /** The ID of the last message sent in this text channel, if any. */
    this.lastMessageId = null;
    /** Manages the messages in this text channel. */
    this.messages = new MessageManager(this);
    /** The type of the channel, which is always `TEXT` for text channels. */
    this.type = "TEXT" /* TEXT */;
    this._patch(data);
  }
  /**
   * Updates the text channel instance with new data from the API.
   *
   * @param {APITextChannel} data - The raw data for the text channel from the API.
   * @returns {this} The updated text channel instance.
   * @protected
   */
  _patch(data) {
    super._patch(data);
    if (data.last_message_id) this.lastMessageId = data.last_message_id;
    return this;
  }
  /**
   * Retrieves the last message sent in this text channel.
   *
   * @returns {Message | null} The last message, or `null` if no message exists.
   */
  get lastMessage() {
    var _a;
    if (!this.lastMessageId) return null;
    return (_a = this.messages.cache.get(this.lastMessageId)) != null ? _a : null;
  }
  /**
   * Sends a message to this text channel.
   *
   * @param {MessageOptions | string} options - The message content or options for the message.
   * @returns {Promise<Message>} A promise that resolves with the sent message.
   *
   * @example
   * ```typescript
   * await textChannel.send("Hello, world!");
   * ```
   */
  send(options) {
    return this.messages.send(options);
  }
  /**
   * Deletes multiple messages from this text channel.
   *
   * @param {MessageResolvable[] | Map<string, Message> | number} messages - The messages to delete. This can be an array of message resolvables, a map of messages, or a number indicating how many recent messages to delete.
   * @returns {Promise<void>} A promise that resolves when the messages have been successfully deleted.
   *
   * @example
   * ```typescript
   * await textChannel.bulkDelete(10); // Deletes the last 10 messages.
   * ```
   */
  bulkDelete(messages) {
    return this.messages.bulkDelete(messages);
  }
};

// src/struct/voiceChannels.ts
var VoiceChannel2 = class extends ServerChannel {
  /**
   * Creates a new VoiceChannel instance.
   *
   * @param {client} client - The client instance.
   * @param {APIVoiceChannel} data - The raw data for the voice channel from the API.
   */
  constructor(client3, data) {
    super(client3, data);
    /** The type of the channel, which is always `VOICE` for voice channels. */
    this.type = "VOICE" /* VOICE */;
    this.voice = /* @__PURE__ */ new Map();
    this._patch(data);
  }
  /**
   * Updates the voice channel instance with new data from the API.
   *
   * @param {APIVoiceChannel} data - The raw data for the voice channel from the API.
   * @returns {this} The updated voice channel instance.
   * @protected
   */
  _patch(data) {
    super._patch(data);
    return this;
  }
  /**
   * Acknowledges the voice channel.
   *
   * @throws {TypeError} Throws an error because voice channels cannot be acknowledged.
   *
   * @example
   * ```typescript
   * try {
   *   await voiceChannel.ack();
   * } catch (error) {
   *   console.error(error.message); // "Cannot ack voice channel"
   * }
   * ```
   */
  ack() {
    throw new TypeError("Cannot ack voice channel");
  }
  /**
   * Creates and connects an AudioPlayer to this voice channel in one step.
   * This is a convenience method that combines createPlayer() and connect().
   *
   * @returns {Promise<AudioPlayer>} A promise that resolves to a connected AudioPlayer
   *
   * @example
   * ```typescript
   * const voiceChannel = await client.channels.fetch('voice-channel-id') as VoiceChannel;
   * const player = await voiceChannel.connect();
   *
   * // Already connected, ready to play
   * await player.playFromUrl('https://example.com/music.mp3');
   * ```
   */
  connect() {
    return __async(this, null, function* () {
      return this.client.voice.connectToChannel(this.id, this.serverId);
    });
  }
  /** Disconnects the AudioPlayer from this voice channel's server. */
  disconnect() {
    return __async(this, null, function* () {
      return this.client.voice.disconnectFromChannel(this.serverId);
    });
  }
  /** Stops the AudioPlayer in this voice channel's server. */
  stop() {
    return __async(this, null, function* () {
      return this.client.voice.stopPlayerInChannel(this.serverId);
    });
  }
  /** Plays audio through the AudioPlayer connected to this voice channel.
   * @param source - The audio source (URL, file path, or stream)
   */
  play(source) {
    return __async(this, null, function* () {
      const player = yield this.getPlayer();
      if (!player) throw new Error("No active player found for this channel");
      return player.play(source);
    });
  }
  /** Retrieves the AudioPlayer associated with this voice channel, if any.
   * @returns {Promise<AudioPlayer | null>} A promise that resolves to the AudioPlayer or null if not found
   */
  getPlayer() {
    return __async(this, null, function* () {
      const player = this.client.voice["players"].get(this.serverId);
      return player != null ? player : null;
    });
  }
};

// src/struct/category.ts
var Category = class extends Base {
  /**
   * Creates a new Category instance.
   *
   * @param {Server} server - The server this category belongs to.
   * @param {APICategory} data - The raw data for the category from the API.
   */
  constructor(server, data) {
    super(server.client);
    this.server = server;
    /** An array of channel IDs that belong to this category. */
    this._children = [];
    this._patch(data);
  }
  /**
   * Updates the category instance with new data from the API.
   *
   * @param {APICategory} data - The raw data for the category from the API.
   * @returns {this} The updated category instance.
   * @protected
   */
  _patch(data) {
    super._patch(data);
    if (data.title) {
      this.name = data.title;
    }
    if (Array.isArray(data.channels)) {
      this._children = data.channels;
    }
    return this;
  }
  /**
   * Retrieves the channels that belong to this category.
   *
   * @returns {Map<string, ServerChannel>} A map of channel IDs to their corresponding `ServerChannel` instances.
   */
  get children() {
    const coll = /* @__PURE__ */ new Map();
    for (const childId of this._children) {
      const child = this.server.channels.cache.get(childId);
      if (child) coll.set(child.id, child);
    }
    return coll;
  }
  /**
   * Converts the category to a string representation.
   *
   * @returns {string} The name of the category.
   */
  toString() {
    return this.name;
  }
};

// src/struct/emoji.ts
var Emoji2 = class extends Base {
  /**
   * Creates a new Emoji instance.
   *
   * @param {client} client - The client instance.
   * @param {Emoji} data - The raw data for the emoji.
   */
  constructor(client3, data) {
    super(client3);
    /** The parent object of the emoji, which can be a server or other entity. */
    this.parent = null;
    /** The ID of the user who created the emoji, or `null` if not available. */
    this.creator_id = null;
    /** The name of the emoji, or `null` if not set. */
    this.name = null;
    this._patch(data);
  }
  /**
   * Retrieves the user who created the emoji.
   *
   * @returns {User | null} The creator of the emoji, or `null` if not found.
   */
  get creator() {
    var _a;
    return (_a = this.client.users.cache.get(this.creator_id)) != null ? _a : null;
  }
  /**
   * Retrieves the server associated with the emoji, if any.
   *
   * @returns {Server | null} The server instance, or `null` if the emoji is not associated with a server.
   */
  get server() {
    var _a;
    if (!this.parent) return null;
    return (_a = this.client.servers.cache.get(this.parent.id)) != null ? _a : null;
  }
};

// src/managers/channelManager.ts
var ChannelManager = class extends BaseManager {
  constructor() {
    super(...arguments);
    /** @private */
    this.holds = null;
  }
  /** @private */
  _add(data) {
    let channel;
    switch (data.channel_type) {
      case "TextChannel":
        if (data.voice !== void 0) {
          channel = new VoiceChannel2(this.client, data);
        } else {
          channel = new TextChannel2(this.client, data);
        }
        break;
      case "VoiceChannel":
        channel = new VoiceChannel2(this.client, data);
        break;
      case "DirectMessage":
        channel = new DMChannel3(this.client, data);
        break;
      case "Group":
        channel = new GroupChannel2(this.client, data);
        break;
      case "SavedMessages":
        channel = new NotesChannel(this.client, data);
        if (this.client.user) this.client.user.notes = channel;
        break;
      default:
        throw new Error(`Unknown Channel Type: ${data}`);
    }
    this.cache.set(channel.id, channel);
    return channel;
  }
  _remove(id) {
    var _a;
    const channel = this.cache.get(id);
    if (channel == null ? void 0 : channel.inServer()) {
      (_a = channel.server) == null ? void 0 : _a.channels.cache.delete(id);
    }
    super._remove(id);
  }
  /**
   * used to delete a channel
   *
   * @param channel The channel to delete
   * @returns A promise that resolves when the channel is deleted
   */
  delete(channel) {
    return __async(this, null, function* () {
      const id = this.resolveId(channel);
      if (!id) {
        throw new TypeError("INVALID_TYPE");
      }
      yield this.client.api.delete(`/channels/${id}`);
    });
  }
  /**
   * used to fetch a channel
   *
   * @param channel The channel to fetch
   * @param force Whether to force fetch the channel using the api or return it form cache if able
   * @returns A promise that resolves with the fetched channel
   */
  fetch(_0) {
    return __async(this, arguments, function* (channel, { force = true } = {}) {
      const id = this.resolveId(channel);
      if (!id) {
        throw new TypeError("INVALID_TYPE");
      }
      if (!force) {
        const channel2 = this.cache.get(id);
        if (channel2) return channel2;
      }
      const data = yield this.client.api.get(`/channels/${id}`);
      return this._add(data);
    });
  }
  /**
   * resolves a channel from a string or a channel object
   * @param channel The channel to resolve
   * @returns the resolved channel or null if not found
   */
  resolve(channel) {
    if (channel instanceof Channel) return channel;
    return super.resolve(channel);
  }
  /**
   * resolves a channel id from a string or a channel object
   * @param channel The channel to resolve
   * @returns the resolved channel id or null if not found
   */
  resolveId(channel) {
    if (channel instanceof Channel) return channel.id;
    return super.resolveId(channel);
  }
};

// src/managers/serverManager.ts
var ServerManager = class extends BaseManager {
  constructor() {
    super(...arguments);
    /** @private */
    this.holds = Server2;
  }
  /** @private */
  _remove(id) {
    var _a;
    const server = this.cache.get(id);
    for (const id2 of (_a = server == null ? void 0 : server.channels.cache.keys()) != null ? _a : []) {
      this.client.channels._remove(id2);
    }
    return super._remove(id);
  }
  /**
   * edits a server
   * @param server The server to edit
   * @param options The options to edit the server with
   * @param options.name The name of the server
   * @param options.description The description of the server
   * @returns A promise that resolves when the server is edited
   */
  edit(server, options) {
    return __async(this, null, function* () {
      const id = this.resolveId(server);
      if (!id) throw new TypeError("INVALID_TYPE");
      yield this.client.api.patch(`/servers/${id}`, { body: options });
    });
  }
  /**
   * leaves a server
   * @param server the server to leave
   */
  delete(server) {
    return __async(this, null, function* () {
      const id = this.resolveId(server);
      if (!id) throw new TypeError("INVALID_TYPE");
      yield this.client.api.delete(`/servers/${id}`);
    });
  }
  fetch(_0) {
    return __async(this, arguments, function* (server, { force = true } = {}) {
      const id = this.resolveId(server);
      if (!id) throw new TypeError("INVALID_TYPE");
      if (!force) {
        const server2 = this.cache.get(id);
        if (server2) return server2;
      }
      const data = yield this.client.api.get(`/servers/${id}`);
      return this._add(data);
    });
  }
};

// src/managers/userManager.ts
var UserManager = class extends BaseManager {
  constructor() {
    super(...arguments);
    /** @private */
    this.holds = User;
  }
  /**
   *
   * @param user The user to fetch
   * @returns A promise that resolves when the user is fetched
   */
  fetch(_0) {
    return __async(this, arguments, function* (user, { force = false } = {}) {
      const id = this.resolveId(user);
      if (!id) throw new TypeError("INVALID_TYPE");
      if (!force) {
        const user2 = this.cache.get(id);
        if (user2) return user2;
      }
      const data = yield this.client.api.get(`/users/${id}`);
      return this._add(data);
    });
  }
  resolve(resolvable) {
    if (resolvable instanceof MessageStruct)
      return resolvable.author;
    return super.resolve(resolvable);
  }
  /**
   * get a user id form cache
   * @param resolvable The user to resolve
   * @returns The user id or null if it cannot be resolved
   */
  resolveId(resolvable) {
    if (resolvable instanceof MessageStruct) return resolvable.authorId;
    return super.resolveId(resolvable);
  }
};

// src/managers/messageManager.ts
var import_node_buffer2 = require("buffer");
var import_stream2 = require("stream");
var import_form_data2 = __toESM(require("form-data"));
var import_axios2 = __toESM(require("axios"));
var MessageManager = class extends BaseManager {
  constructor(channel, maxSize = 1e3) {
    super(channel.client, maxSize);
    this.channel = channel;
    /** @private */
    this.holds = MessageStruct;
  }
  /**
   *
   * @param content The content to send. Can be a string or an object with the following properties:
   * - content: The content of the message
   * - replies: An array of message IDs to reply to
   * - attachments: An array of attachment URLs, Files, or ReadStreams
   * - embeds: An array of MessageEmbed objects
   * @returns Promise that resolves to the sent message
   */
  send(content) {
    return __async(this, null, function* () {
      if (typeof content === "string") content = { content };
      let attachments = [];
      let embeds = [];
      if (Array.isArray(content.attachments)) {
        const promises = content.attachments.map((att) => __async(this, null, function* () {
          const data = new import_form_data2.default();
          if (typeof att === "string") {
            const readableStream = yield import_axios2.default.get(att, {
              responseType: "stream"
            });
            data.append("file", readableStream.data, {
              filename: att.split("/").pop()
            });
          }
          if (att instanceof import_stream2.Readable) {
            data.append("file", att);
          }
          if (att instanceof import_node_buffer2.File) {
            const buffer = Buffer.from(yield att.arrayBuffer());
            data.append("file", buffer, { filename: att.name });
          }
          yield this.client.cdn.post("/attachments", data).then((attachment) => {
            const { id } = attachment;
            attachments.push(id);
          });
        }));
        yield Promise.all(promises);
      }
      if (Array.isArray(content.embeds)) {
        const promises = content.embeds.map((embed) => __async(this, null, function* () {
          const json = yield embed.toJSONWithMedia(this.client);
          embeds.push(json);
        }));
        yield Promise.all(promises);
      }
      const resp = yield this.client.api.post(
        `/channels/${this.channel.id}/messages`,
        {
          body: __spreadProps(__spreadValues({}, content), { attachments, embeds, nonce: UUID.generate() })
        }
      );
      return this._add(resp);
    });
  }
  /**
   * acknowledge a message to mark it as read (not important for bots)
   * @param message The message to acknowledge
   * @returns Promise that resolves when the message is acknowledged
   */
  ack(message) {
    return __async(this, null, function* () {
      const id = this.resolveId(message);
      if (!id) {
        throw new TypeError("INVALID_TYPE");
      }
      yield this.client.api.put(`/channels/${this.channel.id}/ack/${id}`);
    });
  }
  /**
   * bulk delete messages from the channel
   * @param messages The messages to delete. Can be an array of message IDs or a Map of message IDs to Message objects.
   * @returns Promise that resolves when the messages are deleted
   */
  bulkDelete(messages) {
    return __async(this, null, function* () {
      let ids = [];
      if (typeof messages === "number") {
        messages = yield this.fetch(messages);
        ids = messages instanceof Map ? [...messages.keys()] : [];
      } else if (messages instanceof Map) {
        ids = [...messages.keys()];
      } else {
        ids = messages.map((m) => this.resolveId(m)).filter(Boolean);
      }
      yield this.client.api.delete(`/channels/${this.channel.id}/messages/bulk`, {
        body: JSON.stringify({ ids })
      });
    });
  }
  /**
   * delete a message from the channel
   * @param message The message to delete. Can be a Message object or a message ID.
   * @returns Promise that resolves when the message is deleted
   */
  delete(message) {
    return __async(this, null, function* () {
      const id = this.resolveId(message);
      if (!id) {
        throw new TypeError("INVALID_TYPE");
      }
      yield this.client.api.delete(`/channels/${this.channel.id}/messages/${id}`);
    });
  }
  /**
   * edit a message in the channel
   * @param message The message to edit. Can be a Message object or a message ID.
   * @param options The options to edit the message with. Can be a string or an object with the following properties:
   * - content: The new content of the message
   * - attachments: An array of attachment URLs
   * - embeds: An array of MessageEmbed objects
   * @returns Promise that resolves when the message is edited
   */
  edit(message, options) {
    return __async(this, null, function* () {
      const id = this.resolveId(message);
      if (!id) {
        throw new TypeError("INVALID_TYPE");
      }
      if (typeof options === "string") options = { content: options };
      yield this.client.api.patch(`/channels/${this.channel.id}/messages/${id}`, {
        body: options
      });
    });
  }
  /**
   * search for messages in the channel
   * @param query The query to search for. Can be a string or an object with the following properties:
   * - query: The query to search for
   * - limit: The maximum number of messages to return
   * - before: The message ID to start searching from (exclusive)
   * - after: The message ID to stop searching at (exclusive)
   * - sort: The sort order of the results (asc or desc)
   * @returns Promise that resolves to a Map of message IDs to Message objects
   */
  search(query) {
    return __async(this, null, function* () {
      if (typeof query === "string") query = { query };
      const response = yield this.client.api.post(
        `/channels/${this.channel.id}/search`,
        {
          query
        }
      );
      return response.reduce((coll, cur) => {
        const msg = this._add(cur);
        coll.set(msg.id, msg);
        return coll;
      }, /* @__PURE__ */ new Map());
    });
  }
  fetch(query) {
    return __async(this, null, function* () {
      const id = this.resolveId(query);
      if (id) {
        const data = yield this.client.api.get(
          `/channels/${this.channel.id}/messages/${id}`
        );
        return this._add(data);
      }
      if (typeof query === "number") query = { limit: query };
      else if (typeof query === "undefined") query = { limit: 100 };
      const queryObj = Object.fromEntries(
        Object.entries(query).filter(
          ([, v]) => v !== void 0
        )
      );
      const messages = yield this.client.api.get(
        `/channels/${this.channel.id}/messages`,
        queryObj
      );
      return messages.reduce((coll, cur) => {
        const msg = this._add(cur);
        coll.set(msg.id, msg);
        return coll;
      }, /* @__PURE__ */ new Map());
    });
  }
  /**
   * add a reaction to a message
   * @param message The message to react to. Can be a Message object or a message ID.
   * @param emoji emoji to react with. Can be a string or an Emoji object.
   * @returns Promise that resolves when the reaction is added
   */
  addReaction(message, emoji) {
    return __async(this, null, function* () {
      const id = this.resolveId(message);
      if (!id) {
        throw new TypeError("INVALID_TYPE");
      }
      if (emoji instanceof Emoji2) emoji = emoji.id;
      else if (typeof emoji !== "string") {
        throw new TypeError("INVALID_TYPE");
      }
      yield this.client.api.put(
        `/channels/${this.channel.id}/messages/${id}/reactions/${emoji}`
      );
    });
  }
  /**
   *
   * @param message The message to unreact. Can be a Message object or a message ID.
   * @param emoji the emoji to unreact with. Can be a string or an Emoji object.
   * @param user_id The user ID to remove the reaction for. If not provided, removes the reaction for the current user.
   * @param remove_all Whether to remove all of the specified reaction for the message. Defaults to false.
   * @returns Promise that resolves when the reaction is removed
   */
  removeReaction(message, emoji, user_id, remove_all = false) {
    return __async(this, null, function* () {
      const id = this.resolveId(message);
      if (!id) {
        throw new TypeError("INVALID_TYPE");
      }
      if (emoji instanceof Emoji2) emoji = emoji.id;
      else if (typeof emoji !== "string") {
        throw new TypeError("INVALID_TYPE");
      }
      const queryString = user_id ? `?user_id=${user_id}&remove_all=${remove_all}` : `?remove_all=${remove_all}`;
      yield this.client.api.delete(
        `/channels/${this.channel.id}/messages/${id}/reactions/${emoji}${queryString}`
      );
    });
  }
  /**
   * remove all reactions from a message
   * @param message The message to remove reactions from. Can be a Message object or a message ID.
   * @returns Promise that resolves when the reactions are removed
   */
  removeAllReactions(message) {
    return __async(this, null, function* () {
      const id = this.resolveId(message);
      if (!id) {
        throw new TypeError("INVALID_TYPE");
      }
      yield this.client.api.delete(
        `/channels/${this.channel.id}/messages/${id}/reactions`
      );
    });
  }
};

// src/managers/roleManager.ts
var RoleManager = class extends BaseManager {
  constructor(server) {
    super(server.client);
    this.server = server;
    /** @private */
    this.holds = Role;
  }
  /** @private */
  _add(data) {
    const role = new Role(this.server, data);
    this.cache.set(role.id, role);
    return role;
  }
  /**
   * creates a new role in the server
   * @param name The name of the role to create
   * @returns
   */
  create(name) {
    return __async(this, null, function* () {
      const { id, role } = yield this.client.api.post(`/servers/${this.server.id}/roles`, { body: { name } });
      return this._add(Object.assign(role, { id }));
    });
  }
  /**
   * deletes a role from the server
   * @param role the role to delete
   * @returns A promise that resolves when the role is deleted
   */
  delete(role) {
    return __async(this, null, function* () {
      const id = this.resolveId(role);
      if (!id) throw new TypeError("INVALID_TYPE");
      yield this.client.api.delete(`/servers/${this.server.id}/roles/${id}`);
    });
  }
  /**
   *
   * @param role the role to edit
   * @param data data to edit the role with
   * @param data.permissions The permissions to set for the role, in the format { a: allow, d: deny }
   * @param data.name The name of the role
   * @param data.colour The color of the role, or `null` if no color is set
   * @param data.hoist Whether the role is displayed separately in the member list
   * @param data.rank The rank of the role, used for ordering
   * @param data.remove Fields to remove from the role
   * @returns Role
   * @throws {TypeError} If the role ID is invalid
   */
  edit(role, data) {
    return __async(this, null, function* () {
      var _a, _b;
      const id = this.resolveId(role);
      if (!id) throw new TypeError("INVALID_TYPE");
      if (data.permissions) {
        const permissions = {
          allow: new FullPermissions(((_a = data.permissions) == null ? void 0 : _a.a) || []).bitfield,
          deny: new FullPermissions(((_b = data.permissions) == null ? void 0 : _b.d) || []).bitfield
        };
        yield this.client.api.put(
          `/servers/${this.server.id}/permissions/${id}`,
          { body: { permissions } }
        );
      }
      delete data.permissions;
      const updatedRole = yield this.client.api.patch(
        `/servers/${this.server.id}/roles/${id}`,
        { body: data }
      );
      return this._add(Object.assign(updatedRole, { id }));
    });
  }
};

// src/managers/serverChannelManager.ts
var ServerChannelManager = class extends BaseManager {
  constructor(server) {
    super(server.client);
    this.server = server;
    /** @private */
    this.holds = ServerChannel;
  }
  /** @private */
  _add(data) {
    let channel;
    switch (data.channel_type) {
      case "TextChannel":
        channel = new TextChannel2(this.client, data);
        break;
      case "VoiceChannel":
        channel = new VoiceChannel2(this.client, data);
        break;
      default:
        throw new Error(
          `Unknown channel type: ${data.channel_type}`
        );
    }
    this.cache.set(channel.id, channel);
    return channel;
  }
  /**
   * Creates a new channel in the server.
   * @param options - Options for creating the channel.
   * @param options.name - The name of the channel to create.
   * @param [options.type="Text"] - The type of the channel to create. Can be "Text" or "Voice". Defaults to "Text".
   * @param [options.description] - The description of the channel to create. Only used for voice channels.
   * @returns A promise that resolves to the created channel.
   */
  create(_0) {
    return __async(this, arguments, function* ({
      name,
      type = "Text",
      description
    }) {
      const data = yield this.client.api.post(
        `/servers/${this.server.id}/channels`,
        {
          body: {
            name,
            type,
            description,
            nonce: UUID.generate()
          }
        }
      );
      return this._add(data);
    });
  }
  /**
   * fetch a channel from the server
   * @param channel The channel to fetch. Can be a string, a channel object, or an API channel object.
   * @param force Whether to force fetch the channel from the API. Defaults to true.
   * If set to false, the method will return the channel from the cache if it exists.
   * @returns A promise that resolves to the fetched channel
   */
  fetch(_0) {
    return __async(this, arguments, function* (channel, { force = true } = {}) {
      const id = this.resolveId(channel);
      if (!id) {
        throw new TypeError("INVALID_ID");
      }
      if (!force) {
        const channel2 = this.cache.get(id);
        if (channel2) return channel2;
      }
      const data = yield this.client.api.get(
        `/servers/${this.server.id}/channels/${id}`
      );
      return this._add(data);
    });
  }
};

// src/managers/serverMemberManager.ts
var ServerMemberManager = class extends BaseManager {
  constructor(server) {
    super(server.client);
    this.server = server;
    /** @private */
    this.holds = ServerMember3;
  }
  /**
   * edit selected member in the server
   * @param member The member to edit
   * @param options The options to edit the member with
   * @param options.nickname The nickname of the member to set
   * @param options.avatar The avatar of the member to set
   * @param options.roles The roles of the member to set
   * @returns A promise that resolves when the member is edited
   */
  edit(member, options) {
    return __async(this, null, function* () {
      const id = this.resolveId(member);
      if (!id) {
        throw new TypeError("INVALID_TYPE");
      }
      yield this.client.api.patch(`/servers/${this.server.id}/members/${id}`, {
        body: __spreadValues({}, options)
      });
    });
  }
  /**
   * ban selected member in the server
   * @param member The member to ban
   * @param reason the reason for the ban
   * @returns A promise that resolves when the member is banned
   */
  ban(member, reason) {
    return __async(this, null, function* () {
      const id = this.resolveId(member);
      if (!id) {
        throw new TypeError("INVALID_TYPE");
      }
      yield this.client.api.put(`/servers/${this.server.id}/bans/${id}`, {
        body: { reason }
      });
    });
  }
  /**
   * kick selected member in the server
   * @param member The member to kick
   * @returns A promise that resolves when the member is kicked
   */
  kick(member) {
    return __async(this, null, function* () {
      const id = this.resolveId(member);
      if (!id) {
        throw new TypeError("INVALID_TYPE");
      }
      yield this.client.api.delete(`/servers/${this.server.id}/members/${id}`);
    });
  }
  /**
   * unban selected member in the server
   * @param member The member to unban
   * @returns A promise that resolves when the member is unbanned
   */
  unban(member) {
    return __async(this, null, function* () {
      const id = this.resolveId(member);
      if (!id) {
        throw new TypeError("INVALID_TYPE");
      }
      yield this.client.api.delete(`/servers/${this.server.id}/bans/${id}`);
    });
  }
  /**
   * set timeout for a member in the server
   * @param member The member to set the timeout for
   * @param duration The duration of the timeout as a Date object
   * @returns A promise that resolves when the timeout is set
   */
  timeout(member, duration) {
    return __async(this, null, function* () {
      yield this.client.api.patch(
        `/servers/${this.server.id}/members/${member}`,
        {
          body: { timeout: duration }
        }
      );
    });
  }
  fetch(member) {
    return __async(this, null, function* () {
      if (typeof member !== "undefined") {
        const id = this.resolveId(member);
        if (!id) {
          throw new TypeError("INVALID_TYPE");
        }
        const data = yield this.client.api.get(
          `/servers/${this.server.id}/members/${id}`
        );
        return this._add(data);
      }
      const { users, members } = yield this.client.api.get(`/servers/${this.server.id}/members`);
      users.reduce((coll, cur) => {
        const user = this.client.users._add(cur);
        coll.set(user.id, user);
        return coll;
      }, this.client.users.cache);
      return members.reduce((coll, cur) => {
        const member2 = this._add(cur);
        coll.set(member2.id, member2);
        return coll;
      }, /* @__PURE__ */ new Map());
    });
  }
  /**
   * resolves a member from a string or a member object
   * @param member The member to resolve
   * @returns The id of the member or null if it cannot be resolved
   */
  resolveId(member) {
    if (member == null) return null;
    if (member instanceof ServerMember3 || member instanceof User) {
      return member.id;
    }
    if (typeof member === "string") return member;
    if ("_id" in member) return member._id.user;
    return null;
  }
};

// src/managers/webhookManager.ts
var import_stream3 = require("stream");
var import_axios3 = __toESM(require("axios"));
var import_form_data3 = __toESM(require("form-data"));
var WebhookManager = class {
  /**
   * Creates a new WebhookManager instance.
   *
   * @param client - The client instance this manager belongs to
   */
  constructor(client3) {
    this.client = client3;
  }
  /**
   * Creates a new webhook in the specified channel.
   *
   * @param channelId - The ID of the channel where the webhook will be created
   * @param name - The name of the webhook
   * @param avatar - Optional avatar for the webhook. Can be a URL string, Readable stream, or File object
   * @returns Promise resolving to the created webhook response
   *
   * @example
   * ```typescript
   * const webhook = await client.webhooks.create("channelId", "My Webhook", "https://example.com/avatar.png");
   * ```
   */
  create(channelId, name, avatar) {
    return __async(this, null, function* () {
      const data = new import_form_data3.default();
      let avatarID = void 0;
      if (typeof avatar === "string") {
        const readableStream = yield import_axios3.default.get(avatar, {
          responseType: "stream"
        });
        data.append("file", readableStream.data, {
          filename: avatar.split("/").pop()
        });
      }
      if (avatar instanceof import_stream3.Readable) {
        data.append("file", avatar, { filename: "avatar.png" });
      }
      if (avatar instanceof File) {
        const buffer = Buffer.from(yield avatar.arrayBuffer());
        data.append("file", buffer, { filename: avatar.name });
      }
      if (avatar) {
        yield this.client.cdn.post("/avatars", data).then((attachment) => {
          const { id } = attachment;
          avatarID = id;
        });
      }
      const response = yield this.client.api.post(
        `/channels/${channelId}/webhooks`,
        {
          body: {
            name,
            avatar: avatarID
          }
        }
      );
      return response;
    });
  }
  /**
   * Retrieves all webhooks for the specified channel.
   *
   * @param channelId - The ID of the channel to get webhooks from
   * @returns Promise resolving to an array of webhook responses
   *
   * @example
   * ```typescript
   * const webhooks = await client.webhooks.getAll("channelId");
   * console.log(`Found ${webhooks.length} webhooks`);
   * ```
   */
  getAll(channelId) {
    return __async(this, null, function* () {
      const response = yield this.client.api.get(
        `/channels/${channelId}/webhooks`
      );
      return response;
    });
  }
  /**
   * Retrieves a specific webhook by ID and token.
   *
   * @param webhookId - The ID of the webhook to retrieve
   * @param token - The token of the webhook
   * @returns Promise resolving to the webhook response
   *
   * @example
   * ```typescript
   * const webhook = await client.webhooks.get("webhookId", "webhookToken");
   * console.log(`Webhook name: ${webhook.name}`);
   * ```
   */
  get(webhookId, token) {
    return __async(this, null, function* () {
      const response = yield this.client.api.get(
        `/webhooks/${webhookId}/${token}`
      );
      return response;
    });
  }
  /**
   * Sends a message through a webhook.
   *
   * @param webhookId - The ID of the webhook to send the message through
   * @param token - The token of the webhook
   * @param content - The message content. Can be a string or MessageOptions object with attachments and embeds
   * @returns Promise resolving to the sent message
   *
   * @example
   * ```typescript
   * // Send a simple text message
   * await client.webhooks.send("webhookId", "token", "Hello, world!");
   *
   * // Send a message with embeds and attachments
   * await client.webhooks.send("webhookId", "token", {
   *   content: "Check out this image!",
   *   attachments: ["https://example.com/image.png"],
   *   embeds: [myEmbed]
   * });
   * ```
   */
  send(webhookId, token, content) {
    return __async(this, null, function* () {
      if (typeof content === "string") content = { content };
      let attachments = [];
      let embeds = [];
      if (Array.isArray(content.attachments)) {
        const promises = content.attachments.map((att) => __async(this, null, function* () {
          const data = new import_form_data3.default();
          if (typeof att === "string") {
            const readableStream = yield import_axios3.default.get(att, {
              responseType: "stream"
            });
            data.append("file", readableStream.data, {
              filename: att.split("/").pop()
            });
          }
          if (att instanceof import_stream3.Readable) {
            data.append("file", att);
          }
          if (att instanceof File) {
            const buffer = Buffer.from(yield att.arrayBuffer());
            data.append("file", buffer, { filename: att.name });
          }
          yield this.client.cdn.post("/attachments", data).then((attachment) => {
            const { id } = attachment;
            attachments.push(id);
          });
        }));
        yield Promise.all(promises);
      }
      if (Array.isArray(content.embeds)) {
        const promises = content.embeds.map((embed) => __async(this, null, function* () {
          const json = yield embed.toJSONWithMedia(this.client);
          embeds.push(json);
        }));
        yield Promise.all(promises);
      }
      const resp = yield this.client.api.post(
        `/webhooks/${webhookId}/${token}`,
        {
          body: __spreadProps(__spreadValues({}, content), { attachments, embeds, nonce: UUID.generate() })
        }
      );
      return resp;
    });
  }
  /**
   * Deletes a webhook.
   *
   * @param webhookId - The ID of the webhook to delete
   * @param token - The token of the webhook
   * @returns Promise that resolves when the webhook is deleted
   *
   * @example
   * ```typescript
   * await client.webhooks.delete("webhookId", "webhookToken");
   * console.log("Webhook deleted successfully");
   * ```
   */
  delete(webhookId, token) {
    return __async(this, null, function* () {
      yield this.client.api.delete(`/webhooks/${webhookId}/${token}`);
    });
  }
  /**
   * Edits a webhook's properties.
   *
   * @param webhookId - The ID of the webhook to edit
   * @param token - The token of the webhook
   * @param options - The options to edit on the webhook
   * @returns Promise resolving to the updated webhook response
   *
   * @example
   * ```typescript
   * const updatedWebhook = await client.webhooks.edit("webhookId", "token", {
   *   name: "New Webhook Name",
   *   avatar: "https://example.com/new-avatar.png"
   * });
   * ```
   */
  edit(webhookId, token, options) {
    return __async(this, null, function* () {
      var _a;
      const data = new import_form_data3.default();
      let avatarID = void 0;
      if (typeof options.avatar === "string") {
        const readableStream = yield import_axios3.default.get(options.avatar, {
          responseType: "stream"
        });
        data.append("file", readableStream.data, {
          filename: options.avatar.split("/").pop()
        });
      }
      if (options.avatar instanceof import_stream3.Readable) {
        data.append("file", options.avatar, { filename: "avatar.png" });
      }
      if (options.avatar instanceof File) {
        const buffer = Buffer.from(yield options.avatar.arrayBuffer());
        data.append("file", buffer, { filename: options.avatar.name });
      }
      if (options.avatar) {
        yield this.client.cdn.post("/avatars", data).then((attachment) => {
          const { id } = attachment;
          avatarID = id;
        });
      }
      const response = yield this.client.api.patch(
        `/webhooks/${webhookId}/${token}`,
        {
          body: __spreadProps(__spreadValues({}, options), {
            avatar: avatarID,
            remove: (_a = options.remove) != null ? _a : []
          })
        }
      );
      return response;
    });
  }
  /**
   * Retrieves partial information about a webhook using only its ID.
   * This method provides limited webhook information without requiring a token.
   *
   * @param webhookId - The ID of the webhook to retrieve partial information for
   * @returns Promise resolving to the webhook response with partial information
   *
   * @example
   * ```typescript
   * const partialWebhook = await client.webhooks.getPartial("webhookId");
   * console.log(`Webhook name: ${partialWebhook.name}`);
   * ```
   */
  getPartial(webhookId) {
    return __async(this, null, function* () {
      const response = yield this.client.api.get(
        `/webhooks/${webhookId}`
      );
      return response;
    });
  }
};

// src/client/baseClient.ts
var import_node_events = require("events");

// src/rest/restClient.ts
var import_axios5 = __toESM(require("axios"));

// package.json
var version = "0.4.5";

// src/rest/restUtils/rateLimitQueue.ts
var import_axios4 = __toESM(require("axios"));
var RateLimitQueue = class {
  constructor() {
    this.bucketMap = /* @__PURE__ */ new Map();
    this.pathToBucket = /* @__PURE__ */ new Map();
  }
  request(config) {
    return __async(this, null, function* () {
      const path = config.url;
      const bucketId = this.pathToBucket.get(path);
      let bucket = bucketId ? this.bucketMap.get(bucketId) : void 0;
      if (bucket && bucket.remaining <= 0 && Date.now() < bucket.resetAfter) {
        return new Promise((resolve, reject) => {
          bucket.queue.push(() => __async(this, null, function* () {
            try {
              const res = yield this._doRequest(config, path);
              resolve(res);
            } catch (e) {
              console.error(e);
            }
          }));
        });
      } else {
        return this._doRequest(config, path);
      }
    });
  }
  _doRequest(config, path) {
    return __async(this, null, function* () {
      const response = yield (0, import_axios4.default)(config);
      this._updateRateLimit(path, response);
      return response;
    });
  }
  _updateRateLimit(path, response) {
    const headers = response.headers;
    const limit = parseInt(headers["x-ratelimit-limit"]);
    const remaining = parseInt(headers["x-ratelimit-remaining"]);
    const resetAfter = parseFloat(headers["x-ratelimit-reset-after"]) * 1e3 + Date.now();
    const bucket = headers["x-ratelimit-bucket"];
    const resetIn = parseInt(headers["x-ratelimit-reset-after"]);
    if (!bucket) return;
    this.pathToBucket.set(path, bucket);
    let state = this.bucketMap.get(bucket);
    if (!state) {
      state = {
        limit,
        remaining,
        resetAfter,
        bucket,
        resetIn,
        queue: [],
        lastPath: path
      };
      this.bucketMap.set(bucket, state);
    } else {
      state.limit = limit;
      state.remaining = remaining;
      state.resetAfter = resetAfter;
      state.lastPath = path;
    }
    if (remaining <= 0) {
      if (state.resetTimeout) clearTimeout(state.resetTimeout);
      const delay = resetIn;
      state.resetTimeout = setTimeout(() => {
        state.remaining = state.limit;
        state.resetTimeout = void 0;
        while (state.queue.length > 0 && state.remaining > 0) {
          const fn = state.queue.shift();
          if (fn) {
            state.remaining--;
            fn();
          }
        }
      }, delay);
    }
  }
};

// src/rest/restClient.ts
var RestClient = class {
  constructor(client3) {
    this.client = client3;
    this.rateLimitQueue = new RateLimitQueue();
  }
  /**
   * Helper function to handle API requests.
   * @param method The HTTP method (GET, POST, PATCH, PUT, DELETE).
   * @param url The URL for the request.
   * @param body The request body (if applicable).
   * @param query Query parameters (if applicable).
   * @returns The API response.
   */
  request(method, url, body, query, retry) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f;
      try {
        if (!this.client.token) throw new Error("Token is required");
        const authHeader = this.client.bot ? "X-Bot-Token" : "X-Session-Token";
        const config = __spreadProps(__spreadValues({}, {
          method,
          url: `${((_a = this.client.options.rest) == null ? void 0 : _a.instanceURL) ? (_b = this.client.options.rest) == null ? void 0 : _b.instanceURL : apiUrl}${url}`,
          params: query,
          data: body == null ? void 0 : body.body,
          headers: {
            [authHeader]: this.client.token,
            "User-Agent": `StoatBot.js/${version}`
          }
        }), {
          url: `${((_c = this.client.options.rest) == null ? void 0 : _c.instanceURL) ? (_d = this.client.options.rest) == null ? void 0 : _d.instanceURL : apiUrl}${url}`
        });
        if (process.env.NODE_ENV === "DEV") {
          console.info("Request Body:", body);
          console.info("Request Query:", query);
          console.info("Request URL:", config.url);
        }
        const response = yield this.rateLimitQueue.request(config);
        return response.data;
      } catch (error) {
        if (retry) throw typeof error;
        if (error instanceof import_axios5.AxiosError) {
          if (error.status && (error.status === 429 || error.status >= 500)) {
            return this.retryRequest(0, method, url, body, query);
          }
          if (error.status) {
            if (process.env.NODE_ENV === "DEV") {
              console.error("Error details:", error);
              console.error("Error response data:", (_e = error.response) == null ? void 0 : _e.data);
              console.error("Error request config:", error.config);
              console.error("Error message:", error.message);
              console.error("Error URL:", url);
            }
            throw new Error(
              `API call failed with status ${error.status}: ${(_f = error.response) == null ? void 0 : _f.statusText}`
            );
          }
        }
        throw new Error(
          `API call failed: ${error instanceof Error ? error.message : error}`
        );
      }
    });
  }
  getConfig() {
    return __async(this, null, function* () {
      var _a, _b;
      try {
        const response = yield import_axios5.default.get(
          `${((_a = this.client.options.rest) == null ? void 0 : _a.instanceURL) ? (_b = this.client.options.rest) == null ? void 0 : _b.instanceURL : apiUrl}/`
        );
        const config = response.data;
        this.client.options.rest = __spreadProps(__spreadValues({}, this.client.options.rest), {
          instanceCDNURL: config.features.autumn.url
        });
        this.client.options.ws = __spreadProps(__spreadValues({}, this.client.options.ws), {
          instanceURL: config.ws
        });
        this.client.voiceOptions = __spreadValues({}, config.features.livekit);
      } catch (error) {
        console.error("Failed to fetch configuration:", error);
        process.exit(1);
      }
    });
  }
  retryRequest(attempt = 0, method, url, body, query) {
    return __async(this, null, function* () {
      var _a, _b;
      if (attempt >= ((_b = (_a = this.client.options.rest) == null ? void 0 : _a.retries) != null ? _b : 3)) {
        throw new Error("Max retries reached");
      }
      try {
        return yield this.request(method, url, body, query, true);
      } catch (error) {
        console.warn(`Attempt ${attempt + 1} failed:`, error);
        yield new Promise(
          (resolve) => {
            var _a2, _b2, _c;
            return setTimeout(
              resolve,
              (_c = (_a2 = this.client.options.rest) == null ? void 0 : _a2.timeout) != null ? _c : (_b2 = DEFAULT_CLIENT_OPTIONS.rest) == null ? void 0 : _b2.timeout
            );
          }
        );
        return this.retryRequest(attempt + 1, method, url, body, query);
      }
    });
  }
  /**
   * GET request.
   * @param url The URL for the request.
   * @param query Query parameters (if applicable).
   * @returns The API response.
   */
  get(url, query) {
    return __async(this, null, function* () {
      return this.request("GET", url, void 0, query);
    });
  }
  /**
   * POST request.
   * @param url The URL for the request.
   * @param body The request body.
   * @param query Query parameters (if applicable).
   * @returns The API response.
   */
  post(url, body, query) {
    return __async(this, null, function* () {
      return this.request("POST", url, body, query);
    });
  }
  /**
   * PATCH request.
   * @param url The URL for the request.
   * @param body The request body.
   * @param query Query parameters (if applicable).
   * @returns The API response.
   */
  patch(url, body, query) {
    return __async(this, null, function* () {
      return this.request("PATCH", url, body, query);
    });
  }
  /**
   * PUT request.
   * @param url The URL for the request.
   * @param body The request body.
   * @param query Query parameters (if applicable).
   * @returns The API response.
   */
  put(url, body, query) {
    return __async(this, null, function* () {
      return this.request("PUT", url, body, query);
    });
  }
  /**
   * DELETE request.
   * @param url The URL for the request.
   * @param query Query parameters (if applicable).
   * @returns The API response.
   */
  delete(url, body, query) {
    return __async(this, null, function* () {
      return this.request("DELETE", url, body, query);
    });
  }
};

// src/rest/CDNClient.ts
var import_axios6 = require("axios");
var CDNClient = class {
  constructor(client3) {
    this.client = client3;
    this.rateLimitQueue = new RateLimitQueue();
  }
  /**
   * Helper function to handle API requests.
   * @param method The HTTP method (GET, POST, PATCH, PUT, DELETE).
   * @param url The URL for the request.
   * @param body The request body (if applicable).
   * @param query Query parameters (if applicable).
   * @returns The API response.
   */
  request(method, url, data, query, retry) {
    return __async(this, null, function* () {
      var _a, _b;
      try {
        if (!this.client.token) throw new Error("Token is required");
        const authHeader = this.client.bot ? "X-Bot-Token" : "X-Session-Token";
        const config = __spreadProps(__spreadValues({}, {
          method,
          url: `${(_a = this.client.options.rest) == null ? void 0 : _a.instanceCDNURL}${url}`,
          params: query,
          data,
          maxBodyLength: Infinity,
          headers: __spreadValues({
            [authHeader]: this.client.token,
            "Content-Type": "multipart/form-data",
            "User-Agent": `StoatBot.js/${version}`
          }, data.getHeaders())
        }), {
          url: `${(_b = this.client.options.rest) == null ? void 0 : _b.instanceCDNURL}${url}`
        });
        if (process.env.NODE_ENV === "DEV") {
          console.info("Request Data:", data);
          console.info("Request Query:", query);
          console.info("Request URL:", config.url);
        }
        const response = yield this.rateLimitQueue.request(config);
        return response.data;
      } catch (error) {
        if (retry) throw typeof error;
        if (error instanceof import_axios6.AxiosError) {
          if (error.status && (error.status === 429 || error.status >= 500)) {
            return this.retryRequest(0, method, url, data, query);
          }
          if (error.status) {
            console.error(`API call failed with status ${error.status}:`, error);
            throw new Error(
              `API call failed with status ${error.status}: ${error.message}`
            );
          }
        }
        throw new Error(
          `API call failed: ${error instanceof Error ? error.message : error}`
        );
      }
    });
  }
  retryRequest(attempt = 0, method, url, body, query) {
    return __async(this, null, function* () {
      var _a, _b;
      if (attempt >= ((_b = (_a = this.client.options.rest) == null ? void 0 : _a.retries) != null ? _b : 3)) {
        throw new Error("Max retries reached");
      }
      try {
        return yield this.request(method, url, body, query, true);
      } catch (error) {
        console.warn(`Attempt ${attempt + 1} failed:`, error);
        yield new Promise(
          (resolve) => {
            var _a2, _b2, _c;
            return setTimeout(
              resolve,
              (_c = (_a2 = this.client.options.rest) == null ? void 0 : _a2.timeout) != null ? _c : (_b2 = DEFAULT_CLIENT_OPTIONS.rest) == null ? void 0 : _b2.timeout
            );
          }
        );
        return this.retryRequest(attempt + 1, method, url, body, query);
      }
    });
  }
  /**
   * POST request.
   * @param url The URL for the request.
   * @param data The request body.
   * @returns The API response.
   */
  post(url, data) {
    return __async(this, null, function* () {
      return this.request("POST", url, data);
    });
  }
};

// src/client/baseClient.ts
var _token, _useDefaultErrorHandler;
var BaseClient = class extends import_node_events.EventEmitter {
  /**
   * Creates a new BaseClient instance.
   *
   * @param {clientOptions} [options={}] - The options for configuring the client.
   */
  constructor(options = {}) {
    var _a, _b, _c;
    if ((_a = options.rest) == null ? void 0 : _a.instanceURL) {
      if (!((_b = options.rest) == null ? void 0 : _b.instanceURL)) {
        console.error(
          'instance URLs must be provided (REST) see docs at "https://jade3375.github.io/stoatbot.js/interfaces/clientOptions.html"'
        );
        process.exit(0);
      } else {
        console.warn(
          "You are connecting to a custom instance of Revolt. compatibility with StoatBot.js is not guaranteed."
        );
      }
    }
    super();
    /** The authentication token for the client. */
    __privateAdd(this, _token, null);
    this.voiceOptions = { enabled: false };
    /** Track current voice connection to prevent AlreadyConnected errors */
    this.currentVoiceConnection = null;
    /** Whether the client is a bot. */
    this.bot = true;
    /** Whether to use the default error handler */
    __privateAdd(this, _useDefaultErrorHandler, true);
    this.options = __spreadValues(__spreadValues({}, DEFAULT_CLIENT_OPTIONS), options);
    this.bot = (_c = this.options.isBot) != null ? _c : true;
    this.api = new RestClient(this);
    this.cdn = new CDNClient(this);
    this.on("error", (error) => {
      if (__privateGet(this, _useDefaultErrorHandler) && this.listenerCount("error") === 1) {
        console.error(
          "[stoatbot.js] Unhandled client error occurred. Consider adding an error listener to your client:",
          error
        );
        console.error(
          "Example: client.on('error', (error) => { console.error('Bot error:', error); });"
        );
      }
    });
    this.on("newListener", (event) => {
      if (event === "error") {
        __privateSet(this, _useDefaultErrorHandler, false);
      }
    });
  }
  /**
   * Emits a debug message.
   *
   * @param {unknown} msg - The debug message to emit.
   */
  debug(msg) {
    this.emit("debug" /* DEBUG */, msg);
  }
  /**
   * Sets the authentication token for the client.
   *
   * @param {string | null} token - The authentication token.
   */
  set token(token) {
    __privateSet(this, _token, token);
  }
  /**
   * Gets the authentication token for the client.
   *
   * @returns {string | null} The authentication token, or `null` if not set.
   */
  get token() {
    return __privateGet(this, _token);
  }
};
_token = new WeakMap();
_useDefaultErrorHandler = new WeakMap();

// src/client/events/event.ts
var Event = class {
  /**
   * Creates a new Event instance.
   *
   * @param {client} client - The client instance.
   */
  constructor(client3) {
    this.client = client3;
  }
};

// src/client/events/bulkMessageDelete.ts
var BulkMessageDelete = class extends Event {
  /**
   * Handles the bulk message delete event.
   *
   * @param {{ ids: string[] }} data - The data for the event, containing the IDs of the deleted messages.
   */
  handle(data) {
    this.client.emit("messageDeleteBulk" /* MESSAGE_DELETE_BULK */, data.ids);
  }
};

// src/client/events/channelCreate.ts
var ChannelCreate = class extends Event {
  /**
   * Handles the channel creation event.
   *
   * @param {API.Channel} data - The raw data for the created channel from the API.
   * @returns {Promise<{ channel: unknown }>} A promise that resolves with the created channel.
   * @private
   */
  handle(data) {
    return __async(this, null, function* () {
      var _a;
      const channel = this.client.channels._add(data);
      if (channel) {
        if (channel.inServer()) {
          const server = (_a = channel.server) != null ? _a : yield this.client.servers.fetch(channel.serverId);
          server.channels.cache.set(channel.id, channel);
        }
        this.client.emit("channelCreate" /* CHANNEL_CREATE */, channel);
      }
      return { channel };
    });
  }
};

// src/client/events/channelDelete.ts
var ChannelDelete = class extends Event {
  /**
   * Handles the channel deletion event.
   *
   * @param {{ id: string }} data - The data for the event, containing the ID of the deleted channel.
   * @returns {{ channel: unknown }} An object containing the deleted channel, or `undefined` if not found.
   */
  handle(data) {
    var _a;
    const channel = this.client.channels.cache.get(data.id);
    if (channel) {
      if (channel.inServer()) {
        (_a = channel.server) == null ? void 0 : _a.channels.cache.delete(channel.id);
      }
      this.client.emit("channelDelete" /* CHANNEL_DELETE */, channel);
    }
    return { channel };
  }
};

// src/client/events/channelGroupJoin.ts
var ChannelGroupJoin = class extends Event {
  /**
   * Handles the group channel join event.
   *
   * @param {{ id: string; user: string }} data - The data for the event, containing the channel ID and user ID.
   * @returns {Promise<{ channel: unknown; user: unknown }>} A promise that resolves with the updated channel and user.
   */
  handle(data) {
    return __async(this, null, function* () {
      const channel = this.client.channels.cache.get(data.id);
      const user = yield this.client.users.fetch(data.user, { force: false });
      if (channel == null ? void 0 : channel.isGroup()) {
        channel.users.set(user.id, user);
        this.client.emit("groupJoin" /* GROUP_JOIN */, channel, user);
      }
      return { channel, user };
    });
  }
};

// src/client/events/channelGroupLeave.ts
var ChannelGroupLeave = class extends Event {
  /**
   * Handles the group channel leave event.
   *
   * @param {{ id: string; user: string }} data - The data for the event, containing the channel ID and user ID.
   * @returns {Promise<{ channel: unknown; user: unknown }>} A promise that resolves with the updated channel and user.
   */
  handle(data) {
    return __async(this, null, function* () {
      const channel = this.client.channels.cache.get(data.id);
      const user = yield this.client.users.fetch(data.user, { force: false });
      if (channel == null ? void 0 : channel.isGroup()) {
        channel.users.delete(data.user);
        this.client.emit("groupLeave" /* GROUP_LEAVE */, channel, user);
      }
      return { channel, user };
    });
  }
};

// src/client/events/channelStarttyping.ts
var ChannelStartTyping = class extends Event {
  /**
   * Handles the typing start event.
   *
   * @param {{ id: string; user: string }} data - The data for the event, containing the channel ID and user ID.
   * @returns {{ channel: unknown; user: unknown }} An object containing the channel and user involved in the event.
   */
  handle(data) {
    const channel = this.client.channels.cache.get(data.id);
    const user = this.client.users.cache.get(data.user);
    if ((channel == null ? void 0 : channel.isText()) && user) {
      this.client.emit("typingStart" /* TYPING_START */, channel, user);
    }
    return { channel, user };
  }
};

// src/client/events/channelStopTyping.ts
var ChannelStopTyping = class extends Event {
  /**
   * Handles the typing stop event.
   *
   * @param {{ id: string; user: string }} data - The data for the event, containing the channel ID and user ID.
   * @returns {{ channel: unknown; user: unknown }} An object containing the channel and user involved in the event.
   */
  handle(data) {
    const channel = this.client.channels.cache.get(data.id);
    const user = this.client.users.cache.get(data.user);
    if ((channel == null ? void 0 : channel.isText()) && user) {
      this.client.emit("typingStop" /* TYPING_STOP */, channel, user);
    }
    return { channel, user };
  }
};

// src/client/events/channelUpdate.ts
var ChannelUpdate = class extends Event {
  /**
   * Handles the channel update event.
   *
   * @param {{ id: string; data: API.Channel; clear: API.FieldsChannel }} data - The data for the event, containing the channel ID, updated data, and fields to clear.
   * @returns {void}
   */
  handle(data) {
    const channel = this.client.channels.cache.get(data.id);
    const oldChannel = channel == null ? void 0 : channel._update(data.data);
    if (channel && oldChannel && !channel.equals(oldChannel)) {
      this.client.emit("channelUpdate" /* CHANNEL_UPDATE */, oldChannel, channel);
    }
  }
};

// src/client/events/message.ts
var Message = class extends Event {
  /**
   * Handles the message event.
   *
   * @param {API.Message} data - The raw data for the message from the API.
   * @returns {Promise<{ message: unknown }>} A promise that resolves with the created message, or an empty object if the channel is not text-based.
   * @private
   */
  handle(data) {
    return __async(this, null, function* () {
      var _a;
      if (data.system) {
        return {};
      }
      const channel = this.client.channels.cache.get(data.channel);
      if (channel == null ? void 0 : channel.isText()) {
        if (((_a = data.user) == null ? void 0 : _a.bot) && this.client.options.ignoreBots) {
          return {};
        }
        const message = channel.messages._add(data);
        if (data.author !== SYSTEM_USER_ID && !data.webhook) {
          yield this.client.users.fetch(data.author, { force: false });
        }
        this.client.emit("message" /* MESSAGE */, message);
        return { message };
      }
      return {};
    });
  }
};

// src/client/events/messageDelete.ts
var MessageDelete = class extends Event {
  /**
   * Handles the message deletion event.
   *
   * @param {{ id: string; channel: string }} data - The data for the event, containing the message ID and channel ID.
   * @returns {{ message: unknown } | {}} An object containing the deleted message, or an empty object if the channel is not text-based or the message is not found.
   */
  handle(data) {
    const channel = this.client.channels.cache.get(data.channel);
    if (channel == null ? void 0 : channel.isText()) {
      const message = channel.messages.cache.get(data.id);
      if (message) {
        channel.messages._remove(message.id);
        this.client.emit("messageDelete" /* MESSAGE_DELETE */, message);
      }
      return { message };
    }
    return {};
  }
};

// src/client/events/messageUpdate.ts
var MessageUpdate = class extends Event {
  /**
   * Handles the message update event.
   *
   * @param {{ id: string; channel: string; data: API.Message }} data - The data for the event, containing the message ID, channel ID, and updated message data.
   * @returns {void}
   */
  handle(data) {
    const channel = this.client.channels.cache.get(data.channel);
    if (!(channel == null ? void 0 : channel.isText())) return;
    const message = channel == null ? void 0 : channel.messages.cache.get(data.id);
    const oldMessage = message == null ? void 0 : message._update(data.data);
    if (oldMessage && message && !message.equals(oldMessage)) {
      this.client.emit("messageUpdate" /* MESSAGE_UPDATE */, oldMessage, message);
    }
  }
};

// src/client/events/serverCreate.ts
var ServerCreate = class extends Event {
  /**
   * Handles the server creation event.
   *
   * @param {API.Server} data - The raw data for the created server from the API.
   * @returns {Promise<void>} A promise that resolves when the server is added and members are optionally fetched.
   * @private
   */
  handle(data) {
    return __async(this, null, function* () {
      const server = this.client.servers._add(data);
      if (this.client.options.fetchMembers) {
        yield server.members.fetch();
      }
      this.client.emit("serverCreate" /* SERVER_CREATE */, server);
    });
  }
};

// src/client/events/serverDelete.ts
var ServerDelete = class extends Event {
  /**
   * Handles the server deletion event.
   *
   * @param {API.Server} data - The raw data for the deleted server from the API.
   * @returns {{ server: unknown }} An object containing the deleted server, or `undefined` if not found.
   */
  handle(data) {
    const server = this.client.servers.cache.get(data._id);
    if (server) {
      this.client.servers._remove(server.id);
      this.client.emit("serverDelete" /* SERVER_DELETE */, server);
    }
    return { server };
  }
};

// src/client/events/serverMemberJoin.ts
var ServerMemberJoin = class extends Event {
  /**
   * Handles the server member join event.
   *
   * @param {{ id: string; user: string }} data - The data for the event, containing the server ID and user ID.
   * @returns {Promise<{ member: unknown }>} A promise that resolves with the joined member.
   */
  handle(data) {
    return __async(this, null, function* () {
      let server = this.client.servers.cache.get(data.id);
      if (!server) {
        server = yield this.client.servers.fetch(data.id);
        this.client.emit("serverCreate" /* SERVER_CREATE */, server);
      }
      const member = yield server.members.fetch(data.user);
      server.members.cache.set(member.id, member);
      this.client.emit("serverMemberJoin" /* SERVER_MEMBER_JOIN */, member);
      return { member };
    });
  }
};

// src/client/events/serverMemberLeave.ts
var ServerMemberLeave = class extends Event {
  /**
   * Handles the server member leave event.
   *
   * @param {{ id: string; user: string }} data - The data for the event, containing the server ID and user ID.
   * @returns {{ server: unknown; member?: unknown }} An object containing the server and the member who left, or just the server if the member is not found.
   */
  handle(data) {
    const server = this.client.servers.cache.get(data.id);
    if (server) {
      const member = server.members.cache.get(data.user);
      if (member) {
        server.members._remove(member.id);
        this.client.emit("serverMemberLeave" /* SERVER_MEMBER_LEAVE */, member);
      }
      return { server, member };
    }
    return { server };
  }
};

// src/client/events/serverMemberUpdate.ts
var ServerMemberUpdate = class extends Event {
  /**
   * Handles the server member update event.
   *
   * @param {{ id: string; data: API.Member }} data - The data for the event, containing the server ID and updated member data.
   * @returns {void}
   */
  handle(data) {
    const updateData = __spreadProps(__spreadValues({}, data.data), {
      _id: { server: data.id.server, user: data.id.user }
    });
    const server = this.client.servers.cache.get(data.id.server);
    const member = server == null ? void 0 : server.members.cache.get(data.id.user);
    const oldMember = member == null ? void 0 : member._update(updateData);
    if (oldMember && member && (!member.equals(oldMember) || areRolesDifferent(member.roles, oldMember.roles))) {
      this.client.emit("serverMemberUpdate" /* SERVER_MEMBER_UPDATE */, oldMember, member);
    }
  }
};
function areRolesDifferent(rolesA, rolesB) {
  const idsA = rolesA.map((role) => role.id).sort();
  const idsB = rolesB.map((role) => role.id).sort();
  return idsA.length !== idsB.length || !idsA.every((id, index) => id === idsB[index]);
}

// src/client/events/serverRoleDelete.ts
var ServerRoleDelete = class extends Event {
  /**
   * Handles the server role deletion event.
   *
   * @param {{ id: string; role_id: string }} data - The data for the event, containing the server ID and role ID.
   * @returns {{ role: unknown } | {}} An object containing the deleted role, or an empty object if the role or server is not found.
   */
  handle(data) {
    const server = this.client.servers.cache.get(data.id);
    if (server) {
      const role = server.roles.cache.get(data.role_id);
      if (role) {
        server.roles._remove(role.id);
        this.client.emit("roleDelete" /* ROLE_DELETE */, role);
      }
      return { role };
    }
    return {};
  }
};

// src/client/events/serverRoleUpdate.ts
var ServerRoleUpdate = class extends Event {
  /**
   * Handles the server role update event.
   *
   * @param {{ id: string; role_id: string; data: API.Role & { _id: string }; clear: API.FieldsRole[] }} data - The data for the event, containing the server ID, role ID, updated role data, and fields to clear.
   * @returns {void}
   */
  handle(data) {
    return __async(this, null, function* () {
      const server = this.client.servers.cache.get(data.id);
      if (!server) return;
      let role = server.roles.cache.get(data.role_id);
      const oldRole = role == null ? void 0 : role._update(data.data, data.clear);
      if (!oldRole && !role) {
        yield Promise.all(
          Object.values(data.data).map((raw) => __async(this, null, function* () {
            if (raw && typeof raw === "object") {
              server.roles._add(__spreadProps(__spreadValues({
                name: "",
                permissions: {
                  a: 0,
                  d: 0
                }
              }, raw), {
                id: data.role_id
              }));
            }
          }))
        );
        role = server.roles.cache.get(data.role_id);
      }
      if (role && oldRole && !role.equals(oldRole)) {
        this.client.emit("roleUpdate" /* ROLE_UPDATE */, oldRole, role);
      }
    });
  }
};

// src/client/events/serverupdate.ts
var ServerUpdate = class extends Event {
  /**
   * Handles the server update event.
   *
   * @param {{ id: string; data: API.Server; clear: API.FieldsServer[] }} data - The data for the event, containing the server ID, updated server data, and fields to clear.
   * @returns {void}
   */
  handle(data) {
    const server = this.client.servers.cache.get(data.id);
    const oldServer = server == null ? void 0 : server._update(data.data, data.clear);
    if (oldServer && server && !oldServer.equals(server)) {
      this.client.emit("serverUpdate" /* SERVER_UPDATE */, oldServer, server);
    }
  }
};

// src/client/events/userUpdate.ts
var UserUpdate = class extends Event {
  /**
   * Handles the user update event.
   *
   * @param {{ id: string; data: API.User; clear: API.FieldsUser[] }} data - The data for the event, containing the user ID, updated user data, and fields to clear.
   * @returns {void}
   */
  handle(data) {
    const user = data.id === this.client.user.id ? this.client.user : this.client.users.cache.get(data.id);
    const oldUser = user == null ? void 0 : user._update(data.data, data.clear);
    if (user && oldUser && !user.equals(oldUser)) {
      this.client.emit("userUpdate" /* USER_UPDATE */, oldUser, user);
    }
  }
};

// src/client/events/messageReact.ts
var MessageReact = class extends Event {
  /**
   * Handles the message reaction event.
   *
   * @param {MessageReactData} data - The data for the event, containing the message ID, channel ID, user ID, and emoji ID.
   * @returns {Promise<unknown>} A promise that resolves with an empty object.
   */
  handle(data) {
    return __async(this, null, function* () {
      var _a, _b;
      const channel = this.client.channels.cache.get(data.channel_id);
      if (channel == null ? void 0 : channel.isText()) {
        let message = channel.messages.cache.get(data.id) ? channel.messages.cache.get(data.id) : yield channel.messages.fetch(data.id);
        if (message) {
          if ((_a = message.reactions.get(data.emoji_id)) == null ? void 0 : _a.indexOf(data.user_id)) return;
          if (!((_b = message.reactions.get(data.emoji_id)) == null ? void 0 : _b.push(data.user_id)))
            message.reactions.set(data.emoji_id, [data.user_id]);
          this.client.emit("messageReact" /* MESSAGE_REACT */, message);
        }
      }
      return {};
    });
  }
};

// src/client/events/messageUnreact.ts
var MessageUnreact = class extends Event {
  /**
   * Handles the message reaction removal event.
   *
   * @param {MessageReactData} data - The data for the event, containing the message ID, channel ID, user ID, and emoji ID.
   * @returns {Promise<unknown>} A promise that resolves with an empty object.
   */
  handle(data) {
    return __async(this, null, function* () {
      const channel = this.client.channels.cache.get(data.channel_id);
      if (channel == null ? void 0 : channel.isText()) {
        let message = channel.messages.cache.get(data.id) ? channel.messages.cache.get(data.id) : yield channel.messages.fetch(data.id);
        if (message) {
          const reaction = message.reactions.get(data.emoji_id);
          if (reaction) {
            const index = reaction.indexOf(data.user_id);
            if (index !== -1) {
              reaction.splice(index, 1);
            }
            if (reaction.length === 0) {
              message.reactions.delete(data.emoji_id);
            }
          }
          this.client.emit("messageUnreact" /* MESSAGE_REACT_REMOVE */, message);
        }
      }
      return {};
    });
  }
};

// src/client/events/webhookCreate.ts
var WebhookCreate = class extends Event {
  /**
   * Handles the webhook create event.
   * @param {id: string, channel_id: string, server_id: string, name: string} data - The data for the event, containing the webhook ID, channel ID, server ID, and name.
   * @returns {void}
   */
  handle(data) {
    const webhookData = {
      webhookId: data.id,
      channelId: data.channel_id,
      name: data.name,
      creatorId: data.creator_id,
      token: data.token
    };
    this.client.emit("webhookCreate" /* WEBHOOKS_CREATE */, webhookData);
  }
};

// src/client/events/webhookDelete.ts
var WebhookDelete = class extends Event {
  /**
   * Handles the webhook delete event.
   * @param {id: string, channel_id: string, server_id: string} data - The data for the event, containing the webhook ID, channel ID, and server ID.
   * @returns {void}
   */
  handle(data) {
    const webhookData = {
      webhookId: data.id
    };
    this.client.emit("webhookDelete" /* WEBHOOKS_DELETE */, webhookData);
  }
};

// src/client/events/webhookUpdate.ts
var WebhookUpdate = class extends Event {
  /**
   * Handles the webhook update event.
   * @param {id: string, data: { name: string; avatar?: { _id: string; tag: string; filename: string; metadata: any; content_type: string; size: number; }; remove: string[]; }} data- The data for the event, containing the webhook ID and updated webhook data.
   * @returns {void}
   */
  handle(data) {
    const webhookData = {
      webhookId: data.id,
      name: data.data.name,
      avatar: data.data.avatar,
      remove: data.data.remove
    };
    this.client.emit("webhookUpdate" /* WEBHOOKS_UPDATE */, webhookData);
  }
};

// src/client/events/userVoiceStateUpdate.ts
var UserVoiceStateUpdate = class extends Event {
  /**
   * Handles the user voice state update event.
   * @param {{ id: string; channel_id: string; data: { is_publishing: boolean; screensharing: boolean; camera: boolean; }; }} data - The data for the event, containing the user ID, channel ID, and updated voice state data.
   * @returns {void}
   */
  handle(data) {
    this.client.emit("userVoiceStateUpdate" /* USER_VOICE_STATE_UPDATE */, data);
  }
};

// src/client/events/voiceChannelJoin.ts
var VoiceChannelJoin = class extends Event {
  /**
   * Handles the voice channel join event.
   * @param {{ id: string; state: voiceParticipant; }} data - The data for the event, containing the channel ID and participant state.
   * @returns {void}
   */
  handle(data) {
    var _a;
    const channel = this.client.channels.cache.get(data.id);
    if ((channel == null ? void 0 : channel.type) === "VOICE" /* VOICE */ || (channel == null ? void 0 : channel.type) === "GROUP" /* GROUP */) {
      (_a = channel.voice) == null ? void 0 : _a.set(data.id, data.state);
    }
    this.client.emit("voiceChannelJoin" /* VOICE_CHANNEL_JOIN */, data);
  }
};

// src/client/events/voiceChannelLeave.ts
var VoiceChannelLeave = class extends Event {
  /**
   * Handles the voice channel leave event.
   * @param {{ id: string; user: string; }} data - The data for the event, containing the channel ID and user ID.
   * @returns {void}
   */
  handle(data) {
    var _a;
    const channel = this.client.channels.cache.get(data.id);
    if ((channel == null ? void 0 : channel.type) === "VOICE" /* VOICE */ || (channel == null ? void 0 : channel.type) === "GROUP" /* GROUP */) {
      (_a = channel.voice) == null ? void 0 : _a.delete(data.id);
    }
    this.client.emit("voiceChannelLeave" /* VOICE_CHANNEL_LEAVE */, data);
  }
};

// src/client/events/index.ts
var EventMap = {
  bulkMessageDelete: BulkMessageDelete,
  channelCreate: ChannelCreate,
  channelDelete: ChannelDelete,
  channelGroupJoin: ChannelGroupJoin,
  channelGroupLeave: ChannelGroupLeave,
  channelStartTyping: ChannelStartTyping,
  channelStopTyping: ChannelStopTyping,
  channelUpdate: ChannelUpdate,
  message: Message,
  messageDelete: MessageDelete,
  messageUpdate: MessageUpdate,
  serverCreate: ServerCreate,
  serverDelete: ServerDelete,
  serverMemberJoin: ServerMemberJoin,
  serverMemberLeave: ServerMemberLeave,
  serverMemberUpdate: ServerMemberUpdate,
  serverRoleDelete: ServerRoleDelete,
  serverRoleUpdate: ServerRoleUpdate,
  serverUpdate: ServerUpdate,
  userUpdate: UserUpdate,
  messageReact: MessageReact,
  messageUnreact: MessageUnreact,
  webhookCreate: WebhookCreate,
  webhookDelete: WebhookDelete,
  webhookUpdate: WebhookUpdate,
  userVoiceStateUpdate: UserVoiceStateUpdate,
  voiceChannelJoin: VoiceChannelJoin,
  voiceChannelLeave: VoiceChannelLeave
};

// src/client/events/eventManager.ts
var _events;
var EventManager = class {
  /**
   * Creates a new EventManager instance.
   *
   * @param {client} client - The client instance.
   */
  constructor(client3) {
    this.client = client3;
    /** A map of registered events, keyed by their names. */
    __privateAdd(this, _events, /* @__PURE__ */ new Map());
    var _a;
    for (const [key, Event2] of Object.entries(EventMap)) {
      if ((_a = this.client.options.ignoreEvents) == null ? void 0 : _a.includes(key)) return;
      this.register(Event2);
    }
  }
  /**
   * Registers an event with the manager.
   *
   * @param {new (client: client) => CustomEvent} Event - The event class to register.
   */
  register(Event2) {
    __privateGet(this, _events).set(Event2.name.replace(/Events$/, ""), new Event2(this.client));
  }
  /**
   * Retrieves a registered event by its name.
   *
   * @param {string} name - The name of the event to retrieve.
   * @returns {CustomEvent | null} The event instance, or `null` if not found.
   */
  get(name) {
    var _a;
    return (_a = __privateGet(this, _events).get(name)) != null ? _a : null;
  }
};
_events = new WeakMap();

// src/client/player.ts
var import_node_child_process = require("child_process");
var import_node_stream = require("stream");
var import_node_events2 = require("events");
var import_node_fs = require("fs");
var import_node_url = require("url");
var import_rtc_node = require("@livekit/rtc-node");
var AudioPlayer = class extends import_node_events2.EventEmitter {
  // Flag to control streaming audio playback
  constructor(channelId, serverId, client3) {
    super();
    this._volume = 1;
    this.publications = /* @__PURE__ */ new Map();
    this.audioSources = /* @__PURE__ */ new Map();
    this.isConnected = false;
    this.shouldStop = false;
    // Flag to control audio playback cancellation
    this.isStreaming = false;
    this.channelId = channelId;
    this.serverId = serverId;
    this.client = client3;
  }
  /**
   * Get the channel ID this player is associated with
   */
  get channel() {
    return this.channelId;
  }
  /**
   * Get the server ID this player is associated with
   */
  get server() {
    return this.serverId;
  }
  /**
   * Get current volume level (0.0 to 2.0)
   */
  get volume() {
    return this._volume;
  }
  /**
   * Check if the player is connected to a voice channel
   */
  get connected() {
    return this.isConnected && !!this.room;
  }
  /**
   * Set volume level
   * @param level - Volume level from 0.0 (mute) to 2.0 (200%)
   */
  setVolume(level) {
    const oldVolume = this._volume;
    this._volume = Math.max(0, Math.min(2, level));
    this.emit("debug", `Volume set to ${(this._volume * 100).toFixed(0)}%`, {
      oldVolume,
      newVolume: this._volume
    });
    this.emit("volumeChanged", oldVolume, this._volume);
  }
  /**
   * Increase volume by specified amount
   * @param amount - Amount to increase (default: 0.1)
   */
  increaseVolume(amount = 0.1) {
    this.setVolume(this._volume + amount);
  }
  /**
   * Decrease volume by specified amount
   * @param amount - Amount to decrease (default: 0.1)
   */
  decreaseVolume(amount = 0.1) {
    this.setVolume(this._volume - amount);
  }
  /**
   * Mute audio (set volume to 0)
   */
  mute() {
    const oldVolume = this._volume;
    this.setVolume(0);
    this.emit("muted", oldVolume);
  }
  /**
   * Unmute audio (restore to 100% if currently muted)
   */
  unmute() {
    if (this._volume === 0) {
      this.setVolume(1);
      this.emit("unmuted", 1);
    }
  }
  /**
   * Apply volume to PCM audio data
   * @param pcmData - Int16Array audio data
   * @returns Modified PCM data with volume applied
   * @private
   */
  applyVolume(pcmData) {
    if (this._volume === 1) return pcmData;
    const result = new Int16Array(pcmData.length);
    for (let i = 0; i < pcmData.length; i++) {
      const sample = pcmData[i] * this._volume;
      result[i] = Math.max(-32768, Math.min(32767, Math.round(sample)));
    }
    return result;
  }
  /**
   * Check if a string is a valid URL
   * @param input - The string to check
   * @returns True if the input is a valid URL
   */
  isUrl(input) {
    try {
      const url = new import_node_url.URL(input);
      return url.protocol === "http:" || url.protocol === "https:";
    } catch (e) {
      return false;
    }
  }
  /**
   * Check if a string is a valid file path that exists
   * @param input - The string to check
   * @returns True if the input is an existing file path
   * @private
   */
  isFilePath(input) {
    try {
      return (0, import_node_fs.existsSync)(input);
    } catch (e) {
      return false;
    }
  }
  /**
   * Check if input is a Readable stream
   * @param input - The input to check
   * @returns True if the input is a Readable stream
   * @private
   */
  isStream(input) {
    return input instanceof import_node_stream.Readable;
  }
  /**
   * Connect to the voice channel
   */
  connect(targetChannelId) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d;
      const channelToConnect = targetChannelId || this.channelId;
      if (this.isConnected && channelToConnect !== this.channelId) {
        yield this.disconnect();
        this.channelId = channelToConnect;
      } else if (this.isConnected && channelToConnect === this.channelId) {
        return;
      }
      this.emit("debug", "Starting connection", {
        channelId: channelToConnect,
        serverId: this.serverId
      });
      try {
        const selectedNode = ((_a = this.client.voiceOptions.nodes) == null ? void 0 : _a[0].name) || "worldwide";
        let response;
        try {
          response = yield this.client.api.post(
            `/channels/${channelToConnect}/join_call`,
            { body: { node: selectedNode } }
          );
        } catch (joinError) {
          if (((_b = joinError.message) == null ? void 0 : _b.includes("AlreadyConnected")) || ((_d = (_c = joinError.response) == null ? void 0 : _c.data) == null ? void 0 : _d.type) === "AlreadyConnected") {
            try {
              yield this.client.api.delete(
                `/channels/${channelToConnect}/join_call`
              );
              response = yield this.client.api.post(
                `/channels/${channelToConnect}/join_call`,
                { body: { node: selectedNode } }
              );
            } catch (deleteError) {
              try {
                response = yield this.client.api.post(
                  `/channels/${channelToConnect}/join_call`,
                  { body: { node: selectedNode, force: true } }
                );
              } catch (forceError) {
                throw new Error(
                  `Unable to join voice channel: Bot is already connected to another voice channel.

This typically happens when:
\u2022 The bot didn't disconnect properly from a previous session
\u2022 Another instance of the bot is running
\u2022 The bot crashed without proper cleanup

Solutions to try:
1. Restart the bot application completely
2. Wait 30-60 seconds for the connection to timeout
3. Check if another bot instance is running
4. Check server permissions for voice channels

If this persists, the API may need manual intervention to clear the connection state.`
                );
              }
            }
          } else {
            throw joinError;
          }
        }
        const room = new import_rtc_node.Room();
        this.room = room;
        room.on(import_rtc_node.RoomEvent.Disconnected, this.handleDisconnected.bind(this));
        yield room.connect(response.url, response.token, {
          dynacast: true,
          autoSubscribe: true
        });
        this.isConnected = true;
        this.emit("connected", channelToConnect, this.serverId, room.name);
        this.emit("debug", "Connection established", { roomName: room.name });
      } catch (error) {
        this.emit(
          "error",
          error instanceof Error ? error : new Error(String(error)),
          "connection"
        );
        console.error(`\u274C [${channelToConnect}] Failed to connect:`, error);
        throw error;
      }
    });
  }
  /**
   * Generic play method that automatically detects the input type and uses the appropriate play method
   * @param input - Can be a URL string, file path string, or Readable stream
   * @returns Promise that resolves when playback starts
   *
   * @example
   * ```typescript
   * // Play from URL
   * await player.play("https://example.com/audio.mp3");
   *
   * // Play from file path
   * await player.play("/path/to/audio.mp3");
   *
   * // Play from stream
   * await player.play(readableStream);
   * ```
   */
  play(input) {
    return __async(this, null, function* () {
      if (this.isStream(input)) {
        this.emit("debug", "Auto-detected stream input", { type: "stream" });
        this.emit("audioStart", "stream", "stream");
        yield this.playFromStream(input, "stream", "stream");
      } else if (typeof input === "string") {
        if (this.isUrl(input)) {
          this.emit("debug", "Auto-detected URL input", { url: input });
          yield this.playFromUrl(input);
        } else if (this.isFilePath(input)) {
          this.emit("debug", "Auto-detected file path input", {
            filePath: input
          });
          yield this.playFromFile(input);
        } else {
          throw new Error(
            `Invalid input: '${input}' is neither a valid URL nor an existing file path`
          );
        }
      } else {
        throw new Error(
          `Unsupported input type: expected string or Readable stream, got ${typeof input}`
        );
      }
    });
  }
  /**
   * Play audio from a URL (supports both files and streaming URLs like radio stations)
   * @private
   */
  playFromUrl(url) {
    return __async(this, null, function* () {
      if (!this.connected) {
        yield this.connect();
      }
      this.emit("audioStart", url, "url");
      this.emit("debug", "Starting URL playback", { url });
      try {
        const https = yield import("https");
        const http = yield import("http");
        return new Promise((resolve, reject) => {
          const client3 = url.startsWith("https:") ? https : http;
          const request = client3.get(url, (response) => {
            if (response.statusCode !== 200) {
              const error = new Error(`HTTP Error: ${response.statusCode}`);
              console.error("HTTP Error:", error.message);
              this.emit("audioError", url, "url", error);
              return;
            }
            const contentType = response.headers["content-type"] || "";
            const contentLength = response.headers["content-length"];
            const isLiveStream = !contentLength || contentType.includes("audio/mpeg") && url.includes("stream") || contentType.includes("application/ogg") || url.toLowerCase().includes("radio") || url.toLowerCase().includes("stream");
            if (isLiveStream) {
              this.playStreamingAudio(response, url, "url").then(() => {
                this.emit("audioEnd", "URL playback completed", { url });
                resolve();
              }).catch((error) => {
                console.error("Error streaming audio from URL:", error);
                this.emit("audioError", url, "url", error);
                this.emit("error", error, "url-streaming");
              });
            } else {
              this.playFromStream(response, url, "url").then(() => {
                this.emit("debug", "URL playback completed", { url });
                resolve();
              }).catch((error) => {
                console.error("Error playing audio from URL:", error);
                this.emit("audioError", url, "url", error);
                this.emit("error", error, "url-standard");
              });
            }
          });
          request.on("error", (error) => {
            console.error("Request error:", error.message);
            this.emit("audioError", url, "url", error);
          });
          request.setTimeout(3e4, () => {
            const timeoutError = new Error("Request timeout");
            request.destroy();
            this.emit("audioError", url, "url", timeoutError);
          });
        });
      } catch (error) {
        const errorObj = error instanceof Error ? error : new Error(String(error));
        this.emit("audioError", url, "url", errorObj);
        this.emit("error", errorObj, "url-playback");
        console.error(`\u274C [${this.channelId}] URL playback failed:`, error);
        throw error;
      }
    });
  }
  /**
   * Play audio from a stream in real-time (for radio stations, live streams)
   */
  playStreamingAudio(audioStream, source, type) {
    return __async(this, null, function* () {
      this.shouldStop = false;
      this.isStreaming = true;
      if (!this.room) {
        throw new Error(
          `Not connected to voice channel ${this.channelId}. Call connect() first.`
        );
      }
      if (!this.room.localParticipant) {
        yield new Promise((resolve) => setTimeout(resolve, 1e3));
        if (!this.room.localParticipant) {
          throw new Error("Local participant not available after waiting");
        }
      }
      try {
        const sampleRate = 48e3;
        const channels = 1;
        const source2 = new import_rtc_node.AudioSource(sampleRate, channels);
        const sourceId = `stream_${Date.now()}`;
        this.audioSources.set(sourceId, source2);
        const track = import_rtc_node.LocalAudioTrack.createAudioTrack("audio", source2);
        const options = new import_rtc_node.TrackPublishOptions();
        options.source = import_rtc_node.TrackSource.SOURCE_MICROPHONE;
        const publication = yield this.room.localParticipant.publishTrack(
          track,
          options
        );
        if (publication) {
          this.publications.set(publication.sid, publication);
          this.emit("trackPublished", publication.sid);
          try {
            if (typeof publication.setMuted === "function") {
              yield publication.setMuted(false);
            } else if (typeof track.setMuted === "function") {
              yield track.setMuted(false);
            }
          } catch (error) {
            this.emit("error", error, "track-unmute");
          }
          const args = [
            "-i",
            "pipe:0",
            // Read from stdin
            "-f",
            "s16le",
            // 16-bit little-endian PCM
            "-ar",
            sampleRate.toString(),
            // Sample rate
            "-ac",
            channels.toString(),
            // Number of channels
            "-"
            // Output to stdout
          ];
          const ffmpeg = (0, import_node_child_process.spawn)("ffmpeg", args);
          ffmpeg.stdin.on("error", (error) => {
          });
          audioStream.pipe(ffmpeg.stdin);
          audioStream.on("error", (error) => {
            this.emit("audioError", "stream", "streaming", error);
          });
          audioStream.on("close", () => {
            console.warn("\u26A0\uFE0F Audio stream closed unexpectedly");
            if (this.isStreaming) {
            }
          });
          audioStream.on("end", () => {
            if (this.isStreaming) {
              this.isStreaming = false;
              ffmpeg.kill();
            }
          });
          const chunkDurationMs = 100;
          const samplesPerChunk = Math.floor(sampleRate * chunkDurationMs / 1e3) * channels;
          const bytesPerChunk = samplesPerChunk * 2;
          let buffer = Buffer.alloc(0);
          let chunkCount = 0;
          ffmpeg.stdout.on("data", (chunk) => __async(this, null, function* () {
            var _a;
            try {
              if (!this.isStreaming || this.shouldStop) return;
              buffer = Buffer.concat([buffer, chunk]);
              chunkCount++;
              while (buffer.length >= bytesPerChunk && this.isStreaming && !this.shouldStop) {
                const audioChunk = buffer.slice(0, bytesPerChunk);
                buffer = buffer.slice(bytesPerChunk);
                const alignedBuffer = Buffer.from(audioChunk);
                const originalPcmData = new Int16Array(
                  alignedBuffer.buffer,
                  alignedBuffer.byteOffset,
                  alignedBuffer.byteLength / 2
                );
                const volumeAdjustedPcmData = this.applyVolume(originalPcmData);
                const frame = new import_rtc_node.AudioFrame(
                  volumeAdjustedPcmData,
                  sampleRate,
                  channels,
                  volumeAdjustedPcmData.length
                );
                try {
                  yield source2.captureFrame(frame);
                } catch (frameError) {
                  console.error("Error processing audio chunk:", frameError);
                  if (!this.isStreaming || this.shouldStop) {
                    return;
                  }
                  if (frameError instanceof Error && ((_a = frameError.message) == null ? void 0 : _a.includes("InvalidState"))) {
                    continue;
                  }
                }
              }
            } catch (error) {
            }
          }));
          ffmpeg.on("close", (code) => {
            this.isStreaming = false;
            if (code !== 0 && code !== null) {
              const error = new Error(`FFmpeg exited with code ${code}`);
              this.emit("audioError", "stream", "streaming", error);
            }
          });
          this.once("disconnected", () => {
            this.isStreaming = false;
            ffmpeg.kill();
          });
          return new Promise((resolve, reject) => {
            ffmpeg.on("close", (code) => {
              this.emit("debug", "FFmpeg streaming ended", {
                code,
                source: source2,
                type
              });
              if (source2 && type) {
                this.emit("debug", "Emitting audioEnd for streaming", {
                  source: source2,
                  type
                });
                this.emit("audioEnd", source2, type);
              } else {
                this.emit("debug", "No source/type for streaming audioEnd", {
                  source: source2,
                  type
                });
              }
              if (code === 0 || code === null) {
                resolve();
              } else {
                console.warn(
                  `\u26A0\uFE0F FFmpeg exited with code ${code} - this may be normal for streaming`
                );
                resolve();
              }
            });
          });
        } else {
          throw new Error("Failed to publish audio track");
        }
      } catch (error) {
        console.error(
          `\u274C [${this.channelId}] Failed to set up streaming:`,
          error
        );
        throw error;
      }
    });
  }
  /**
   * Play audio from a finite stream (for regular audio files)
   * @private
   */
  playFromStream(stream, source, type) {
    return __async(this, null, function* () {
      this.shouldStop = false;
      this.isStreaming = false;
      const pcmData = yield this.convertAudioToPCM(stream, 48e3, 1);
      this.emit("debug", "PCM conversion completed", { source, type });
      yield this.publishPCMAudio(pcmData);
      this.emit("debug", "Audio publishing completed", { source, type });
      if (source && type) {
        this.emit("debug", "Emitting audioEnd event", { source, type });
        this.emit("audioEnd", source, type);
      } else {
        this.emit("debug", "No source/type provided, skipping audioEnd", {
          source,
          type
        });
      }
    });
  }
  /**
  * Convert audio to PCM format using FFmpeg
  * @private
  */
  convertAudioToPCM(input, sampleRate = 48e3, channels = 1) {
    return __async(this, null, function* () {
      const sourceDesc = typeof input === "string" ? input : "stream";
      this.emit("conversionStart", sourceDesc, sampleRate, channels);
      this.emit("debug", "Starting FFmpeg audio conversion", {
        source: sourceDesc,
        sampleRate,
        channels
      });
      return new Promise((resolve, reject) => {
        const args = [];
        if (typeof input === "string") {
          args.push("-i", input);
        } else {
          args.push("-i", "pipe:0");
        }
        args.push(
          "-f",
          "s16le",
          // 16-bit little-endian PCM
          "-ar",
          sampleRate.toString(),
          // Sample rate
          "-ac",
          channels.toString(),
          // Number of channels
          "-"
          // Output to stdout
        );
        const ffmpeg = (0, import_node_child_process.spawn)("ffmpeg", args);
        const chunks = [];
        let errorOutput = "";
        ffmpeg.stdout.on("data", (chunk) => {
          chunks.push(chunk);
        });
        ffmpeg.stderr.on("data", (data) => {
          errorOutput += data.toString();
        });
        ffmpeg.on("close", (code) => {
          if (code === 0) {
            const pcmBuffer = Buffer.concat(chunks);
            const int16Array = new Int16Array(
              pcmBuffer.buffer,
              pcmBuffer.byteOffset,
              pcmBuffer.length / 2
            );
            this.emit("conversionEnd", sourceDesc, int16Array.length);
            this.emit("debug", "FFmpeg conversion completed", {
              pcmDataSize: int16Array.length,
              bufferSize: pcmBuffer.length
            });
            resolve(int16Array);
          } else {
            const error = new Error(
              `FFmpeg failed with code ${code}: ${errorOutput}`
            );
            this.emit("conversionError", sourceDesc, error);
            console.error(error);
          }
        });
        ffmpeg.on("error", (err) => {
          const error = new Error(`FFmpeg spawn error: ${err.message}`);
          this.emit("conversionError", sourceDesc, error);
          console.error(error);
        });
        if (typeof input === "string") {
          ffmpeg.stdin.end();
        } else {
          input.pipe(ffmpeg.stdin);
          input.on("end", () => {
            ffmpeg.stdin.end();
          });
          input.on("error", (err) => {
            ffmpeg.kill("SIGTERM");
            console.error(err);
          });
        }
      });
    });
  }
  /**
   * Publish PCM audio to the voice channel
   */
  publishPCMAudio(pcmData) {
    return __async(this, null, function* () {
      if (!this.room) {
        throw new Error(
          `Not connected to voice channel ${this.channelId}. Call connect() first.`
        );
      }
      const volumeAdjustedPCM = this.applyVolume(pcmData);
      return new Promise((resolve, reject) => {
        const processAudio = () => __async(this, null, function* () {
          try {
            const source = new import_rtc_node.AudioSource(48e3, 1);
            const sourceId = `file_${Date.now()}`;
            this.audioSources.set(sourceId, source);
            const track = import_rtc_node.LocalAudioTrack.createAudioTrack("audio", source);
            const options = new import_rtc_node.TrackPublishOptions();
            options.source = import_rtc_node.TrackSource.SOURCE_MICROPHONE;
            if (!this.room.localParticipant) {
              throw new Error("Room local participant not available");
            }
            const publication = yield this.room.localParticipant.publishTrack(
              track,
              options
            );
            if (publication) {
              this.publications.set(publication.sid, publication);
              this.emit("trackPublished", publication.sid);
              this.emit("debug", "Audio track published successfully", {
                trackId: publication.sid,
                publicationCount: this.publications.size
              });
              try {
                if (typeof publication.setMuted === "function") {
                  yield publication.setMuted(false);
                } else if (typeof track.setMuted === "function") {
                  yield track.setMuted(false);
                }
                if (typeof track.setEnabled === "function") {
                  yield track.setEnabled(true);
                }
              } catch (error) {
                this.emit("error", error, "track-unmute");
              }
              const chunkDurationMs = 100;
              const samplesPerChunk = Math.floor(48e3 * chunkDurationMs / 1e3) * 1;
              let offset = 0;
              let chunksSent = 0;
              while (offset < volumeAdjustedPCM.length && !this.shouldStop) {
                const chunkEnd = Math.min(
                  offset + samplesPerChunk,
                  volumeAdjustedPCM.length
                );
                const chunk = volumeAdjustedPCM.slice(offset, chunkEnd);
                const frame = new import_rtc_node.AudioFrame(
                  chunk,
                  48e3,
                  // sampleRate
                  1,
                  // channels (mono)
                  chunk.length
                  // total samples in chunk
                );
                try {
                  yield source.captureFrame(frame);
                  chunksSent++;
                } catch (error) {
                  this.emit("error", error, "frame-capture");
                }
                offset = chunkEnd;
                yield new Promise(
                  (resolve2) => setTimeout(resolve2, chunkDurationMs)
                );
              }
              if (this.shouldStop) {
                this.emit("debug", "Audio playback stopped by user", {
                  channelId: this.channelId,
                  chunksSent
                });
              } else {
                this.emit("debug", "Audio playback completed successfully", {
                  channelId: this.channelId,
                  chunksSent,
                  totalSamples: volumeAdjustedPCM.length
                });
              }
              this.emit("debug", "publishPCMAudio resolving");
              resolve();
            } else {
              console.error(new Error("Failed to publish audio track"));
            }
          } catch (error) {
            console.error(
              `\u274C [${this.channelId}] Failed to publish audio:`,
              error
            );
            console.error(error);
          }
        });
        processAudio();
      });
    });
  }
  /**
   * Play audio from a file
   * @private
   */
  playFromFile(filePath) {
    return __async(this, null, function* () {
      if (!this.connected) {
        yield this.connect();
      }
      this.shouldStop = false;
      this.isStreaming = false;
      this.emit("audioStart", filePath, "file");
      this.emit("debug", "Starting file playback", { filePath });
      try {
        const pcmData = yield this.convertAudioToPCM(filePath, 48e3, 1);
        yield this.publishPCMAudio(pcmData);
        this.emit("audioEnd", filePath, "file");
        this.emit("debug", "File playback completed", { filePath });
      } catch (error) {
        const errorObj = error instanceof Error ? error : new Error(String(error));
        this.emit("audioError", filePath, "file", errorObj);
        this.emit("error", errorObj, "file-playback");
        console.error(`\u274C [${this.channelId}] File playback failed:`, error);
        throw error;
      }
    });
  }
  /**
   * Stop current audio playback
   */
  stop(trackName) {
    return __async(this, null, function* () {
      var _a, _b;
      this.shouldStop = true;
      this.isStreaming = false;
      if (!this.room) {
        return;
      }
      if (trackName) {
        const publication = this.publications.get(trackName);
        if (publication) {
          try {
            yield (_a = this.room.localParticipant) == null ? void 0 : _a.unpublishTrack(publication.sid);
            this.publications.delete(trackName);
            this.emit("trackStopped", trackName);
          } catch (error) {
            console.error(
              `\u274C [${this.channelId}] Failed to stop track ${trackName}:`,
              error
            );
          }
        }
      } else {
        for (const [sid, publication] of this.publications) {
          try {
            yield (_b = this.room.localParticipant) == null ? void 0 : _b.unpublishTrack(publication.sid);
            this.emit("trackStopped", sid);
          } catch (error) {
            console.error(
              `\u274C [${this.channelId}] Failed to stop track ${sid}:`,
              error
            );
          }
        }
        this.publications.clear();
      }
    });
  }
  /**
   * Disconnect from the voice channel
   */
  disconnect() {
    return __async(this, null, function* () {
      if (!this.room) {
        return;
      }
      try {
        yield this.stop();
        this.audioSources.clear();
        yield this.room.disconnect();
        this.isConnected = false;
        this.publications.clear();
        this.room = void 0;
        this.emit("disconnected", this.channelId, this.serverId, "manual");
        this.emit("debug", "Disconnected manually");
      } catch (error) {
        console.error(`\u274C [${this.channelId}] Error during disconnect:`, error);
        this.isConnected = false;
        this.publications.clear();
        this.audioSources.clear();
        this.room = void 0;
        throw error;
      }
    });
  }
  /**
   * Handle unexpected disconnection
   * @private
   */
  handleDisconnected() {
    return __async(this, null, function* () {
      this.audioSources.clear();
      this.isConnected = false;
      this.publications.clear();
      this.room = void 0;
      this.emit("disconnected", this.channelId, this.serverId, "unexpected");
      this.emit("debug", "Voice disconnected unexpectedly");
    });
  }
  /**
   * Get player status information
   */
  getStatus() {
    return {
      connected: this.connected,
      volume: this._volume,
      activeTracksCount: this.publications.size,
      channelId: this.channelId,
      serverId: this.serverId
    };
  }
};

// src/client/voiceClient.ts
var VoiceClient = class {
  constructor(client3) {
    this.client = client3;
    this.players = /* @__PURE__ */ new Map();
  }
  /**
   * Creates a new AudioPlayer instance for the specified voice channel.
   *
   * @param channelId - The ID of the voice channel to connect to
   * @param serverId - The ID of the server containing the voice channel
   * @returns A new AudioPlayer instance that the user can manage
   *
   * @example
   * ```typescript
   * // Create a player for a specific voice channel
   * const player = client.voice.createPlayer('voice-channel-id', 'server-id');
   *
   * // Set up event listeners
   * player.on('connected', () => {
   *   console.log('Connected to voice channel!');
   * });
   *
   * player.on('audioStart', (source, type) => {
   *   console.log(`Started playing ${type}: ${source}`);
   * });
   *
   * // Connect and play audio
   * await player.connect();
   * await player.playFromFile('./music.mp3');
   *
   * // The user is responsible for managing the player lifecycle
   * await player.disconnect();
   * ```
   */
  createPlayer(channelId, serverId) {
    return new AudioPlayer(channelId, serverId, this.client);
  }
  /**
   * Creates a new AudioPlayer instance and immediately connects it to the voice channel.
   * This is a convenience method that combines createPlayer() and connect().
   *
   * @param channelId - The ID of the voice channel to connect to
   * @param serverId - The ID of the server containing the voice channel
   * @returns A new connected AudioPlayer instance
   *
   * @example
   * ```typescript
   * // Create and connect in one step
   * const player = await client.voice.connectToChannel('voice-channel-id', 'server-id');
   *
   * // Player is already connected and ready to use
   * await player.playFromUrl('https://example.com/music.mp3');
   * ```
   */
  connectToChannel(channelId, serverId) {
    return __async(this, null, function* () {
      var _a;
      const player = (_a = this.players.get(serverId)) != null ? _a : this.createPlayer(channelId, serverId);
      this.players.set(serverId, player);
      yield player.connect(channelId);
      return player;
    });
  }
  /**
   * Disconnects the AudioPlayer from the specified server.
   *
   * @param serverId - The ID of the server to disconnect from
   */
  disconnectFromChannel(serverId) {
    return __async(this, null, function* () {
      const player = this.players.get(serverId);
      if (player) {
        yield player.disconnect();
        this.players.delete(serverId);
      }
    });
  }
  /**
   * Stops the AudioPlayer in the specified server.
   *
   * @param serverId - The ID of the server whose player should be stopped
   */
  stopPlayerInChannel(serverId) {
    return __async(this, null, function* () {
      const player = this.players.get(serverId);
      if (player) {
        yield player.stop();
      }
    });
  }
};

// src/struct/clientUser.ts
var ClientUser = class extends User {
  constructor(client3, data) {
    var _a;
    super(client3, data);
    /** The notes channel associated with the client user, if any. */
    this.notes = null;
    this.owner = null;
    this._patch(data);
    this.owner = ((_a = data.bot) == null ? void 0 : _a.owner) || null;
  }
  /**
   * Updates the username of the client user.
   *
   * @param {string} username - The new username to set.
   * @param {string} [password] - The current password of the user (required for non-bot accounts).
   * @returns {Promise<void>} A promise that resolves when the username has been successfully updated.
   * @throws {Error} Throws an error if the client user is a bot and a password is provided.
   *
   * @example
   * ```typescript
   * await clientUser.setUsername("NewUsername", "CurrentPassword");
   * ```
   */
  setUsername(username, password) {
    return __async(this, null, function* () {
      if (this.bot && password) {
        throw new Error("Bots do not have passwords");
      }
      yield this.client.api.patch("/users/@me/username", {
        body: { username, password }
      });
    });
  }
  setStatus(text, presence) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      if (typeof text === "string" && text in Status && !presence) {
        presence = text;
        text = void 0;
      }
      const status = {
        text: text != null ? text : (_a = this.client.user) == null ? void 0 : _a.presence.text,
        presence: presence != null ? presence : (_b = this.client.user) == null ? void 0 : _b.presence.status
      };
      yield this.client.api.patch(`/users/${(_c = this.client.user) == null ? void 0 : _c.id}`, {
        body: { status }
      });
    });
  }
};

// src/client/webSocket.ts
var WebSocketClient = class {
  /**
   * Creates a new WebSocketClient instance.
   *
   * @param {client} client - The client instance.
   */
  constructor(client3) {
    this.client = client3;
    /** Whether the last pong acknowledgment was received. */
    this.lastPongAck = false;
    /** Whether the WebSocket client is connected. */
    this.connected = false;
    /** A promise representing the reconnecting process, or `null` if not reconnecting. */
    this.reconnecting = null;
    /** Whether the WebSocket client is ready. */
    this.ready = false;
    /** The number of reconnection attempts made. */
    this.retryCount = 0;
  }
  /**
   * Logs a debug message.
   *
   * @param {unknown} message - The message to log.
   * @private
   */
  debug(message) {
    this.client.debug(`[WS] ${message}`);
  }
  /**
   * Sends data through the WebSocket connection.
   *
   * @param {unknown} data - The data to send.
   * @returns {Promise<void>} A promise that resolves when the data is sent.
   * @throws {Error} Throws an error if the WebSocket is not open.
   */
  send(data) {
    return __async(this, null, function* () {
      var _a;
      if (this.reconnecting) {
        this.debug("Reconnecting, waiting to send message.");
        yield this.reconnecting;
      }
      if (((_a = this.socket) == null ? void 0 : _a.readyState) === WebSocket.OPEN) {
        this.socket.send(JSON.stringify(data));
      } else {
        this.debug("Socket is not open, cannot send message.");
        throw new Error("Socket is not open");
      }
    });
  }
  /**
   * Handles the WebSocket connection opening.
   *
   * @private
   */
  onOpen() {
    if (!this.client.token) throw new Error("Token is required");
    this.send({
      type: "Authenticate" /* AUTHENTICATE */,
      token: this.client.token
    });
  }
  /**
   * Gets the current ping (latency) of the WebSocket connection.
   *
   * @returns {number} The ping in milliseconds, or `-0` if the WebSocket is not connected.
   */
  get ping() {
    if (!this.socket) return -0;
    return Date.now() - this.lastPingTimestamp;
  }
  /**
   * Sets the heartbeat interval for the WebSocket connection.
   *
   * @param {number} time - The interval time in milliseconds. Use `-1` to clear the interval.
   */
  setHeartbeatTimer(time) {
    this.debug(`Setting a heartbeat interval for ${time}ms.`);
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
    }
    if (time !== -1) {
      this.heartbeatInterval = setInterval(() => this.sendHeartbeat(), time);
    }
  }
  /**
   * Sends a heartbeat to the server to keep the connection alive.
   */
  sendHeartbeat() {
    var _a;
    this.debug("Sending heartbeat.");
    if (!this.lastPongAck) {
      this.debug("Did not receive a pong ack.");
      if ((_a = this.client.options.ws) == null ? void 0 : _a.reconnect) {
        this.reconnecting = this.destroy().then(() => this.connect()).then(() => this.reconnecting = null);
      }
    }
    const now = Date.now();
    this.send({ type: "Ping" /* PING */, data: now });
    this.lastPongAck = false;
    this.lastPingTimestamp = now;
  }
  /**
   * Handles WebSocket errors.
   *
   * @param {unknown} event - The error event.
   * @private
   */
  onError(event) {
    this.client.emit("error" /* ERROR */, event);
  }
  /**
   * Handles incoming WebSocket messages.
   *
   * @param {{ data: unknown }} param0 - The message event containing the data.
   * @private
   */
  onMessage({ data }) {
    let packet;
    try {
      packet = JSON.parse(String(data));
    } catch (err) {
      this.client.emit("error" /* ERROR */, err);
      return;
    }
    this.client.emit("raw" /* RAW */, packet);
    this.onPacket(packet).catch((e) => this.client.emit("error" /* ERROR */, e));
  }
  /**
   * Handles the WebSocket connection closing.
   *
   * @param {{ code: number; reason: string }} event - The close event containing the code and reason.
   * @private
   */
  onClose(event) {
    this.debug(`Closed with reason: ${event.reason}, code: ${event.code}`);
    this.destroy();
  }
  /**
   * Handles incoming WebSocket packets.
   *
   * @param {any} packet - The packet data.
   * @private
   */
  onPacket(packet) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e;
      if (!packet) {
        this.debug(`Received broken packet: '${packet}'.`);
        return;
      }
      switch (packet.type) {
        case "Bulk" /* BULK */:
          yield Promise.all(packet.v.map((p) => this.onPacket(p)));
          break;
        case "Authenticated" /* AUTHENTICATED */:
          this.connected = true;
          this.retryCount = 0;
          this.debug(`Successfully authenticated.`);
          break;
        case "Pong" /* PONG */:
          this.debug(`Received a heartbeat.`);
          this.lastPongAck = true;
          break;
        case "Error" /* ERROR */:
          this.client.emit("error" /* ERROR */, packet.error);
          break;
        case "Ready" /* READY */: {
          this.lastPongAck = true;
          const promises = [];
          for (const user of packet.users) {
            if (user.relationship === "User" && !this.client.user) {
              this.client.user = new ClientUser(this.client, user);
            } else {
              this.client.users._add(user);
            }
          }
          for (const member of packet.members) {
            (_a = this.client.servers.cache.get(member._id.server)) == null ? void 0 : _a.members._add(member);
          }
          for (const emoji of packet.emojis) {
            (_b = this.client.servers.cache.get(emoji.parent.id)) == null ? void 0 : _b.emojis.set(emoji._id, __spreadProps(__spreadValues({}, emoji), { _id: emoji._id }));
          }
          for (const channel of packet.channels) {
            this.client.channels._add(channel);
          }
          for (const server of packet.servers) {
            const s = this.client.servers._add(server);
            if (this.client.options.fetchMembers) {
              promises.push(s.members.fetch());
            }
          }
          this.setHeartbeatTimer(
            (_d = (_c = this.client.options.ws) == null ? void 0 : _c.heartbeatInterval) != null ? _d : 3e4
          );
          yield Promise.all(promises);
          for (const voice_state of packet.voice_states) {
            const channel = this.client.channels.cache.get(voice_state.id);
            for (const participant of voice_state.participants) {
              (_e = channel == null ? void 0 : channel.voice) == null ? void 0 : _e.set(participant.id, participant);
            }
          }
          this.ready = true;
          this.client.emit("ready" /* READY */, this.client);
          break;
        }
        default: {
          const action = this.client.events.get(packet.type);
          if (action) {
            yield action.handle(packet);
          } else {
            this.debug(`Received unknown packet "${packet.type}"`);
          }
          break;
        }
      }
    });
  }
  /**
   * Connects to the WebSocket server.
   *
   * @returns {Promise<this>} A promise that resolves when the connection is established.
   */
  connect() {
    this.retryCount = this.retryCount + 1;
    if (this.retryCount > 10) {
      this.debug("Max retry attempts reached");
      return Promise.reject(
        new Error(
          "Max retry attempts reached on WS connection, try again later."
        )
      );
    }
    return new Promise((resolve) => __async(this, null, function* () {
      var _a, _b, _c, _d;
      if (((_a = this.socket) == null ? void 0 : _a.readyState) === WebSocket.OPEN && this.ready) {
        return resolve(this);
      }
      if (typeof this.client.options === "undefined") {
        throw new Error("MISSING_CONFIGURATION_SYNC");
      }
      if (typeof this.client.token !== "string") {
        throw new Error("INVALID_TOKEN");
      }
      yield this.client.init();
      if (!((_b = this.client.options.ws) == null ? void 0 : _b.instanceURL))
        return Promise.reject(new Error("WebSocket instance URL not set."));
      const ws = this.socket = (_d = this.socket) != null ? _d : new WebSocket((_c = this.client.options.ws) == null ? void 0 : _c.instanceURL);
      ws.onopen = this.onOpen.bind(this);
      ws.onmessage = this.onMessage.bind(this);
      ws.onerror = this.onError.bind(this);
      ws.onclose = this.onClose.bind(this);
      ws.addEventListener("open", () => resolve(this));
    }));
  }
  /**
   * Destroys the WebSocket connection and clears its state.
   *
   * @returns {Promise<void>} A promise that resolves when the connection is destroyed.
   */
  destroy(isUserInitiated) {
    return new Promise((resolve) => {
      var _a;
      this.setHeartbeatTimer(-1);
      this.connected = false;
      this.ready = false;
      if (((_a = this.socket) == null ? void 0 : _a.readyState) === WebSocket.OPEN) {
        this.socket.addEventListener("close", () => {
          this.socket = null;
          if (!isUserInitiated) {
            setTimeout(() => this.connect(), 1e3);
          }
          resolve();
        });
        this.socket.close();
        if (!isUserInitiated) {
          setTimeout(() => this.connect(), 1e3);
        }
      } else {
        this.socket = null;
        if (!isUserInitiated) {
          setTimeout(() => this.connect(), 1e3);
        }
        resolve();
      }
    });
  }
};

// src/client/client.ts
var client2 = class extends BaseClient {
  constructor() {
    super(...arguments);
    /** The WebSocket client used for real-time communication. */
    this.ws = new WebSocketClient(this);
    /** Manages the channels in the client. */
    this.channels = new ChannelManager(this);
    /** Manages the servers in the client. */
    this.servers = new ServerManager(this);
    /** Manages the users in the client. */
    this.users = new UserManager(this);
    /** Manages the events in the client. */
    this.events = new EventManager(this);
    /** Manages the webhooks in the client. */
    this.webhooks = new WebhookManager(this);
    /** Manages the voice connections in the client. */
    this.voice = new VoiceClient(this);
    /** The authenticated user, or `null` if not logged in. */
    this.user = null;
    /** The timestamp when the client became ready, or `null` if not ready. */
    this.readyAt = null;
  }
  /**
   * Initializes the client.
   * @private
   */
  init() {
    return __async(this, null, function* () {
      this.debug("Initializing client...");
      if (process.env.NODE_ENV === "DEV") {
        console.info(
          "Development mode enabled: displaying additional debug info."
        );
      }
      yield this.api.getConfig();
    });
  }
  /**
   * Gets the timestamp when the client became ready.
   *
   * @returns {number | null} The ready timestamp in milliseconds, or `null` if not ready.
   */
  get readyTimestamp() {
    return this.readyAt ? this.readyAt.getTime() : null;
  }
  /**
   * Gets the uptime of the client in milliseconds.
   *
   * @returns {number | null} The uptime in milliseconds, or `null` if the client is not ready.
   */
  get upTime() {
    return this.readyAt ? Date.now() - this.readyAt.getTime() : null;
  }
  /**
   * Logs the client into the API using the provided token.
   *
   * @param {string} token - The authentication token.
   * @returns {Promise<void>} A promise that resolves when the client is logged in.
   * @throws {Error} Throws an error if the token is not provided or if the WebSocket connection fails.
   *
   * @example
   * ```typescript
   * await client.login("your-token-here");
   * ```
   */
  login(token) {
    return __async(this, null, function* () {
      if (!token) throw new Error("Token is required");
      this.token = token;
      this.debug("Logging in...");
      try {
        yield this.ws.connect();
      } catch (error) {
        this.debug(`Error connecting to WebSocket: ${error}`);
        throw error;
      }
      this.readyAt = /* @__PURE__ */ new Date();
    });
  }
  /**
   * Destroys the client, disconnecting it from the API and clearing its state.
   *
   * @returns {Promise<void>} A promise that resolves when the client is destroyed.
   *
   * @example
   * ```typescript
   * await client.destroy();
   * ```
   */
  destroy() {
    return __async(this, null, function* () {
      this.token = null;
      this.user = null;
      this.readyAt = null;
      yield this.ws.destroy(true);
    });
  }
  /**
   * Checks if the client is ready.
   *
   * @returns {boolean} `true` if the client is ready, otherwise `false`.
   *
   * @example
   * ```typescript
   * if (client.isReady()) {
   *   console.log("Client is ready!");
   * }
   * ```
   */
  isReady() {
    return this.readyAt !== null;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Attachment,
  AudioPlayer,
  Badges,
  Base,
  BaseManager,
  BitField,
  Category,
  Channel,
  ChannelManager,
  ChannelPermissions,
  ChannelTypes,
  DEFAULT_CLIENT_OPTIONS,
  DEFAULT_PERMISSION_DM,
  DMChannel,
  Emoji,
  Events,
  FullPermissions,
  GroupChannel,
  Invite,
  Mentions,
  MessageEmbed,
  MessageManager,
  MessageStruct,
  NotesChannel,
  Presence,
  Role,
  RoleManager,
  SYSTEM_USER_ID,
  Server,
  ServerChannel,
  ServerChannelManager,
  ServerManager,
  ServerMember,
  ServerMemberManager,
  ServerPermissions,
  Status,
  TextChannel,
  UUID,
  User,
  UserManager,
  UserPermissions,
  VoiceChannel,
  WSEvents,
  apiUrl,
  client
});
//# sourceMappingURL=index.js.map