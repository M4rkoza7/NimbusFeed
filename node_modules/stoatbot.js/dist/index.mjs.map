{"version":3,"sources":["../src/managers/baseManager.ts","../src/utils/bitField.ts","../src/struct/base.ts","../src/utils/UUID.ts","../src/utils/constants.ts","../src/utils/permissions.ts","../src/utils/badges.ts","../src/struct/user.ts","../src/struct/message.ts","../src/struct/attachment.ts","../src/struct/presence.ts","../src/struct/server.ts","../src/struct/role.ts","../src/struct/channel.ts","../src/struct/dmChannel.ts","../src/struct/groupChannel.ts","../src/struct/invite.ts","../src/struct/mentions.ts","../src/struct/messageEmbed.ts","../src/struct/notesChannel.ts","../src/struct/serverChannel.ts","../src/struct/serverMember.ts","../src/struct/textChannel.ts","../src/struct/voiceChannels.ts","../src/struct/category.ts","../src/struct/emoji.ts","../src/managers/channelManager.ts","../src/managers/serverManager.ts","../src/managers/userManager.ts","../src/managers/messageManager.ts","../src/managers/roleManager.ts","../src/managers/serverChannelManager.ts","../src/managers/serverMemberManager.ts","../src/managers/webhookManager.ts","../src/client/baseClient.ts","../src/rest/restClient.ts","../package.json","../src/rest/restUtils/rateLimitQueue.ts","../src/rest/CDNClient.ts","../src/client/events/event.ts","../src/client/events/bulkMessageDelete.ts","../src/client/events/channelCreate.ts","../src/client/events/channelDelete.ts","../src/client/events/channelGroupJoin.ts","../src/client/events/channelGroupLeave.ts","../src/client/events/channelStarttyping.ts","../src/client/events/channelStopTyping.ts","../src/client/events/channelUpdate.ts","../src/client/events/message.ts","../src/client/events/messageDelete.ts","../src/client/events/messageUpdate.ts","../src/client/events/serverCreate.ts","../src/client/events/serverDelete.ts","../src/client/events/serverMemberJoin.ts","../src/client/events/serverMemberLeave.ts","../src/client/events/serverMemberUpdate.ts","../src/client/events/serverRoleDelete.ts","../src/client/events/serverRoleUpdate.ts","../src/client/events/serverupdate.ts","../src/client/events/userUpdate.ts","../src/client/events/messageReact.ts","../src/client/events/messageUnreact.ts","../src/client/events/webhookCreate.ts","../src/client/events/webhookDelete.ts","../src/client/events/webhookUpdate.ts","../src/client/events/userVoiceStateUpdate.ts","../src/client/events/voiceChannelJoin.ts","../src/client/events/voiceChannelLeave.ts","../src/client/events/index.ts","../src/client/events/eventManager.ts","../src/client/player.ts","../src/client/voiceClient.ts","../src/struct/clientUser.ts","../src/client/webSocket.ts","../src/client/client.ts"],"sourcesContent":["import type { client } from \"../client/client\";\r\n\r\nexport abstract class BaseManager<Holds extends { id: string }, R = unknown> {\r\n  /** Shared default max size for all managers (can be changed globally). */\r\n  static defaultMaxSize = -1;\r\n\r\n  /** Insertion ordered cache of items this manager holds. */\r\n  readonly cache = new Map<string, Holds>();\r\n\r\n  /** Instance level max size (can be changed per manager instance). */\r\n  protected maxSize: number;\r\n\r\n  /** @private */\r\n  Holds: any;\r\n\r\n  constructor(\r\n    protected readonly client: client,\r\n    maxSize = BaseManager.defaultMaxSize,\r\n  ) {\r\n    this.maxSize = maxSize;\r\n  }\r\n\r\n  /**\r\n   * Adds a raw object to the cache, constructing the holdable class.\r\n   * Automatically evicts oldest entries if the max size is exceeded.\r\n   * @private\r\n   */\r\n  _add(raw: R): Holds {\r\n    if (!this.holds) throw new Error(\"Holds is not defined\");\r\n    const obj = new this.holds(this.client, raw);\r\n    this.cache.set(obj.id, obj);\r\n    this.enforceMaxSize();\r\n    return obj;\r\n  }\r\n\r\n  /** Remove an entry by id.\r\n   * @private\r\n   */\r\n  _remove(id: string): void {\r\n    this.cache.delete(id);\r\n  }\r\n\r\n  /** Adjust the maximum size for this manager at runtime. */\r\n  setMaxSize(size: number): void {\r\n    if (!Number.isFinite(size) || size < -1)\r\n      throw new RangeError(\"maxSize must be a non-negative finite number\");\r\n    this.maxSize = size;\r\n    this.enforceMaxSize();\r\n  }\r\n\r\n  /** Force eviction until cache size is within the limit. */\r\n  protected enforceMaxSize(): void {\r\n    if (this.maxSize === -1) return;\r\n    if (this.maxSize === 0) {\r\n      // Special case: caching disabled.\r\n      this.cache.clear();\r\n      return;\r\n    }\r\n    while (this.cache.size > this.maxSize) {\r\n      const oldestKey = this.cache.keys().next().value as string | undefined;\r\n      if (oldestKey === undefined) break;\r\n      this.cache.delete(oldestKey);\r\n    }\r\n  }\r\n\r\n  abstract readonly holds: (new (...args: any[]) => Holds) | null;\r\n\r\n  resolve(resolvable: Holds): Holds | null;\r\n  resolve(resolvable: string | R): Holds | null;\r\n  resolve(resolvable: string | R | Holds): Holds | null;\r\n  resolve(resolvable: string | R | Holds): Holds | null {\r\n    const id = this.resolveId(resolvable);\r\n    if (id) return this.cache.get(id) ?? null;\r\n    return null;\r\n  }\r\n\r\n  resolveId(resolvable: string | Holds | R): string | null {\r\n    if (resolvable == null) return null;\r\n    if (typeof resolvable === \"string\") return resolvable;\r\n    if (this.holds && resolvable instanceof this.holds) return resolvable.id;\r\n    const raw = resolvable as unknown as { _id: string };\r\n    if (typeof raw === \"object\" && \"_id\" in raw) raw._id ?? null;\r\n    return null;\r\n  }\r\n\r\n  valueOf(): this[\"cache\"] {\r\n    return this.cache;\r\n  }\r\n}\r\n","const DEFAULT_BIT = 0;\r\n\r\n/** A type that can be a BitField, number, string, or an array of these types.\r\n * @private\r\n */\r\nexport type BitFieldResolvable =\r\n  | BitField\r\n  | number\r\n  | string\r\n  | BitFieldResolvable[];\r\n\r\n/**\r\n * Represents a bitfield that can be used to manage flags or permissions.\r\n */\r\nexport class BitField {\r\n  static FLAGS: Record<string, number> = {};\r\n  bitfield = DEFAULT_BIT;\r\n  constructor(bits: BitFieldResolvable = DEFAULT_BIT) {\r\n    this.bitfield = this.self.resolve(bits);\r\n  }\r\n\r\n  /**\r\n   * Resolves a bitfield or an array of bitfields into a single number.\r\n   * @param bit The bitfield or array of bitfields to resolve.\r\n   * @returns The resolved bitfield as a number.\r\n   */\r\n  static resolve(bit: BitFieldResolvable): number {\r\n    if (bit instanceof BitField) return bit.bitfield;\r\n    if (typeof bit === \"number\" && bit >= DEFAULT_BIT) return bit;\r\n    if (Array.isArray(bit)) {\r\n      return bit\r\n        .map((p) => this.resolve(p))\r\n        .reduce((prev, p) => prev | p, DEFAULT_BIT);\r\n    }\r\n    if (typeof this.FLAGS[bit] !== \"undefined\") return this.FLAGS[bit];\r\n    throw new Error(\"BITFIELD_INVALID\");\r\n  }\r\n  /**\r\n   * Returns the class that this instance belongs to.\r\n   * @returns The class of the bitfield.\r\n   */\r\n  get self(): {\r\n    FLAGS: Record<string, number>;\r\n    resolve(bit: BitFieldResolvable): number;\r\n    new (bits?: BitFieldResolvable): BitField;\r\n  } {\r\n    return this.constructor as unknown as {\r\n      FLAGS: Record<string, number>;\r\n      resolve(bit: BitFieldResolvable): number;\r\n      new (bits?: BitFieldResolvable): BitField;\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Checks if any of the bits in the bitfield are set.\r\n   * @param bit The bitfield or array of bitfields to check.\r\n   * @returns True if any bits are set, false otherwise.\r\n   */\r\n  any(bit: BitFieldResolvable): boolean {\r\n    bit = this.self.resolve(bit);\r\n    return (this.bitfield & bit) !== DEFAULT_BIT;\r\n  }\r\n\r\n  /**\r\n   * checks if a specific permission is set.\r\n   */\r\n  has(bit: BitFieldResolvable): boolean {\r\n    bit = this.self.resolve(bit);\r\n    return (this.bitfield & bit) === bit;\r\n  }\r\n\r\n  /**\r\n   * Returns an array of all the Permissions that are set in the bitfield.\r\n   * @returns An array of flag names.\r\n   */\r\n  toArray(): string[] {\r\n    return Object.keys(this.self.FLAGS).filter((bit) => this.has(bit));\r\n  }\r\n\r\n  add(...bits: BitFieldResolvable[]): this {\r\n    let total = 0;\r\n\r\n    for (const bit of bits) {\r\n      total |= this.self.resolve(bit);\r\n    }\r\n\r\n    if (Object.isFrozen(this)) {\r\n      return new this.self(this.bitfield | total) as this;\r\n    }\r\n\r\n    this.bitfield |= total;\r\n\r\n    return this;\r\n  }\r\n\r\n  remove(...bits: BitFieldResolvable[]): this {\r\n    let total = 0;\r\n\r\n    for (const bit of bits) {\r\n      total |= this.self.resolve(bit);\r\n    }\r\n\r\n    if (Object.isFrozen(this)) {\r\n      return new this.self(this.bitfield & ~total) as this;\r\n    }\r\n\r\n    this.bitfield &= ~total;\r\n\r\n    return this;\r\n  }\r\n\r\n  freeze(): Readonly<this> {\r\n    return Object.freeze(this);\r\n  }\r\n\r\n  valueOf(): number {\r\n    return this.bitfield;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @returns A record of all flags and their boolean values indicating whether they are set.\r\n   */\r\n  serialize(): Record<string, boolean> {\r\n    const serialized: Record<string, boolean> = {};\r\n    for (const [flag, bit] of Object.entries(this.self.FLAGS)) {\r\n      serialized[flag] = this.has(bit);\r\n    }\r\n    return serialized;\r\n  }\r\n\r\n  *[Symbol.iterator](): Iterable<string> {\r\n    yield* this.toArray();\r\n  }\r\n}\r\n","import { client } from \"../client/client\";\r\nimport { BitField } from \"../utils/bitField\";\r\n\r\nexport type PartialObject = Partial<\r\n  { _id: string } | { id: string } | { _id: { user: string } }\r\n>;\r\n\r\n/**\r\n * Represents the base structure for all objects in the client.\r\n * Provides common functionality such as equality checks, cloning, and patching data.\r\n */\r\nexport abstract class Base {\r\n  /** The unique identifier for the object. */\r\n  id!: string;\r\n\r\n  /**\r\n   * Creates a new Base instance.\r\n   *\r\n   * @param {client} client - The client instance.\r\n   */\r\n  constructor(public readonly client: client) {}\r\n\r\n  /**\r\n   * Compares this object with another to determine if they are equal.\r\n   *\r\n   * @param {this | null} [obj] - The object to compare with.\r\n   * @returns {boolean} `true` if the objects are equal, otherwise `false`.\r\n   */\r\n  equals(obj?: this | null): boolean {\r\n    if (!obj) return false;\r\n\r\n    for (const key in obj) {\r\n      const a = obj[key],\r\n        b = this[key];\r\n      if (a instanceof Base && !a.equals(b as typeof a)) return false;\r\n      if (\r\n        a instanceof BitField &&\r\n        a.bitfield !== (b as unknown as BitField).bitfield\r\n      )\r\n        return false;\r\n\r\n      if (typeof a === \"object\" && a !== null) continue;\r\n      if (a !== b) return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Updates the object with new data and returns a clone of the object.\r\n   *\r\n   * @param {PartialObject} data - The data to update the object with.\r\n   * @param {string[]} [clear] - Fields to clear in the object.\r\n   * @returns {this} A clone of the updated object.\r\n   */\r\n  _update(data: PartialObject, clear?: string[]): this {\r\n    const clone = this._clone();\r\n    this._patch(data, clear);\r\n    return clone;\r\n  }\r\n\r\n  /**\r\n   * Patches the object with new data.\r\n   *\r\n   * @param {PartialObject} data - The data to patch the object with.\r\n   * @param {string[]} [_clear] - Fields to clear in the object.\r\n   * @returns {this} The updated object.\r\n   * @protected\r\n   */\r\n  protected _patch(data: PartialObject, _clear?: string[]): this {\r\n    if (\"id\" in data) this.id = data.id!;\r\n    if (\"_id\" in data) {\r\n      if (typeof data._id === \"string\") this.id = data._id;\r\n      if (typeof data._id === \"object\") this.id = data._id.user;\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Creates a deep clone of the object.\r\n   *\r\n   * @returns {this} A clone of the object.\r\n   */\r\n  _clone(): this {\r\n    const clone = Object.assign(Object.create(this), this);\r\n\r\n    for (const key in clone) {\r\n      const prop = clone[key];\r\n      if (prop instanceof Base) clone[key] = prop._clone();\r\n    }\r\n\r\n    return clone;\r\n  }\r\n}\r\n","import { randomBytes } from \"crypto\";\r\n\r\nexport class UUID extends null {\r\n  static readonly ENCODING = \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\";\r\n  static readonly ENCODING_LENGTH = UUID.ENCODING.length;\r\n  static readonly RANDOM_LENGTH = 16;\r\n  static readonly TIME_LENGTH = 10;\r\n  static readonly TIME_MAX = Math.pow(2, 48) - 1;\r\n  static get PROG(): number {\r\n    return randomBytes(1).readUInt8() / 0xff;\r\n  }\r\n\r\n  private static time(now = Date.now()): string {\r\n    let mod: number,\r\n      result = \"\";\r\n\r\n    for (let i = this.TIME_LENGTH; i > 0; i--) {\r\n      mod = now % this.ENCODING_LENGTH;\r\n      result = this.ENCODING.charAt(mod) + result;\r\n      now = (now - mod) / this.ENCODING_LENGTH;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  private static hash(): string {\r\n    let result = \"\";\r\n\r\n    for (let i = this.RANDOM_LENGTH; i > 0; i--) {\r\n      let random = Math.floor(this.PROG * this.ENCODING_LENGTH);\r\n\r\n      if (random === this.ENCODING_LENGTH) {\r\n        random = this.ENCODING_LENGTH - 1;\r\n      }\r\n\r\n      result = this.ENCODING.charAt(random) + result;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  static generate(timestamp = Date.now()): string {\r\n    return this.time(timestamp) + this.hash();\r\n  }\r\n\r\n  static timestampOf(id: string): Date {\r\n    const timestamp = id\r\n      .slice(0, this.TIME_LENGTH)\r\n      .split(\"\")\r\n      .reverse()\r\n      .reduce((carry, char, index) => {\r\n        const encodingIndex = this.ENCODING.indexOf(char);\r\n\r\n        if (encodingIndex === -1) {\r\n          throw new Error(\"invalid character found: \" + char);\r\n        }\r\n\r\n        return (carry += encodingIndex * Math.pow(this.ENCODING_LENGTH, index));\r\n      }, 0);\r\n\r\n    return new Date(timestamp);\r\n  }\r\n}\r\n","import { clientOptions } from \"../client/baseClient\";\r\nimport { UUID } from \"./UUID\";\r\n\r\n/**\r\n * Enum representing the client events that can be emitted.\r\n * @private\r\n */\r\nexport enum Events {\r\n  CHANNEL_CREATE = \"channelCreate\",\r\n  CHANNEL_DELETE = \"channelDelete\",\r\n  CHANNEL_UPDATE = \"channelUpdate\",\r\n  DEBUG = \"debug\",\r\n  ERROR = \"error\",\r\n  GROUP_JOIN = \"groupJoin\",\r\n  GROUP_LEAVE = \"groupLeave\",\r\n  MESSAGE = \"message\",\r\n  MESSAGE_DELETE = \"messageDelete\",\r\n  MESSAGE_DELETE_BULK = \"messageDeleteBulk\",\r\n  MESSAGE_UPDATE = \"messageUpdate\",\r\n  MESSAGE_REACT = \"messageReact\",\r\n  MESSAGE_REACT_REMOVE = \"messageUnreact\",\r\n  RAW = \"raw\",\r\n  READY = \"ready\",\r\n  ROLE_CREATE = \"roleCreate\",\r\n  ROLE_DELETE = \"roleDelete\",\r\n  ROLE_UPDATE = \"roleUpdate\",\r\n  SERVER_CREATE = \"serverCreate\",\r\n  SERVER_DELETE = \"serverDelete\",\r\n  SERVER_MEMBER_JOIN = \"serverMemberJoin\",\r\n  SERVER_MEMBER_LEAVE = \"serverMemberLeave\",\r\n  SERVER_MEMBER_UPDATE = \"serverMemberUpdate\",\r\n  SERVER_UPDATE = \"serverUpdate\",\r\n  TYPING_START = \"typingStart\",\r\n  TYPING_STOP = \"typingStop\",\r\n  USER_UPDATE = \"userUpdate\",\r\n  WEBHOOKS_CREATE = \"webhookCreate\",\r\n  WEBHOOKS_DELETE = \"webhookDelete\",\r\n  WEBHOOKS_UPDATE = \"webhookUpdate\",\r\n  USER_VOICE_STATE_UPDATE = \"userVoiceStateUpdate\",\r\n  VOICE_CHANNEL_JOIN = \"voiceChannelJoin\",\r\n  VOICE_CHANNEL_LEAVE = \"voiceChannelLeave\",\r\n}\r\n\r\n/**\r\n * Enum representing the WebSocket events used for communication.\r\n * @private\r\n */\r\nexport enum WSEvents {\r\n  AUTHENTICATE = \"Authenticate\",\r\n  AUTHENTICATED = \"Authenticated\",\r\n  BEGIN_TYPING = \"BeginTyping\",\r\n  BULK = \"Bulk\",\r\n  CHANNEL_ACK = \"ChannelAck\",\r\n  CHANNEL_CREATE = \"ChannelCreate\",\r\n  CHANNEL_DELETE = \"ChannelDelete\",\r\n  CHANNEL_GROUP_JOIN = \"ChannelGroupJoin\",\r\n  CHANNEL_GROUP_LEAVE = \"ChannelGroupLeave\",\r\n  CHANNEL_START_TYPING = \"ChannelStartTyping\",\r\n  CHANNEL_STOP_TYPING = \"ChannelStopTyping\",\r\n  CHANNEL_UPDATE = \"ChannelUpdate\",\r\n  END_TYPING = \"EndTyping\",\r\n  ERROR = \"Error\",\r\n  MESSAGE = \"Message\",\r\n  MESSAGE_BULK_DELETE = \"BulkMessageDelete\",\r\n  MESSAGE_DELETE = \"MessageDelete\",\r\n  MESSAGE_UPDATE = \"MessageUpdate\",\r\n  PING = \"Ping\",\r\n  PONG = \"Pong\",\r\n  READY = \"Ready\",\r\n  SERVER_DELETE = \"ServerDelete\",\r\n  SERVER_MEMBER_JOIN = \"ServerMemberJoin\",\r\n  SERVER_MEMBER_LEAVE = \"ServerMemberLeave\",\r\n  SERVER_MEMBER_UPDATE = \"ServerMemberUpdate\",\r\n  SERVER_ROLE_DELETE = \"ServerRoleDelete\",\r\n  SERVER_ROLE_UPDATE = \"ServerRoleUpdate\",\r\n  SERVER_UPDATE = \"ServerUpdate\",\r\n  USER_RELATIONSHIP = \"UserRelationship\",\r\n  USER_UPDATE = \"UserUpdate\",\r\n  WEBHOOKS_CREATE = \"WebhooksCreate\",\r\n  WEBHOOKS_DELETE = \"WebhooksDelete\",\r\n  WEBHOOKS_UPDATE = \"WebhooksUpdate\",\r\n  VOICE_STATE_UPDATE = \"VoiceStateUpdate\",\r\n  VOICE_CHANNEL_JOIN = \"VoiceChannelJoin\",\r\n  VOICE_CHANNEL_LEAVE = \"VoiceChannelLeave\",\r\n}\r\n\r\n/**\r\n * Enum representing the types of channels supported by the client.\r\n */\r\nexport enum ChannelTypes {\r\n  DM = \"DM\",\r\n  GROUP = \"GROUP\",\r\n  TEXT = \"TEXT\",\r\n  VOICE = \"VOICE\",\r\n  NOTES = \"NOTES\",\r\n}\r\n\r\n/**\r\n * The default options for configuring the client.\r\n */\r\nexport const DEFAULT_CLIENT_OPTIONS: clientOptions = {\r\n  fetchMembers: true,\r\n  rest: {\r\n    timeout: 15000,\r\n    retries: 3,\r\n  },\r\n  MessageCache: {\r\n    maxSize: 1000,\r\n  },\r\n  ws: {\r\n    heartbeatInterval: 30000,\r\n    reconnect: true,\r\n  },\r\n};\r\n\r\n/** The base API URL for interacting with the Stoat API. */\r\nexport const apiUrl = \"https://api.stoat.chat\";\r\n\r\n/** The system user ID used for identifying system messages. */\r\nexport const SYSTEM_USER_ID = \"0\".repeat(UUID.TIME_LENGTH + UUID.RANDOM_LENGTH);\r\n","import { BitField } from \"./bitField\";\r\n\r\nexport type ChannelPermissionsString = keyof typeof ChannelPermissions.FLAGS;\r\nexport type UserPermissionsString = keyof typeof UserPermissions.FLAGS;\r\nexport type ServerPermissionsString = keyof typeof ServerPermissions.FLAGS;\r\nexport type ChannelPermissionsResolvable =\r\n  | number\r\n  | ChannelPermissionsString\r\n  | ChannelPermissions\r\n  | ChannelPermissionsResolvable[];\r\nexport type UserPermissionsResolvable =\r\n  | number\r\n  | UserPermissionsString\r\n  | UserPermissions\r\n  | UserPermissionsResolvable[];\r\nexport type ServerPermissionsResolvable =\r\n  | number\r\n  | ServerPermissionsString\r\n  | ServerPermissions\r\n  | ServerPermissionsResolvable[];\r\n\r\nexport declare interface ServerPermissions {\r\n  serialize(): Record<ServerPermissionsString, boolean>;\r\n  any(bit: ServerPermissionsResolvable): boolean;\r\n  add(...bits: ServerPermissionsResolvable[]): this;\r\n  remove(...bits: ServerPermissionsResolvable[]): this;\r\n  has(bit: ServerPermissionsResolvable): boolean;\r\n}\r\n\r\nexport declare interface ChannelPermissions {\r\n  serialize(): Record<ChannelPermissionsString, boolean>;\r\n  any(bit: ChannelPermissionsResolvable): boolean;\r\n  add(...bits: ChannelPermissionsResolvable[]): this;\r\n  remove(...bits: ChannelPermissionsResolvable[]): this;\r\n  has(bit: ChannelPermissionsResolvable): boolean;\r\n}\r\n\r\nexport declare interface UserPermissions {\r\n  serialize(): Record<UserPermissionsString, boolean>;\r\n  any(bit: UserPermissionsResolvable): boolean;\r\n  add(...bits: UserPermissionsResolvable[]): this;\r\n  remove(...bits: UserPermissionsResolvable[]): this;\r\n  has(bit: UserPermissionsResolvable): boolean;\r\n}\r\n\r\nexport class ChannelPermissions extends BitField {\r\n  static readonly FLAGS = {\r\n    VIEW_CHANNEL: 1 ** 0,\r\n    SEND_MESSAGE: 1 ** 22,\r\n    MANAGE_MESSAGE: 1 ** 2,\r\n    MANAGE_CHANNEL: 1 ** 3,\r\n    VOICE_CALL: 1 ** 4,\r\n    INVITE_OTHERS: 1 ** 5,\r\n    EMBED_LINKS: 1 ** 6,\r\n    UPLOAD_FILES: 1 ** 7,\r\n  } as const;\r\n\r\n  constructor(bits?: ChannelPermissionsResolvable) {\r\n    super(bits);\r\n  }\r\n\r\n  static resolve(bit: ChannelPermissionsResolvable): number {\r\n    return super.resolve(bit);\r\n  }\r\n}\r\n\r\nexport class UserPermissions extends BitField {\r\n  static readonly FLAGS = {\r\n    ACCESS: 1 ** 0,\r\n    VIEW_PROFILE: 1 ** 1,\r\n    SEND_MESSAGES: 1 ** 2,\r\n    INVITE: 1 ** 3,\r\n  } as const;\r\n\r\n  constructor(bits?: UserPermissionsResolvable) {\r\n    super(bits);\r\n  }\r\n\r\n  static resolve(bit: UserPermissionsResolvable): number {\r\n    return super.resolve(bit);\r\n  }\r\n}\r\n\r\nexport class ServerPermissions extends BitField {\r\n  static readonly FLAGS = {\r\n    VIEW_SERVER: 1 ** 0,\r\n    MANAGE_ROLES: 1 ** 1,\r\n    MANAGE_CHANNELS: 1 ** 2,\r\n    MANAGE_SERVER: 1 ** 3,\r\n    KICK_MEMBERS: 1 ** 4,\r\n    BAN_MEMBERS: 1 ** 5,\r\n    CHANGE_NICKNAME: 1 ** 12,\r\n    MANAGE_NICKNAMES: 1 ** 13,\r\n    CHANGE_AVATAR: 1 ** 14,\r\n    REMOVE_AVATARS: 1 ** 15,\r\n  } as const;\r\n\r\n  constructor(bits?: ServerPermissionsResolvable) {\r\n    super(bits);\r\n  }\r\n\r\n  static resolve(bit: ServerPermissionsResolvable): number {\r\n    return super.resolve(bit);\r\n  }\r\n}\r\n\r\nexport class FullPermissions extends BitField {\r\n  static readonly FLAGS = {\r\n    // * Generic permissions\r\n    /// Manage the channel or channels on the server\r\n    ManageChannel: 2 ** 0,\r\n    /// Manage the server\r\n    ManageServer: 2 ** 1,\r\n    /// Manage permissions on servers or channels\r\n    ManagePermissions: 2 ** 2,\r\n    /// Manage roles on server\r\n    ManageRole: 2 ** 3,\r\n    /// Manage server customisation (includes emoji)\r\n    ManageCustomisation: 2 ** 4,\r\n\r\n    // * Member permissions\r\n    /// Kick other members below their ranking\r\n    KickMembers: 2 ** 6,\r\n    /// Ban other members below their ranking\r\n    BanMembers: 2 ** 7,\r\n    /// Timeout other members below their ranking\r\n    TimeoutMembers: 2 ** 8,\r\n    /// Assign roles to members below their ranking\r\n    AssignRoles: 2 ** 9,\r\n    /// Change own nickname\r\n    ChangeNickname: 2 ** 10,\r\n    /// Change or remove other's nicknames below their ranking\r\n    ManageNicknames: 2 ** 11,\r\n    /// Change own avatar\r\n    ChangeAvatar: 2 ** 12,\r\n    /// Remove other's avatars below their ranking\r\n    RemoveAvatars: 2 ** 13,\r\n\r\n    // * Channel permissions\r\n    /// View a channel\r\n    ViewChannel: 2 ** 20,\r\n    /// Read a channel's past message history\r\n    ReadMessageHistory: 2 ** 21,\r\n    /// Send a message in a channel\r\n    SendMessage: 2 ** 22,\r\n    /// Delete messages in a channel\r\n    ManageMessages: 2 ** 23,\r\n    /// Manage webhook entries on a channel\r\n    ManageWebhooks: 2 ** 24,\r\n    /// Create invites to this channel\r\n    InviteOthers: 2 ** 25,\r\n    /// Send embedded content in this channel\r\n    SendEmbeds: 2 ** 26,\r\n    /// Send attachments and media in this channel\r\n    UploadFiles: 2 ** 27,\r\n    /// Masquerade messages using custom nickname and avatar\r\n    Masquerade: 2 ** 28,\r\n    /// React to messages with emoji\r\n    React: 2 ** 29,\r\n\r\n    // * Voice permissions\r\n    /// Connect to a voice channel\r\n    Connect: 2 ** 30,\r\n    /// Speak in a voice call\r\n    Speak: 2 ** 31,\r\n    /// Share video in a voice call\r\n    Video: 2 ** 32,\r\n    /// Mute other members with lower ranking in a voice call\r\n    MuteMembers: 2 ** 33,\r\n    /// Deafen other members with lower ranking in a voice call\r\n    DeafenMembers: 2 ** 34,\r\n    /// Move members between voice channels\r\n    MoveMembers: 2 ** 35,\r\n\r\n    // * Mention permissions\r\n    /// Mention @everyone or @online\r\n    MentionEveryone: 2 ** 37,\r\n    /// Mention a role\r\n    MentionRoles: 2 ** 38,\r\n\r\n    // * Grant all permissions\r\n    /// Safely grant all permissions\r\n    GrantAll: 0x000f_ffff_ffff_ffff,\r\n  } as const;\r\n\r\n  constructor(\r\n    bits?:\r\n      | number\r\n      | string\r\n      | FullPermissions\r\n      | Array<number | string | FullPermissions>,\r\n  ) {\r\n    super(bits);\r\n  }\r\n\r\n  static resolve(bit: number | string | FullPermissions): number {\r\n    return super.resolve(bit);\r\n  }\r\n}\r\n\r\nexport const DEFAULT_PERMISSION_DM = new ChannelPermissions([\r\n  \"VIEW_CHANNEL\",\r\n  \"VIEW_CHANNEL\",\r\n  \"MANAGE_CHANNEL\",\r\n  \"VOICE_CALL\",\r\n  \"EMBED_LINKS\",\r\n  \"UPLOAD_FILES\",\r\n]).freeze();\r\n","import { BitField } from \"./bitField\";\r\n\r\nexport type BadgeString = keyof typeof Badges.FLAGS;\r\nexport type BadgesResolvable =\r\n  | number\r\n  | BadgeString\r\n  | Badges\r\n  | BadgesResolvable[];\r\n\r\nexport declare interface Badges {\r\n  serialize(): Record<BadgeString, boolean>;\r\n  any(bit: BadgesResolvable): boolean;\r\n  add(...bits: BadgesResolvable[]): this;\r\n  remove(...bits: BadgesResolvable[]): this;\r\n  has(bit: BadgesResolvable): boolean;\r\n}\r\n\r\nexport class Badges extends BitField {\r\n  static readonly FLAGS = {\r\n    DEVELOPER: 1 << 0,\r\n    TRANSLATOR: 1 << 1,\r\n    SUPPORTER: 1 << 2,\r\n    RESPONSIBLE_DISCLOSURE: 1 << 3,\r\n    REVOLT_TEAM: 1 << 4,\r\n    EARLY_ADOPTER: 1 << 8,\r\n  } as const;\r\n\r\n  constructor(bits?: BadgesResolvable) {\r\n    super(bits);\r\n  }\r\n\r\n  static resolve(bit: BadgesResolvable): number {\r\n    return super.resolve(bit);\r\n  }\r\n}\r\n","import { Attachment, Base, DMChannel, Presence, Status } from \"./index\";\r\nimport type {\r\n  User as APIUser,\r\n  FieldsUser,\r\n  Channel as APIChannel,\r\n} from \"revolt-api\";\r\nimport { client } from \"../client/client\";\r\nimport { Badges, UUID } from \"../utils/index\";\r\n\r\n/**\r\n * Represents a user in the client.\r\n *\r\n * @extends Base\r\n */\r\nexport class User extends Base {\r\n  /** The username of the user. */\r\n  username!: string;\r\n\r\n  /** The avatar of the user, or `null` if none is set. */\r\n  avatar: Attachment | null = null;\r\n\r\n  /** The presence status of the user. */\r\n  presence = new Presence(this.client);\r\n\r\n  /** The badges associated with the user. */\r\n  badges!: Badges;\r\n\r\n  /** Whether the user is a bot. */\r\n  bot = false;\r\n\r\n  /**\r\n   * Creates a new User instance.\r\n   *\r\n   * @param {client} client - The client instance.\r\n   * @param {APIUser} data - The raw data for the user from the API.\r\n   */\r\n  constructor(client: client, data: APIUser) {\r\n    super(client);\r\n    this._patch(data);\r\n  }\r\n\r\n  /**\r\n   * Updates the user instance with new data from the API.\r\n   *\r\n   * @param {APIUser} data - The raw data for the user from the API.\r\n   * @param {FieldsUser[]} [clear=[]] - Fields to clear in the user.\r\n   * @returns {this} The updated user instance.\r\n   * @protected\r\n   */\r\n  protected _patch(data: APIUser, clear: FieldsUser[] = []): this {\r\n    super._patch(data);\r\n\r\n    if (data.username) {\r\n      this.username = data.username;\r\n    }\r\n\r\n    if (data.bot) {\r\n      this.bot = true;\r\n    }\r\n\r\n    if (typeof data.badges === \"number\") {\r\n      this.badges = new Badges(data.badges).freeze();\r\n    }\r\n\r\n    if (data.avatar) {\r\n      this.avatar = new Attachment(this.client, data.avatar);\r\n    }\r\n\r\n    if (data.status) {\r\n      this.presence.status = data.status.presence\r\n        ? (Status[data.status.presence as keyof typeof Status] ??\r\n          Status.Invisible)\r\n        : Status.Invisible;\r\n      this.presence.text = data.status.text ?? null;\r\n    }\r\n\r\n    for (const field of clear) {\r\n      if (field === \"Avatar\") this.avatar = null;\r\n      if (field === \"StatusText\") this.presence.text = null;\r\n      if (field === \"StatusPresence\") this.presence.status = Status.Invisible;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Gets the creation date of the user.\r\n   *\r\n   * @returns {Date} The date when the user was created.\r\n   */\r\n  get createdAt(): Date {\r\n    return UUID.timestampOf(this.id);\r\n  }\r\n\r\n  /**\r\n   * checks if the user is the owner of the bot.\r\n   */\r\n  get isOwner(): boolean {\r\n    return this.id === this.client.user?.owner;\r\n  }\r\n\r\n  /**\r\n   * Gets the creation timestamp of the user in milliseconds.\r\n   *\r\n   * @returns {number} The timestamp of when the user was created.\r\n   */\r\n  get createdTimestamp(): number {\r\n    return this.createdAt.getTime();\r\n  }\r\n\r\n  /**\r\n   * Blocks the user.\r\n   *\r\n   * @returns {Promise<void>} A promise that resolves when the user is blocked.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * await user.block();\r\n   * ```\r\n   */\r\n  async block(): Promise<void> {\r\n    await this.client.api.put(`/users/${this.id}/block`);\r\n  }\r\n\r\n  /**\r\n   * Unblocks the user.\r\n   *\r\n   * @returns {Promise<void>} A promise that resolves when the user is unblocked.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * await user.unblock();\r\n   * ```\r\n   */\r\n  async unblock(): Promise<void> {\r\n    await this.client.api.delete(`/users/${this.id}/block`);\r\n  }\r\n\r\n  /**\r\n   * Creates a direct message (DM) channel with the user.\r\n   *\r\n   * @returns {Promise<DMChannel>} A promise that resolves with the created DM channel.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const dmChannel = await user.createDM();\r\n   * ```\r\n   */\r\n  async createDM(): Promise<DMChannel> {\r\n    const data = await this.client.api.get(`/users/${this.id}/dm`);\r\n    return this.client.channels._add(data as APIChannel) as DMChannel;\r\n  }\r\n\r\n  avatarURL(): string | undefined {\r\n    if (!this.avatar?.id) return undefined;\r\n    return `${this.client.options.rest?.instanceCDNURL}/avatars/${this.avatar?.id}`;\r\n  }\r\n\r\n   async displayAvatarURL(): Promise<string> {\r\n    const defaultAvatar = `${this.client.options.rest?.instanceCDNURL}/users/${this.id}/default_avatar`;\r\n    return this.avatarURL() ?? defaultAvatar;\r\n  }\r\n\r\n  /**\r\n   * Fetches the latest data for the user from the API.\r\n   *\r\n   * @param {boolean} [force=false] - Whether to force a fetch even if the user is cached.\r\n   * @returns {Promise<User>} A promise that resolves with the updated user instance.\r\n   */\r\n  fetch(force: boolean = false): Promise<User> {\r\n    return this.client.users.fetch(this, { force });\r\n  }\r\n\r\n  /**\r\n   * Converts the user to a string representation.\r\n   *\r\n   * @returns {string} A string representation of the user in the format `<@userId>`.\r\n   */\r\n  toString(): string {\r\n    return `<@${this.id}>`;\r\n  }\r\n}\r\n","import type {\r\n  File,\r\n  Message as APIMessage,\r\n  SystemMessage,\r\n  Masquerade,\r\n} from \"revolt-api\";\r\nimport type { client } from \"../client/client\";\r\nimport type { MessageEditOptions, MessageOptions } from \"../managers/index\";\r\nimport {\r\n  Base,\r\n  DMChannel,\r\n  Embed,\r\n  GroupChannel,\r\n  Mentions,\r\n  Server,\r\n  ServerMember,\r\n  TextChannel,\r\n  User,\r\n  VoiceChannel,\r\n} from \"./index\";\r\nimport { ChannelTypes, UUID } from \"../utils/index\";\r\n\r\n/**\r\n * Represents a message in a channel.\r\n *\r\n * @extends Base\r\n */\r\nexport class MessageStruct extends Base {\r\n  /** The type of the message (e.g., TEXT, SYSTEM). */\r\n  type: Uppercase<SystemMessage[\"type\"]> = \"TEXT\";\r\n\r\n  /** The content of the message. */\r\n  content = \"\";\r\n\r\n  /** The ID of the channel where the message was sent. */\r\n  channelId = \"\";\r\n\r\n  /** The ID of the user who authored the message. */\r\n  authorId = \"\";\r\n\r\n  /** An array of embeds included in the message. */\r\n  embeds: Embed[] = [];\r\n\r\n  /** An array of file attachments included in the message. */\r\n  attachments: File[] = [];\r\n\r\n  /** Mentions included in the message. */\r\n  mentions = new Mentions(this, []);\r\n\r\n  /** The timestamp of when the message was last edited, or `null` if not edited. */\r\n  editedTimestamp: number | null = null;\r\n\r\n  /** the reactions and count on a message */\r\n  reactions: Map<string, string[]> = new Map();\r\n\r\n  /** Masquerade information for the message, Name and / or avatar override information */\r\n  masquerade?: Masquerade;\r\n\r\n  /** Webhook information for the message, Name and / or avatar override information */\r\n  webhook?: { name: string; avatar: string | null };\r\n\r\n  /**\r\n   * Creates a new Message instance.\r\n   *\r\n   * @param {client} client - The client instance.\r\n   * @param {APIMessage} data - The raw data for the message from the API.\r\n   */\r\n  constructor(client: client, data: APIMessage) {\r\n    super(client);\r\n    this._patch(data);\r\n  }\r\n\r\n  /**\r\n   * Updates the message instance with new data from the API.\r\n   *\r\n   * @param {APIMessage} data - The raw data for the message from the API.\r\n   * @returns {this} The updated message instance.\r\n   * @protected\r\n   */\r\n  protected _patch(data: APIMessage): this {\r\n    super._patch(data);\r\n\r\n    if (Array.isArray(data.embeds)) {\r\n      this.embeds = data.embeds;\r\n    }\r\n\r\n    if (Array.isArray(data.attachments)) {\r\n      this.attachments = data.attachments;\r\n    }\r\n\r\n    if (Array.isArray(data.mentions)) {\r\n      this.mentions = new Mentions(this, data.mentions);\r\n    }\r\n\r\n    if (data.author) {\r\n      this.authorId = data.author;\r\n    }\r\n\r\n    if (data.channel) {\r\n      this.channelId = data.channel;\r\n    }\r\n\r\n    if (data.webhook) {\r\n      this.webhook = {\r\n        name: data.webhook.name,\r\n        avatar: data.webhook.avatar ?? null,\r\n      };\r\n    }\r\n\r\n    if (typeof data.content === \"string\") {\r\n      this.content = data.content;\r\n    }\r\n\r\n    if (data.system) {\r\n      this.type = data.system.type.toUpperCase() as Uppercase<\r\n        SystemMessage[\"type\"]\r\n      >;\r\n    }\r\n\r\n    if (data.edited) {\r\n      this.editedTimestamp = Date.parse(data.edited);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Gets the creation date of the message.\r\n   *\r\n   * @returns {Date} The date when the message was created.\r\n   */\r\n  get createdAt(): Date {\r\n    return UUID.timestampOf(this.id);\r\n  }\r\n\r\n  /**\r\n   * Gets the creation timestamp of the message in milliseconds.\r\n   *\r\n   * @returns {number} The timestamp of when the message was created.\r\n   */\r\n  get createdTimestamp(): number {\r\n    return this.createdAt.getTime();\r\n  }\r\n\r\n  /**\r\n   * Gets the date when the message was last edited.\r\n   *\r\n   * @returns {Date | null} The date of the last edit, or `null` if not edited.\r\n   */\r\n  get editedAt(): Date | null {\r\n    return this.editedTimestamp ? new Date(this.editedTimestamp) : null;\r\n  }\r\n\r\n  /**\r\n   * Checks if the message is a system message.\r\n   *\r\n   * @returns {boolean} `true` if the message is a system message, otherwise `false`.\r\n   */\r\n  get system(): boolean {\r\n    return this.type !== \"TEXT\";\r\n  }\r\n\r\n  /**\r\n   * Retrieves the author of the message.\r\n   *\r\n   * @returns {User | ServerMember | null} The user who authored the message, or `null` if not found.\r\n   */\r\n  get author():\r\n    | User\r\n    | ServerMember\r\n    | Partial<User & { isWebhook: boolean }>\r\n    | null {\r\n    if (this.webhook) {\r\n      return {\r\n        bot: true,\r\n        username: this.webhook.name,\r\n        isWebhook: true,\r\n      } as Partial<User & { isWebhook: boolean }>;\r\n    }\r\n    if (this.inServer()) {\r\n      return (\r\n        this.server?.members.cache.get(this.authorId) ??\r\n        this.client.users.cache.get(this.authorId) ??\r\n        null\r\n      );\r\n    }\r\n    return this.client.users.cache.get(this.authorId) ?? null;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the channel where the message was sent.\r\n   *\r\n   * @returns {TextChannel | DMChannel | GroupChannel | VoiceChannel} The channel instance.\r\n   */\r\n  get channel(): TextChannel | DMChannel | GroupChannel | VoiceChannel {\r\n    const channel = this.client.channels.cache.get(this.channelId);\r\n\r\n    switch (channel?.type) {\r\n      case ChannelTypes.TEXT:\r\n        return channel as TextChannel;\r\n      case ChannelTypes.DM:\r\n        return channel as DMChannel;\r\n      case ChannelTypes.GROUP:\r\n        return channel as GroupChannel;\r\n      case ChannelTypes.VOICE:\r\n        return channel as VoiceChannel;\r\n      default:\r\n        return channel as TextChannel;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieves the server ID associated with the message, if any.\r\n   *\r\n   * @returns {string | null} The server ID, or `null` if the message is not in a server.\r\n   */\r\n  get serverId(): string | null {\r\n    const channel = this.channel;\r\n    return channel.inServer() ? channel.serverId : null;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the server associated with the message, if any.\r\n   *\r\n   * @returns {Server | null} The server instance, or `null` if not found.\r\n   */\r\n  get server(): Server | null {\r\n    return this.client.servers.cache.get(this.serverId as string) ?? null;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the server member who authored the message, if any.\r\n   *\r\n   * @returns {ServerMember | null} The server member instance, or `null` if not found.\r\n   */\r\n  get member(): ServerMember | null {\r\n    return this.server?.members.cache.get(this.authorId) ?? null;\r\n  }\r\n\r\n  /**\r\n   * Gets the URL of the message.\r\n   *\r\n   * @returns {string} The URL of the message.\r\n   */\r\n  get url(): string {\r\n    return `https://app.stoat.chat/${\r\n      this.serverId ? `server/${this.serverId}` : \"\"\r\n    }/channel/${this.channelId}/${this.id}`;\r\n  }\r\n\r\n  /**\r\n   * Acknowledges the message.\r\n   *\r\n   * @returns {Promise<void>} A promise that resolves when the message is acknowledged.\r\n   */\r\n  ack(): Promise<void> {\r\n    return this.channel.messages.ack(this);\r\n  }\r\n\r\n  /**\r\n   * Deletes the message.\r\n   *\r\n   * @returns {Promise<void>} A promise that resolves when the message is deleted.\r\n   */\r\n  delete(): Promise<void> {\r\n    return this.channel.messages.delete(this);\r\n  }\r\n\r\n  /**\r\n   * Replies to the message.\r\n   *\r\n   * @param {string} content - The content of the reply.\r\n   * @param {boolean} [mention=true] - Whether to mention the original message author.\r\n   * @returns {Promise<Message>} A promise that resolves with the sent reply message.\r\n   */\r\n  reply(\r\n    content: MessageOptions | string,\r\n    mention: boolean = true,\r\n  ): Promise<MessageStruct> {\r\n    return this.channel.messages.send({\r\n      ...(typeof content === \"object\" ? content : { content }),\r\n      replies: [{ id: this.id, mention }],\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Edits the message.\r\n   *\r\n   * @param {MessageEditOptions | string} options - The new content or edit options.\r\n   * @returns {Promise<void>} A promise that resolves when the message is edited.\r\n   */\r\n  edit(options: MessageEditOptions | string): Promise<void> {\r\n    return this.channel.messages.edit(this, options);\r\n  }\r\n\r\n  /**\r\n   * Fetches the latest data for the message.\r\n   *\r\n   * @returns {Promise<Message>} A promise that resolves with the updated message instance.\r\n   */\r\n  fetch(): Promise<MessageStruct> {\r\n    return this.channel.messages.fetch(this.id);\r\n  }\r\n\r\n  /**\r\n   * Adds a reaction to the message.\r\n   *\r\n   * @param {string} emoji - The emoji to react with.\r\n   * @returns {Promise<void>} A promise that resolves when the reaction is added.\r\n   */\r\n  addReaction(emoji: string): Promise<void> {\r\n    return this.channel.messages.addReaction(this, emoji);\r\n  }\r\n\r\n  /**\r\n   * Removes a reaction from the message.\r\n   *\r\n   * @param {string} emoji - The emoji to remove the reaction for.\r\n   * @param {object} [options] - Options for removing the reaction.\r\n   * @param {string} [options.user_id] - The user ID to remove the reaction for. If not provided, removes the reaction for the current user.\r\n   * @param {boolean} [options.remove_all=false] - Whether to remove all of the specified reaction for the message.\r\n   * @returns {Promise<void>} A promise that resolves when the reaction is removed.\r\n   */\r\n  removeReaction(\r\n    emoji: string,\r\n    options?: { user_id?: string; remove_all?: boolean },\r\n  ): Promise<void> {\r\n    return this.channel.messages.removeReaction(\r\n      this,\r\n      emoji,\r\n      options?.user_id ?? undefined,\r\n      options?.remove_all ?? false,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Removes all reactions from the message.\r\n   *\r\n   * @returns {Promise<void>} A promise that resolves when all reactions are removed.\r\n   */\r\n  removeAllReactions(): Promise<void> {\r\n    return this.channel.messages.removeAllReactions(this);\r\n  }\r\n\r\n  /**\r\n   * Checks if the message is in a server.\r\n   *\r\n   * @returns {boolean} `true` if the message is in a server, otherwise `false`.\r\n   */\r\n  inServer(): this is this & {\r\n    serverId: string;\r\n    server: Server;\r\n    channel: TextChannel;\r\n  } {\r\n    return this.channel.inServer();\r\n  }\r\n\r\n  /**\r\n   * Converts the message to a string representation.\r\n   *\r\n   * @returns {string} The content of the message.\r\n   */\r\n  toString(): string {\r\n    return this.content;\r\n  }\r\n}\r\n","import { Base } from \"./base\";\r\nimport type { File } from \"revolt-api\";\r\nimport type { client } from \"../client/client\";\r\n\r\n/**\r\n * Represents an attachment, such as a file or image, in a message or channel.\r\n *\r\n * @extends Base\r\n */\r\nexport class Attachment extends Base {\r\n  /** The filename of the attachment. */\r\n  filename!: string;\r\n\r\n  /** The MIME type of the attachment (e.g., `image/png`, `application/pdf`). */\r\n  type!: string;\r\n\r\n  /** The size of the attachment in bytes. */\r\n  size!: number;\r\n\r\n  /** Metadata associated with the attachment (e.g., dimensions for images). */\r\n  metadata!: File[\"metadata\"];\r\n\r\n  /**\r\n   * Creates a new Attachment instance.\r\n   *\r\n   * @param {client} client - The client instance.\r\n   * @param {File} data - The raw data for the attachment from the API.\r\n   */\r\n  constructor(client: client, data: File) {\r\n    super(client);\r\n    this._patch(data);\r\n  }\r\n\r\n  /**\r\n   * Updates the attachment instance with new data from the API.\r\n   *\r\n   * @param {File} data - The raw data for the attachment from the API.\r\n   * @returns {this} The updated attachment instance.\r\n   * @protected\r\n   */\r\n  protected _patch(data: File): this {\r\n    super._patch(data);\r\n    if (data.filename) this.filename = data.filename;\r\n    if (data.content_type) this.type = data.content_type;\r\n    if (typeof data.size === \"number\") this.size = data.size;\r\n    if (data.metadata) this.metadata = data.metadata;\r\n    return this;\r\n  }\r\n}\r\n","import { Base } from \"./base\";\r\n\r\n/**\r\n * Enum representing the possible presence statuses of a user.\r\n */\r\nexport enum Status {\r\n  Online = \"Online\",\r\n  Idle = \"Idle\",\r\n  Focus = \"Focus\",\r\n  Busy = \"Busy\",\r\n  Invisible = \"Invisible\",\r\n}\r\n\r\n/**\r\n * Represents the presence of a user, including their status and custom text.\r\n *\r\n * @extends Base\r\n */\r\nexport class Presence extends Base {\r\n  /** The custom status text of the user, or `null` if none is set. */\r\n  text: string | null = null;\r\n\r\n  /** The current status of the user (e.g., Online, Idle, Busy, Invisible). */\r\n  status = Status.Invisible;\r\n}\r\n","import type { Server as APIServer, FieldsServer } from \"revolt-api\";\r\nimport { Attachment, Base, Category, Emoji, ServerMember, User } from \"./index\";\r\nimport { client } from \"../client/client\";\r\nimport {\r\n  RoleManager,\r\n  ServerChannelManager,\r\n  ServerMemberManager,\r\n} from \"../managers/index\";\r\nimport { FullPermissions, UUID } from \"../utils/index\";\r\n\r\n/**\r\n * Represents a server (guild) in the client.\r\n *\r\n * @extends Base\r\n */\r\nexport class Server extends Base {\r\n  /** The name of the server. */\r\n  name!: string;\r\n\r\n  /** The description of the server, or `null` if none is set. */\r\n  description: string | null = null;\r\n\r\n  /** The ID of the user who owns the server. */\r\n  ownerId!: string;\r\n\r\n  /** Manages the members of the server. */\r\n  members = new ServerMemberManager(this);\r\n\r\n  /** Manages the channels of the server. */\r\n  channels = new ServerChannelManager(this);\r\n\r\n  /** Manages the roles of the server. */\r\n  roles = new RoleManager(this);\r\n\r\n  /** The icon of the server, or `null` if none is set. */\r\n  icon: Attachment | null = null;\r\n\r\n  /** The banner of the server, or `null` if none is set. */\r\n  banner: Attachment | null = null;\r\n\r\n  /** Whether analytics are enabled for the server. */\r\n  analytics = false;\r\n\r\n  /** Whether the server is discoverable. */\r\n  discoverable = false;\r\n\r\n  /** Whether the server is marked as NSFW (Not Safe For Work). */\r\n  nsfw = false;\r\n\r\n  /** The default permissions for the server. */\r\n  permissions!: FullPermissions;\r\n\r\n  /** The categories in the server. */\r\n  categories = new Map<string, Category>();\r\n\r\n  /** the emojies associated with the server */\r\n  emojis = new Map<string, Emoji>();\r\n\r\n  /**\r\n   * Creates a new Server instance.\r\n   *\r\n   * @param {client} client - The client instance.\r\n   * @param {APIServer} data - The raw data for the server from the API.\r\n   */\r\n  constructor(client: client, data: APIServer) {\r\n    super(client);\r\n    this._patch(data);\r\n  }\r\n\r\n  /**\r\n   * Updates the server instance with new data from the API.\r\n   *\r\n   * @param {APIServer} data - The raw data for the server from the API.\r\n   * @param {FieldsServer[]} [clear=[]] - Fields to clear in the server.\r\n   * @returns {this} The updated server instance.\r\n   * @protected\r\n   */\r\n  protected _patch(data: APIServer, clear: FieldsServer[] = []): this {\r\n    super._patch(data);\r\n\r\n    if (Array.isArray(data.categories)) {\r\n      this.categories.clear();\r\n      for (const cat of data.categories) {\r\n        const category = new Category(this, cat);\r\n        this.categories.set(category.id, category);\r\n      }\r\n    }\r\n\r\n    if (data.icon) {\r\n      this.icon = new Attachment(this.client, data.icon);\r\n    }\r\n\r\n    if (data.banner) {\r\n      this.banner = new Attachment(this.client, data.banner);\r\n    }\r\n\r\n    if (data.owner) {\r\n      this.ownerId = data.owner;\r\n    }\r\n\r\n    if (data.name) {\r\n      this.name = data.name;\r\n    }\r\n\r\n    if (\"description\" in data) {\r\n      this.description = data.description ?? null;\r\n    }\r\n\r\n    if (Array.isArray(data.channels)) {\r\n      for (const id of data.channels) {\r\n        const channel = this.client.channels.cache.get(id);\r\n        if (channel?.inServer()) this.channels.cache.set(channel.id, channel);\r\n      }\r\n    }\r\n\r\n    if (typeof data.roles === \"object\") {\r\n      for (const [id, raw] of Object.entries(data.roles)) {\r\n        this.roles._add(Object.assign(raw, { id }));\r\n      }\r\n    }\r\n\r\n    if (typeof data.default_permissions === \"number\") {\r\n      this.permissions = new FullPermissions(data.default_permissions).freeze();\r\n    }\r\n\r\n    if (typeof data.analytics === \"boolean\") this.analytics = data.analytics;\r\n    if (typeof data.discoverable === \"boolean\") {\r\n      this.discoverable = data.discoverable;\r\n    }\r\n    if (typeof data.nsfw === \"boolean\") this.nsfw = data.nsfw;\r\n\r\n    for (const field of clear) {\r\n      if (field === \"Icon\") this.icon = null;\r\n      if (field === \"Description\") this.description = null;\r\n      if (field === \"Banner\") this.banner = null;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the current user's member instance in the server.\r\n   *\r\n   * @returns {ServerMember | null} The current user's member instance, or `null` if not found.\r\n   */\r\n  get me(): ServerMember | null {\r\n    return this.members.cache.get(this.client.user?.id as string) ?? null;\r\n  }\r\n\r\n  /**\r\n   * Gets the creation date of the server.\r\n   *\r\n   * @returns {Date} The date when the server was created.\r\n   */\r\n  get createdAt(): Date {\r\n    return UUID.timestampOf(this.id);\r\n  }\r\n\r\n  /**\r\n   * Gets the creation timestamp of the server in milliseconds.\r\n   *\r\n   * @returns {number} The timestamp of when the server was created.\r\n   */\r\n  get createdTimestamp(): number {\r\n    return this.createdAt.getTime();\r\n  }\r\n\r\n  /**\r\n   * Retrieves the owner of the server.\r\n   *\r\n   * @returns {User | null} The owner of the server, or `null` if not found.\r\n   */\r\n  get owner(): User | null {\r\n    return this.client.users.cache.get(this.ownerId) ?? null;\r\n  }\r\n\r\n  //   iconURL(options?: { size: number }): string | null {\r\n  //     return this.icon\r\n  //       ? this.client.api.cdn.icon(this.icon.id, options?.size)\r\n  //       : null;\r\n  //   }\r\n\r\n  //   bannerURL(options?: { size: number }): string | null {\r\n  //     return this.banner\r\n  //       ? this.client.api.cdn.banner(this.banner.id, options?.size)\r\n  //       : null;\r\n  //   }\r\n\r\n  /**\r\n   * Converts the server to a string representation.\r\n   *\r\n   * @returns {string} The name of the server.\r\n   */\r\n  toString(): string {\r\n    return this.name;\r\n  }\r\n}\r\n","import type { Role as APIRole, FieldsRole } from \"revolt-api\";\r\nimport { Base, Overwrite, Server } from \"./index\";\r\nimport { FullPermissions, UUID } from \"../utils/index\";\r\nimport { editableRole } from \"../utils/types\";\r\n\r\n/**\r\n * Represents a role in a server.\r\n *\r\n * @extends Base\r\n */\r\nexport class Role extends Base {\r\n  /** The name of the role. */\r\n  name!: string;\r\n\r\n  /** The color of the role, or `null` if no color is set. */\r\n  color: string | null = null;\r\n\r\n  /** Whether the role is displayed separately in the member list. */\r\n  hoist = false;\r\n\r\n  /** The rank of the role, used for ordering. */\r\n  rank!: number;\r\n\r\n  /** The permissions overwrite for the role. */\r\n  overwrite!: Overwrite;\r\n\r\n  /**\r\n   * Creates a new Role instance.\r\n   *\r\n   * @param {Server} server - The server this role belongs to.\r\n   * @param {APIRole & { id: string }} data - The raw data for the role from the API.\r\n   */\r\n  constructor(\r\n    public server: Server,\r\n    data: APIRole & { id: string },\r\n  ) {\r\n    super(server.client);\r\n    this._patch(data);\r\n  }\r\n\r\n  /**\r\n   * Updates the role instance with new data from the API.\r\n   *\r\n   * @param {APIRole & { _id?: string }} data - The raw data for the role from the API.\r\n   * @param {FieldsRole[]} [clear=[]] - Fields to clear in the role.\r\n   * @returns {this} The updated role instance.\r\n   * @protected\r\n   */\r\n  protected _patch(\r\n    data: APIRole & { _id?: string },\r\n    clear: FieldsRole[] = [],\r\n  ): this {\r\n    super._patch(data);\r\n\r\n    if (data.name) this.name = data.name;\r\n\r\n    if (typeof data.hoist === \"boolean\") this.hoist = data.hoist;\r\n\r\n    if (typeof data.rank === \"number\") this.rank = data.rank;\r\n\r\n    if (\"colour\" in data) this.color = data.colour ?? null;\r\n\r\n    if (data.permissions) {\r\n      const { a, d } = data.permissions;\r\n      this.overwrite = {\r\n        allow: new FullPermissions(a),\r\n        deny: new FullPermissions(d),\r\n      };\r\n    }\r\n\r\n    for (const field of clear) {\r\n      if (field === \"Colour\") this.color = null;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Gets the date when the role was created.\r\n   *\r\n   * @returns {Date} The creation date of the role.\r\n   */\r\n  get createdAt(): Date {\r\n    return UUID.timestampOf(this.id);\r\n  }\r\n\r\n  /**\r\n   * Gets the timestamp of when the role was created.\r\n   *\r\n   * @returns {number} The creation timestamp of the role in milliseconds.\r\n   */\r\n  get createdTimestamp(): number {\r\n    return this.createdAt.getTime();\r\n  }\r\n\r\n  /**\r\n   * Gets the permissions overwrite for the role.\r\n   *\r\n   * @returns {Overwrite} The permissions overwrite for the role.\r\n   */\r\n  get permissions(): Overwrite {\r\n    return this.overwrite;\r\n  }\r\n\r\n  /**\r\n   * Deletes the role from the server.\r\n   *\r\n   * @returns {Promise<void>} A promise that resolves when the role is deleted.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * await role.delete();\r\n   * console.log(\"Role deleted successfully.\");\r\n   * ```\r\n   */\r\n  delete(): Promise<void> {\r\n    return this.server.roles.delete(this);\r\n  }\r\n\r\n  edit(data: editableRole): Promise<Role> {\r\n    return this.server.roles.edit(this, data);\r\n  }\r\n\r\n  /**\r\n   * Converts the role to a string representation.\r\n   *\r\n   * @returns {string} A string representation of the role in the format `<@&roleId>`.\r\n   */\r\n  toString(): string {\r\n    return `<@&${this.id}>`;\r\n  }\r\n}\r\n","import { Base } from \"./base\";\r\nimport type {\r\n  DMChannel,\r\n  GroupChannel,\r\n  ServerChannel,\r\n  TextChannel,\r\n  VoiceChannel,\r\n  voiceParticipant,\r\n} from \"./index\";\r\nimport { ChannelTypes, UUID } from \"../utils/index\";\r\nimport { CreateChannelOptions } from \"../managers/serverChannelManager\";\r\nimport {\r\n  editablePermissions,\r\n  createWebhookResponse,\r\n  editWebhookOptions,\r\n} from \"../utils/types\";\r\nimport { FullPermissions } from \"../utils/permissions\";\r\nimport { MessageOptions } from \"../managers/messageManager\";\r\nimport { Message as APIMessage } from \"revolt-api\";\r\nimport { Readable } from \"stream\";\r\n\r\n/**\r\n * Represents a generic communication channel in the client.\r\n * This abstract class provides a base structure and common functionality\r\n * for all types of channels, such as text, voice, group, and server channels.\r\n *\r\n * @abstract\r\n * @extends Base\r\n *\r\n * @property {ChannelTypes | \"UNKNOWN\"} type - The type of the channel. Defaults to \"UNKNOWN\".\r\n * @property {number} createdTimestamp - The timestamp (in milliseconds) when the channel was created.\r\n * @property {Date} createdAt - The date and time when the channel was created.\r\n */\r\nexport abstract class Channel extends Base {\r\n  type: ChannelTypes | \"UNKNOWN\" = \"UNKNOWN\";\r\n  voice?: Map<string, voiceParticipant> = new Map();\r\n\r\n  /**\r\n   * Gets the timestamp (in milliseconds) when the channel was created.\r\n   *\r\n   * @returns {number} The timestamp of the channel's creation.\r\n   */\r\n  get createdTimestamp(): number {\r\n    return this.createdAt.getTime();\r\n  }\r\n\r\n  /**\r\n   * Gets the date and time when the channel was created.\r\n   *\r\n   * @returns {Date} The creation date of the channel.\r\n   */\r\n  get createdAt(): Date {\r\n    return UUID.timestampOf(this.id);\r\n  }\r\n\r\n  /**\r\n   * Deletes the current channel instance from the client's channel collection.\r\n   *\r\n   * This method interacts with the client's channel management system to remove\r\n   * the channel. Once deleted, the channel will no longer be accessible through\r\n   * the client.\r\n   *\r\n   * @returns {Promise<void>} A promise that resolves when the channel has been successfully deleted.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const channel = client.channels.get('1234567890');\r\n   * if (channel) {\r\n   *   await channel.delete();\r\n   *   console.log('Channel deleted successfully.');\r\n   * }\r\n   * ```\r\n   */\r\n  delete(): Promise<void> {\r\n    return this.client.channels.delete(this);\r\n  }\r\n\r\n  /**\r\n   * Checks if the channel is a text-based channel.\r\n   *\r\n   * @returns {boolean} True if the channel is a text-based channel, otherwise false.\r\n   */\r\n  isText(): this is TextChannel | GroupChannel | DMChannel {\r\n    return \"messages\" in this;\r\n  }\r\n\r\n  /**\r\n   * Checks if the channel is a voice channel.\r\n   *\r\n   * @returns {boolean} True if the channel is a voice channel, otherwise false.\r\n   */\r\n  isVoice(): this is VoiceChannel {\r\n    return this.type === ChannelTypes.VOICE;\r\n  }\r\n\r\n  /**\r\n   * Checks if the channel is a group channel.\r\n   *\r\n   * @returns {boolean} True if the channel is a group channel, otherwise false.\r\n   */\r\n  isGroup(): this is GroupChannel {\r\n    return this.type === ChannelTypes.GROUP;\r\n  }\r\n\r\n  /**\r\n   * Checks if the channel is part of a server.\r\n   *\r\n   * @returns {boolean} True if the channel is a server channel, otherwise false.\r\n   */\r\n  inServer(): this is ServerChannel {\r\n    return \"serverId\" in this;\r\n  }\r\n\r\n  /**\r\n   * Converts the channel to a string representation.\r\n   *\r\n   * @returns {string} A string representation of the channel in the format `<#channelId>`.\r\n   */\r\n  toString(): string {\r\n    return `<#${this.id}>`;\r\n  }\r\n\r\n  /**\r\n   * Fetches the latest data for the channel from the client's channel collection.\r\n   *\r\n   * @param {boolean} [force=true] - Whether to force a fetch even if the channel is cached.\r\n   * @returns {Promise<Channel>} A promise that resolves with the updated channel instance.\r\n   */\r\n  fetch(force = true): Promise<Channel> {\r\n    return this.client.channels.fetch(this, { force });\r\n  }\r\n\r\n  async edit(\r\n    data: Partial<CreateChannelOptions>,\r\n  ): Promise<{ channel_type: string; _id: string; user: string }> {\r\n    const id = this.id;\r\n    if (!id) {\r\n      throw new TypeError(\"INVALID_ID\");\r\n    }\r\n\r\n    const response = await this.client.api.patch(`/channels/${id}`, {\r\n      body: data,\r\n    });\r\n\r\n    return response as { channel_type: string; _id: string; user: string };\r\n  }\r\n\r\n  /**\r\n   * Sets role permissions for this channel.\r\n   *\r\n   * @param roleId - The ID of the role to set permissions for.\r\n   * @param allow - Array of permissions to allow for the role.\r\n   * @returns A promise that resolves when the permissions have been updated.\r\n   *\r\n   * @throws {TypeError} If the channel ID is invalid.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Allow specific permissions\r\n   * await channel.setRolePermissions(roleId, [\"ViewChannel\", \"SendMessage\"]);\r\n   * ```\r\n   */\r\n  async setRolePermissions(\r\n    roleId: string,\r\n    allow: editablePermissions[\"a\"],\r\n  ): Promise<void>;\r\n\r\n  /**\r\n   * Sets role permissions for this channel.\r\n   *\r\n   * @param roleId - The ID of the role to set permissions for.\r\n   * @param allow - Array of permissions to allow for the role.\r\n   * @param deny - Array of permissions to deny for the role.\r\n   * @returns A promise that resolves when the permissions have been updated.\r\n   *\r\n   * @throws {TypeError} If the channel ID is invalid.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Set both allow and deny permissions\r\n   * await channel.setRolePermissions(roleId, [\"ViewChannel\"], [\"ManageMessages\"]);\r\n   * ```\r\n   */\r\n  async setRolePermissions(\r\n    roleId: string,\r\n    allow: editablePermissions[\"a\"],\r\n    deny: editablePermissions[\"d\"],\r\n  ): Promise<void>;\r\n\r\n  /**\r\n   * Sets role permissions for this channel.\r\n   *\r\n   * @param roleId - The ID of the role to set permissions for.\r\n   * @param options - Object containing allow and/or deny permissions.\r\n   * @returns A promise that resolves when the permissions have been updated.\r\n   *\r\n   * @throws {TypeError} If the channel ID is invalid or if both allow and deny are undefined.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Allow specific permissions only\r\n   * await channel.setRolePermissions(roleId, { allow: [\"ViewChannel\", \"SendMessage\"] });\r\n   *\r\n   * // Deny specific permissions only\r\n   * await channel.setRolePermissions(roleId, { deny: [\"ManageMessages\"] });\r\n   *\r\n   * // Set both allow and deny permissions\r\n   * await channel.setRolePermissions(roleId, {\r\n   *   allow: [\"ViewChannel\"],\r\n   *   deny: [\"ManageMessages\"]\r\n   * });\r\n   * ```\r\n   */\r\n  async setRolePermissions(\r\n    roleId: string,\r\n    options: {\r\n      allow?: editablePermissions[\"a\"];\r\n      deny?: editablePermissions[\"d\"];\r\n    },\r\n  ): Promise<void>;\r\n\r\n  // Implementation\r\n  async setRolePermissions(\r\n    roleId: string,\r\n    allowOrOptions?:\r\n      | editablePermissions[\"a\"]\r\n      | {\r\n          allow?: editablePermissions[\"a\"];\r\n          deny?: editablePermissions[\"d\"];\r\n        },\r\n    deny?: editablePermissions[\"d\"],\r\n  ): Promise<void> {\r\n    const id = this.id;\r\n    if (!id) {\r\n      throw new TypeError(\"INVALID_ID\");\r\n    }\r\n\r\n    let allow: editablePermissions[\"a\"] | undefined;\r\n    let denyPermissions: editablePermissions[\"d\"] | undefined;\r\n\r\n    // Handle different overload patterns\r\n    if (Array.isArray(allowOrOptions)) {\r\n      // First two overloads: setRolePermissions(roleId, allow) or setRolePermissions(roleId, allow, deny)\r\n      allow = allowOrOptions;\r\n      denyPermissions = deny;\r\n    } else if (allowOrOptions && typeof allowOrOptions === \"object\") {\r\n      // Third overload: setRolePermissions(roleId, { allow?, deny? })\r\n      allow = allowOrOptions.allow;\r\n      denyPermissions = allowOrOptions.deny;\r\n\r\n      if (allow === undefined && denyPermissions === undefined) {\r\n        throw new TypeError(\r\n          \"At least one of 'allow' or 'deny' must be provided in options\",\r\n        );\r\n      }\r\n    } else {\r\n      throw new TypeError(\"Invalid arguments provided\");\r\n    }\r\n\r\n    const requestBody: {\r\n      allow?: number;\r\n      deny?: number;\r\n    } = {\r\n      allow: 0,\r\n      deny: 0,\r\n    };\r\n\r\n    if (allow !== undefined) {\r\n      requestBody.allow = new FullPermissions(allow).bitfield;\r\n    }\r\n    if (denyPermissions !== undefined) {\r\n      requestBody.deny = new FullPermissions(denyPermissions).bitfield;\r\n    }\r\n\r\n    await this.client.api.put(`/channels/${id}/permissions/${roleId}`, {\r\n      body: { permissions: requestBody },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Sets default permissions for this channel.\r\n   *\r\n   * @param allow - Array of permissions to allow by default.\r\n   * @returns A promise that resolves when the permissions have been updated.\r\n   *\r\n   * @throws {TypeError} If the channel ID is invalid.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Allow specific permissions\r\n   * await channel.setDefaultPermissions([\"ViewChannel\", \"SendMessage\"]);\r\n   * ```\r\n   */\r\n  async setDefaultPermissions(allow: editablePermissions[\"a\"]): Promise<void>;\r\n\r\n  /**\r\n   * Sets default permissions for this channel.\r\n   *\r\n   * @param options - Object containing allow and/or deny permissions.\r\n   * @returns A promise that resolves when the permissions have been updated.\r\n   *\r\n   * @throws {TypeError} If the channel ID is invalid or if both allow and deny are undefined.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Allow specific permissions only\r\n   * await channel.setDefaultPermissions({ allow: [\"ViewChannel\", \"SendMessage\"] });\r\n   *\r\n   * // Deny specific permissions only\r\n   * await channel.setDefaultPermissions({ deny: [\"ManageMessages\"] });\r\n   *\r\n   * // Set both allow and deny permissions\r\n   * await channel.setDefaultPermissions({\r\n   *   allow: [\"ViewChannel\"],\r\n   *   deny: [\"ManageMessages\"]\r\n   * });\r\n   * ```\r\n   */\r\n  async setDefaultPermissions(options: {\r\n    allow?: editablePermissions[\"a\"];\r\n    deny?: editablePermissions[\"d\"];\r\n  }): Promise<void>;\r\n\r\n  /**\r\n   * Sets default permissions for this channel (legacy format).\r\n   *\r\n   * @param permissions - Object containing allow and deny permissions.\r\n   * @returns A promise that resolves when the permissions have been updated.\r\n   *\r\n   * @throws {TypeError} If the channel ID is invalid.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Legacy format\r\n   * await channel.setDefaultPermissions({\r\n   *   a: [\"ViewChannel\"],\r\n   *   d: [\"ManageMessages\"]\r\n   * });\r\n   * ```\r\n   */\r\n  async setDefaultPermissions(permissions: editablePermissions): Promise<void>;\r\n\r\n  // Implementation\r\n  async setDefaultPermissions(\r\n    allowOrOptionsOrPermissions?:\r\n      | editablePermissions[\"a\"]\r\n      | {\r\n          allow?: editablePermissions[\"a\"];\r\n          deny?: editablePermissions[\"d\"];\r\n        }\r\n      | editablePermissions,\r\n  ): Promise<void> {\r\n    const id = this.id;\r\n    if (!id) {\r\n      throw new TypeError(\"INVALID_ID\");\r\n    }\r\n\r\n    let allow: editablePermissions[\"a\"] | undefined;\r\n    let deny: editablePermissions[\"d\"] | undefined;\r\n\r\n    // Handle different overload patterns\r\n    if (Array.isArray(allowOrOptionsOrPermissions)) {\r\n      // First overload: setDefaultPermissions(allow)\r\n      allow = allowOrOptionsOrPermissions;\r\n    } else if (\r\n      allowOrOptionsOrPermissions &&\r\n      typeof allowOrOptionsOrPermissions === \"object\"\r\n    ) {\r\n      // Check if it's the legacy format (has 'a' or 'd' properties)\r\n      if (\r\n        \"a\" in allowOrOptionsOrPermissions ||\r\n        \"d\" in allowOrOptionsOrPermissions\r\n      ) {\r\n        // Third overload: setDefaultPermissions({ a, d }) - legacy format\r\n        const legacyPerms = allowOrOptionsOrPermissions as editablePermissions;\r\n        allow = legacyPerms.a;\r\n        deny = legacyPerms.d;\r\n      } else {\r\n        // Second overload: setDefaultPermissions({ allow?, deny? })\r\n        const options = allowOrOptionsOrPermissions as {\r\n          allow?: editablePermissions[\"a\"];\r\n          deny?: editablePermissions[\"d\"];\r\n        };\r\n        allow = options.allow;\r\n        deny = options.deny;\r\n\r\n        if (allow === undefined && deny === undefined) {\r\n          throw new TypeError(\r\n            \"At least one of 'allow' or 'deny' must be provided in options\",\r\n          );\r\n        }\r\n      }\r\n    } else {\r\n      throw new TypeError(\"Invalid arguments provided\");\r\n    }\r\n\r\n    const requestBody: {\r\n      allow?: number;\r\n      deny?: number;\r\n    } = {};\r\n\r\n    if (allow !== undefined) {\r\n      requestBody.allow = new FullPermissions(allow).bitfield;\r\n    }\r\n    if (deny !== undefined) {\r\n      requestBody.deny = new FullPermissions(deny).bitfield;\r\n    }\r\n\r\n    // Set defaults for undefined permissions\r\n    if (requestBody.allow === undefined) {\r\n      requestBody.allow = 0;\r\n    }\r\n    if (requestBody.deny === undefined) {\r\n      requestBody.deny = 0;\r\n    }\r\n\r\n    await this.client.api.put(`/channels/${id}/permissions/default`, {\r\n      body: { permissions: requestBody },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a new webhook in this channel.\r\n   *\r\n   * @param name - The name of the webhook\r\n   * @param avatar - Optional avatar for the webhook. Can be a URL string, Readable stream, or File object\r\n   * @returns Promise resolving to the created webhook response\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const webhook = await channel.createWebhook(\"My Webhook\", \"https://example.com/avatar.png\");\r\n   * ```\r\n   */\r\n  async createWebhook(\r\n    name: string,\r\n    avatar?: Readable | string | File,\r\n  ): Promise<createWebhookResponse> {\r\n    return this.client.webhooks.create(this.id, name, avatar);\r\n  }\r\n\r\n  /**\r\n   * Retrieves all webhooks for this channel.\r\n   *\r\n   * @returns Promise resolving to an array of webhook responses\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const webhooks = await channel.getWebhooks();\r\n   * console.log(`Found ${webhooks.length} webhooks`);\r\n   * ```\r\n   */\r\n  async getWebhooks(): Promise<createWebhookResponse[]> {\r\n    return this.client.webhooks.getAll(this.id);\r\n  }\r\n\r\n  /**\r\n   * Retrieves a specific webhook by ID and token.\r\n   *\r\n   * @param webhookId - The ID of the webhook to retrieve\r\n   * @param token - The token of the webhook\r\n   * @returns Promise resolving to the webhook response\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const webhook = await channel.getWebhook(\"webhookId\", \"webhookToken\");\r\n   * console.log(`Webhook name: ${webhook.name}`);\r\n   * ```\r\n   */\r\n  async getWebhook(\r\n    webhookId: string,\r\n    token: string,\r\n  ): Promise<createWebhookResponse> {\r\n    return this.client.webhooks.get(webhookId, token);\r\n  }\r\n\r\n  /**\r\n   * Sends a message through a webhook in this channel.\r\n   *\r\n   * @param webhookId - The ID of the webhook to send the message through\r\n   * @param token - The token of the webhook\r\n   * @param content - The message content. Can be a string or MessageOptions object with attachments and embeds\r\n   * @returns Promise resolving to the sent message\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Send a simple text message\r\n   * await channel.sendWebhookMessage(\"webhookId\", \"token\", \"Hello, world!\");\r\n   *\r\n   * // Send a message with embeds and attachments\r\n   * await channel.sendWebhookMessage(\"webhookId\", \"token\", {\r\n   *   content: \"Check out this image!\",\r\n   *   attachments: [\"https://example.com/image.png\"],\r\n   *   embeds: [myEmbed]\r\n   * });\r\n   * ```\r\n   */\r\n  async sendWebhookMessage(\r\n    webhookId: string,\r\n    token: string,\r\n    content: MessageOptions | string,\r\n  ): Promise<APIMessage> {\r\n    return this.client.webhooks.send(webhookId, token, content);\r\n  }\r\n\r\n  /**\r\n   * Deletes a webhook.\r\n   *\r\n   * @param webhookId - The ID of the webhook to delete\r\n   * @param token - The token of the webhook\r\n   * @returns Promise that resolves when the webhook is deleted\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * await channel.deleteWebhook(\"webhookId\", \"webhookToken\");\r\n   * console.log(\"Webhook deleted successfully\");\r\n   * ```\r\n   */\r\n  async deleteWebhook(webhookId: string, token: string): Promise<void> {\r\n    return this.client.webhooks.delete(webhookId, token);\r\n  }\r\n\r\n  /**\r\n   * Edits a webhook's properties.\r\n   *\r\n   * @param webhookId - The ID of the webhook to edit\r\n   * @param token - The token of the webhook\r\n   * @param options - The options to edit on the webhook\r\n   * @returns Promise resolving to the updated webhook response\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const updatedWebhook = await channel.editWebhook(\"webhookId\", \"token\", {\r\n   *   name: \"New Webhook Name\",\r\n   *   avatar: \"https://example.com/new-avatar.png\"\r\n   * });\r\n   * ```\r\n   */\r\n  async editWebhook(\r\n    webhookId: string,\r\n    token: string,\r\n    options: editWebhookOptions,\r\n  ): Promise<createWebhookResponse> {\r\n    return this.client.webhooks.edit(webhookId, token, options);\r\n  }\r\n\r\n  /**\r\n   * Retrieves partial information about a webhook using only its ID.\r\n   * This method provides limited webhook information without requiring a token.\r\n   *\r\n   * @param webhookId - The ID of the webhook to retrieve partial information for\r\n   * @returns Promise resolving to the webhook response with partial information\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const partialWebhook = await channel.getPartialWebhook(\"webhookId\");\r\n   * console.log(`Webhook name: ${partialWebhook.name}`);\r\n   * ```\r\n   */\r\n  async getPartialWebhook(webhookId: string): Promise<createWebhookResponse> {\r\n    return this.client.webhooks.getPartial(webhookId);\r\n  }\r\n}\r\n","import type { Channel as APIChannel } from \"revolt-api\";\r\nimport { Channel, MessageStruct } from \"./index\";\r\nimport { TextBasedChannel } from \"./interfaces/baseChannel\";\r\nimport {\r\n  client,\r\n  MessageManager,\r\n  MessageOptions,\r\n  MessageResolvable,\r\n} from \"../index\";\r\nimport { ChannelTypes, DEFAULT_PERMISSION_DM } from \"../utils/index\";\r\n\r\ntype APIDirectChannel = Extract<APIChannel, { channel_type: \"DirectMessage\" }>;\r\n\r\n/**\r\n * Represents a direct message (DM) channel between users.\r\n *\r\n * @extends Channel\r\n */\r\nexport class DMChannel extends Channel implements TextBasedChannel {\r\n  /** The type of the channel, which is always `DM` for direct message channels. */\r\n  readonly type = ChannelTypes.DM;\r\n\r\n  /** Whether the DM channel is currently active. */\r\n  active!: boolean;\r\n\r\n  /** The default permissions for the DM channel. */\r\n  permissions = DEFAULT_PERMISSION_DM;\r\n\r\n  /** Manages the messages in this DM channel. */\r\n  messages = new MessageManager(this);\r\n\r\n  /** The ID of the last message sent in this DM channel, if any. */\r\n  lastMessageId: string | null = null;\r\n\r\n  /**\r\n   * Creates a new DMChannel instance.\r\n   *\r\n   * @param {client} client - The client instance.\r\n   * @param {APIDirectChannel} data - The raw data for the DM channel from the API.\r\n   */\r\n  constructor(client: client, data: APIDirectChannel) {\r\n    super(client);\r\n    this._patch(data);\r\n  }\r\n\r\n  /**\r\n   * Updates the DM channel instance with new data from the API.\r\n   *\r\n   * @param {APIDirectChannel} data - The raw data for the DM channel from the API.\r\n   * @returns {this} The updated DM channel instance.\r\n   * @protected\r\n   */\r\n  protected _patch(data: APIDirectChannel): this {\r\n    super._patch(data);\r\n\r\n    if (typeof data.active === \"boolean\") this.active = data.active;\r\n    if (data.last_message_id) this.lastMessageId = data.last_message_id;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the last message sent in this DM channel.\r\n   *\r\n   * @returns {Message | null} The last message, or `null` if no message exists.\r\n   */\r\n  get lastMessage(): MessageStruct | null {\r\n    if (!this.lastMessageId) return null;\r\n    return this.messages.cache.get(this.lastMessageId) ?? null;\r\n  }\r\n\r\n  /**\r\n   * Deletes multiple messages from this DM channel.\r\n   *\r\n   * @param {MessageResolvable[] | Map<string, Message> | number} messages - The messages to delete. This can be an array of message resolvables, a map of messages, or a number indicating how many recent messages to delete.\r\n   * @returns {Promise<void>} A promise that resolves when the messages have been successfully deleted.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * await dmChannel.bulkDelete(10); // Deletes the last 10 messages.\r\n   * ```\r\n   */\r\n  bulkDelete(\r\n    messages: MessageResolvable[] | Map<string, MessageStruct> | number,\r\n  ): Promise<void> {\r\n    return this.messages.bulkDelete(messages);\r\n  }\r\n\r\n  /**\r\n   * Sends a message to this DM channel.\r\n   *\r\n   * @param {MessageOptions | string} options - The message content or options for the message.\r\n   * @returns {Promise<Message>} A promise that resolves with the sent message.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * await dmChannel.send(\"Hello, world!\");\r\n   * ```\r\n   */\r\n  send(options: MessageOptions | string): Promise<MessageStruct> {\r\n    return this.messages.send(options);\r\n  }\r\n}\r\n","import type { Channel as APIChannel } from \"revolt-api\";\r\nimport { Attachment, Channel, Invite, MessageStruct, User } from \"./index\";\r\nimport type { TextBasedChannel } from \"./interfaces/baseChannel\";\r\nimport type { client } from \"../client/client\";\r\nimport {\r\n  MessageManager,\r\n  MessageOptions,\r\n  MessageResolvable,\r\n  UserResolvable,\r\n} from \"../managers/index.js\";\r\nimport { ChannelPermissions, ChannelTypes } from \"../utils/index\";\r\nimport { AudioPlayer } from \"../client/player\";\r\n\r\ntype APIGroupChannel = Extract<APIChannel, { channel_type: \"Group\" }>;\r\n\r\n/**\r\n * Represents a group channel, which allows multiple users to communicate.\r\n *\r\n * @extends Channel\r\n */\r\nexport class GroupChannel extends Channel implements TextBasedChannel {\r\n  /** The type of the channel, which is always `GROUP` for group channels. */\r\n  readonly type = ChannelTypes.GROUP;\r\n\r\n  /** The name of the group channel. */\r\n  name!: string;\r\n\r\n  /** The description of the group channel, if any. */\r\n  description: string | null = null;\r\n\r\n  /** The ID of the user who owns the group channel. */\r\n  ownerId!: string;\r\n\r\n  /** The permissions for the group channel. */\r\n  permissions!: Readonly<ChannelPermissions>;\r\n\r\n  /** The icon of the group channel, if any. */\r\n  icon: Attachment | null = null;\r\n\r\n  /** Manages the messages in this group channel. */\r\n  messages = new MessageManager(this);\r\n\r\n  /** The ID of the last message sent in this group channel, if any. */\r\n  lastMessageId: string | null = null;\r\n\r\n  /** A map of user IDs to their corresponding `User` instances in the group channel. */\r\n  users = new Map<string, User>();\r\n\r\n  /** Whether the group channel is marked as NSFW (Not Safe For Work). */\r\n  nsfw = false;\r\n\r\n  /**\r\n   * Creates a new GroupChannel instance.\r\n   *\r\n   * @param {client} client - The client instance.\r\n   * @param {APIGroupChannel} data - The raw data for the group channel from the API.\r\n   */\r\n  constructor(client: client, data: APIGroupChannel) {\r\n    super(client);\r\n    this._patch(data);\r\n  }\r\n\r\n  /**\r\n   * Updates the group channel instance with new data from the API.\r\n   *\r\n   * @param {APIGroupChannel} data - The raw data for the group channel from the API.\r\n   * @returns {this} The updated group channel instance.\r\n   * @protected\r\n   */\r\n  protected _patch(data: APIGroupChannel): this {\r\n    super._patch(data);\r\n\r\n    if (\"description\" in data) {\r\n      this.description = data.description ?? null;\r\n    }\r\n\r\n    if (Array.isArray(data.recipients)) {\r\n      this.users.clear();\r\n      for (const userId of data.recipients) {\r\n        const user = this.client.users.cache.get(userId);\r\n        if (user) this.users.set(user.id, user);\r\n      }\r\n    }\r\n\r\n    if (typeof data.permissions === \"number\") {\r\n      this.permissions = new ChannelPermissions(data.permissions).freeze();\r\n    }\r\n\r\n    if (data.owner) {\r\n      this.ownerId = data.owner;\r\n    }\r\n\r\n    if (data.icon) {\r\n      this.icon = new Attachment(this.client, data.icon);\r\n    }\r\n\r\n    if (data.name) {\r\n      this.name = data.name;\r\n    }\r\n\r\n    if (data.last_message_id) this.lastMessageId = data.last_message_id;\r\n\r\n    if (typeof data.nsfw === \"boolean\") this.nsfw = data.nsfw;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the last message sent in this group channel.\r\n   *\r\n   * @returns {Message | null} The last message, or `null` if no message exists.\r\n   */\r\n  get lastMessage(): MessageStruct | null {\r\n    if (!this.lastMessageId) return null;\r\n    return this.messages.cache.get(this.lastMessageId) ?? null;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the owner of the group channel.\r\n   *\r\n   * @returns {User | null} The owner of the group channel, or `null` if not found.\r\n   */\r\n  get owner(): User | null {\r\n    return this.client.users.cache.get(this.ownerId) ?? null;\r\n  }\r\n\r\n  /**\r\n   * Deletes multiple messages from this group channel.\r\n   *\r\n   * @param {MessageResolvable[] | Map<string, Message> | number} messages - The messages to delete. This can be an array of message resolvables, a map of messages, or a number indicating how many recent messages to delete.\r\n   * @returns {Promise<void>} A promise that resolves when the messages have been successfully deleted.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * await groupChannel.bulkDelete(10); // Deletes the last 10 messages.\r\n   * ```\r\n   */\r\n  bulkDelete(\r\n    messages: MessageResolvable[] | Map<string, MessageStruct> | number,\r\n  ): Promise<void> {\r\n    return this.messages.bulkDelete(messages);\r\n  }\r\n\r\n  /**\r\n   * Creates an invite for the group channel.\r\n   *\r\n   * @returns {Promise<Invite>} A promise that resolves with the created invite.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const invite = await groupChannel.createInvite();\r\n   * console.log(`Invite created: ${invite}`);\r\n   * ```\r\n   */\r\n  async createInvite(): Promise<Invite> {\r\n    const data = await this.client.api.post(`/channels/${this.id}/invites`, {});\r\n    return new Invite(\r\n      this.client,\r\n      data as { type: \"Group\"; _id: string; creator: string; channel: string },\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Adds a user to the group channel.\r\n   *\r\n   * @param {UserResolvable} user - The user to add to the group channel.\r\n   * @returns {Promise<void>} A promise that resolves when the user has been successfully added.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * await groupChannel.add(user);\r\n   * ```\r\n   */\r\n  async add(user: UserResolvable): Promise<void> {\r\n    const id = this.client.users.resolveId(user);\r\n    if (!id) throw new TypeError(\"INVALID_TYPE\");\r\n    await this.client.api.put(`/channels/${this.id}/recipients/${id}`);\r\n  }\r\n\r\n  /**\r\n   * Removes a user from the group channel.\r\n   *\r\n   * @param {UserResolvable} user - The user to remove from the group channel.\r\n   * @returns {Promise<void>} A promise that resolves when the user has been successfully removed.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * await groupChannel.remove(user);\r\n   * ```\r\n   */\r\n  async remove(user: UserResolvable): Promise<void> {\r\n    const id = this.client.users.resolveId(user);\r\n    if (!id) throw new TypeError(\"INVALID_TYPE\");\r\n    await this.client.api.delete(`/channels/${this.id}/recipients/${id}`);\r\n  }\r\n\r\n  /**\r\n   * Leaves the group channel.\r\n   *\r\n   * @returns {Promise<void>} A promise that resolves when the group channel has been successfully left.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * await groupChannel.leave();\r\n   * ```\r\n   */\r\n  leave(): Promise<void> {\r\n    return super.delete();\r\n  }\r\n\r\n  /**\r\n   * Sends a message to this group channel.\r\n   *\r\n   * @param {MessageOptions | string} options - The message content or options for the message.\r\n   * @returns {Promise<Message>} A promise that resolves with the sent message.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * await groupChannel.send(\"Hello, group!\");\r\n   * ```\r\n   */\r\n  send(options: MessageOptions | string): Promise<MessageStruct> {\r\n    return this.messages.send(options);\r\n  }\r\n\r\n  /**\r\n   * Creates and connects an AudioPlayer to this voice channel in one step.\r\n   * This is a convenience method that combines createPlayer() and connect().\r\n   *\r\n   * @returns {Promise<AudioPlayer>} A promise that resolves to a connected AudioPlayer\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const voiceChannel = await client.channels.fetch('voice-channel-id') as VoiceChannel;\r\n   * const player = await voiceChannel.connect();\r\n   *\r\n   * // Already connected, ready to play\r\n   * await player.playFromUrl('https://example.com/music.mp3');\r\n   * ```\r\n   */\r\n  async connect(): Promise<AudioPlayer> {\r\n    return this.client.voice.connectToChannel(this.id, this.id);\r\n  }\r\n\r\n  /** Disconnects the AudioPlayer from this voice channel's server. */\r\n  async disconnect(): Promise<void> {\r\n    return this.client.voice.disconnectFromChannel(this.id);\r\n  }\r\n  /** Stops the AudioPlayer in this voice channel's server. */\r\n  async stop(): Promise<void> {\r\n    return this.client.voice.stopPlayerInChannel(this.id);\r\n  }\r\n  /** Plays audio through the AudioPlayer connected to this voice channel.\r\n   * @param source - The audio source (URL, file path, or stream)\r\n   */\r\n  async play(source: string): Promise<void> {\r\n    const player = await this.getPlayer();\r\n    if (!player) throw new Error(\"No active player found for this channel\");\r\n    return player.play(source);\r\n  }\r\n  /** Retrieves the AudioPlayer associated with this voice channel, if any.\r\n   * @returns {Promise<AudioPlayer | null>} A promise that resolves to the AudioPlayer or null if not found\r\n   */\r\n  async getPlayer(): Promise<AudioPlayer | null> {\r\n    const player = this.client.voice[\"players\"].get(this.id);\r\n    return player ?? null;\r\n  }\r\n\r\n  //   iconURL(options?: { size: number }): string | null {\r\n  //     if (!this.icon) return null;\r\n  //     return this.client.api.cdn.icon(this.icon.id, options?.size);\r\n  //   }\r\n}\r\n","import { Base } from \"./base\";\r\nimport type { Invite as APIInvite } from \"revolt-api\";\r\nimport type { Server, User } from \"./index\";\r\nimport type { client } from \"../client/client\";\r\n\r\n/**\r\n * Represents an invite to a server or channel.\r\n *\r\n * @extends Base\r\n */\r\nexport class Invite extends Base {\r\n  /** The ID of the server associated with the invite, if any. */\r\n  serverId: string | null = null;\r\n\r\n  /** The ID of the user who created the invite. */\r\n  inviterId!: string;\r\n\r\n  /** The ID of the channel associated with the invite. */\r\n  channelId!: string;\r\n\r\n  /**\r\n   * Creates a new Invite instance.\r\n   *\r\n   * @param {client} client - The client instance.\r\n   * @param {APIInvite} data - The raw data for the invite from the API.\r\n   */\r\n  constructor(client: client, data: APIInvite) {\r\n    super(client);\r\n    this._patch(data);\r\n  }\r\n\r\n  /**\r\n   * Updates the invite instance with new data from the API.\r\n   *\r\n   * @param {APIInvite} data - The raw data for the invite from the API.\r\n   * @returns {this} The updated invite instance.\r\n   * @protected\r\n   */\r\n  protected _patch(data: APIInvite): this {\r\n    super._patch(data);\r\n\r\n    if (data.channel) this.channelId = data.channel;\r\n    if (data.creator) this.inviterId = data.channel;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the server associated with the invite.\r\n   *\r\n   * @returns {Server | null} The server associated with the invite, or `null` if not found.\r\n   */\r\n  get server(): Server | null {\r\n    return this.client.servers.cache.get(this.serverId!) ?? null;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the channel associated with the invite.\r\n   *\r\n   * @returns {Channel | null} The channel associated with the invite, or `null` if not found.\r\n   */\r\n  get channel() {\r\n    return this.client.channels.cache.get(this.channelId) ?? null;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the user who created the invite.\r\n   *\r\n   * @returns {User | null} The user who created the invite, or `null` if not found.\r\n   */\r\n  get inviter(): User | null {\r\n    return this.client.users.cache.get(this.inviterId) ?? null;\r\n  }\r\n\r\n  //   toString(): string {\r\n  //     return this.client.api.cdn.invite(this.id);\r\n  //   }\r\n}\r\n","import { MessageStruct, ServerMember, User } from \"./index\";\r\nimport { client } from \"../client/client\";\r\nimport { UserResolvable } from \"../managers/index\";\r\n\r\n/**\r\n * Represents the mentions in a message, including users and server members.\r\n */\r\nexport class Mentions {\r\n  /** The client instance. */\r\n  public readonly client: client;\r\n\r\n  /**\r\n   * Creates a new Mentions instance.\r\n   *\r\n   * @param {Message} message - The message associated with the mentions.\r\n   * @param {string[]} _users - An array of user IDs mentioned in the message.\r\n   */\r\n  constructor(\r\n    public readonly message: MessageStruct,\r\n    protected _users: string[],\r\n  ) {\r\n    this.client = message.client;\r\n  }\r\n\r\n  /**\r\n   * Checks if a specific user is mentioned in the message.\r\n   *\r\n   * @param {UserResolvable} user - The user to check.\r\n   * @returns {boolean} `true` if the user is mentioned, otherwise `false`.\r\n   * @throws {TypeError} Throws an error if the user cannot be resolved.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * if (mentions.has(someUser)) {\r\n   *   console.log(\"User is mentioned!\");\r\n   * }\r\n   * ```\r\n   */\r\n  has(user: UserResolvable): boolean {\r\n    const id = this.client.users.resolveId(user);\r\n    if (!id) throw new TypeError(\"INVALID_TYPE\");\r\n    return this._users.includes(id);\r\n  }\r\n\r\n  /**\r\n   * Retrieves the server members mentioned in the message.\r\n   *\r\n   * @returns {Map<string, ServerMember> | null} A map of user IDs to `ServerMember` instances, or `null` if the message is not in a server.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const members = mentions.members;\r\n   * if (members) {\r\n   *   members.forEach(member => console.log(member.displayName));\r\n   * }\r\n   * ```\r\n   */\r\n  get members(): Map<string, ServerMember> | null {\r\n    const server = this.message.server;\r\n\r\n    if (!server) return null;\r\n\r\n    const members = new Map<string, ServerMember>();\r\n\r\n    for (const userId of this._users) {\r\n      const member = server.members.cache.get(userId);\r\n      if (member) members.set(member.id, member);\r\n    }\r\n\r\n    return members;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the users mentioned in the message.\r\n   *\r\n   * @returns {Map<string, User>} A map of user IDs to `User` instances.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const users = mentions.users;\r\n   * users.forEach(user => console.log(user.username));\r\n   * ```\r\n   */\r\n  get users(): Map<string, User> {\r\n    const users = new Map<string, User>();\r\n\r\n    for (const userId of this._users) {\r\n      const user = this.client.users.cache.get(userId);\r\n      if (user) users.set(user.id, user);\r\n    }\r\n\r\n    return users;\r\n  }\r\n}\r\n","import type { Embed as APIEmbed, Special, SendableEmbed } from \"revolt-api\";\r\nimport { client } from \"../client/client\";\r\nimport { Readable } from \"stream\";\r\nimport axios from \"axios\";\r\nimport FormData from \"form-data\";\r\nimport { File } from \"node:buffer\";\r\nimport { CDNAttachmentResponse } from \"../utils/types\";\r\n\r\nexport type Embed = APIEmbed;\r\nexport type EmbedImage = Extract<Embed, { type: \"Image\" }>;\r\nexport type EmbedVideo = Extract<Embed, { type: \"Video\" }>;\r\nexport type EmbedSpecial = Special;\r\n\r\n/**\r\n * Represents a message embed, which can include rich content such as titles, descriptions, URLs, and media.\r\n */\r\nexport class MessageEmbed {\r\n  #url?: string;\r\n  #title?: string;\r\n  #description?: string;\r\n  #icon_url?: string;\r\n  #color?: string;\r\n  #media?: Readable | string | File;\r\n\r\n  /**\r\n   * Sets the title of the embed.\r\n   *\r\n   * @param {string} title - The title to set.\r\n   * @returns {this} The updated `MessageEmbed` instance.\r\n   */\r\n  setTitle(title: string): this {\r\n    this.#title = title;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the icon URL of the embed.\r\n   *\r\n   * @param {string} iconURL - The URL of the icon to set.\r\n   * @returns {this} The updated `MessageEmbed` instance.\r\n   */\r\n  setIcon(iconURL: string): this {\r\n    this.#icon_url = iconURL;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the color of the embed.\r\n   *\r\n   * @param {string} color - The color to set (e.g., a hex code).\r\n   * @returns {this} The updated `MessageEmbed` instance.\r\n   */\r\n  setColor(color: string): this {\r\n    this.#color = color;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the description of the embed.\r\n   *\r\n   * @param {string} description - The description to set.\r\n   * @returns {this} The updated `MessageEmbed` instance.\r\n   */\r\n  setDescription(description: string): this {\r\n    this.#description = description;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the URL of the embed.\r\n   *\r\n   * @param {string} url - The URL to set.\r\n   * @returns {this} The updated `MessageEmbed` instance.\r\n   */\r\n  setURL(url: string): this {\r\n    this.#url = url;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the media (e.g., image or video) of the embed.\r\n   *\r\n   * @param {Readable | string | File} media - The media URL, File or Stream to set.\r\n   * @returns {this} The updated `MessageEmbed` instance.\r\n   */\r\n  setMedia(media: Readable | string | File): this {\r\n    this.#media = media;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param client The client instance used to send the embed.\r\n   * @returns SendableEmbed\r\n   * Converts the embed to a JSON object that can be sent to the API, including media handling.\r\n   */\r\n  async toJSONWithMedia(client: client): Promise<SendableEmbed> {\r\n    const embed: SendableEmbed = {\r\n      title: this.#title,\r\n      icon_url: this.#icon_url,\r\n      colour: this.#color,\r\n      description: this.#description,\r\n      url: this.#url,\r\n    };\r\n\r\n    if (this.#media) {\r\n      let att = this.#media;\r\n      const data = new FormData();\r\n      if (typeof att === \"string\") {\r\n        const readableStream = (await axios.get(att, {\r\n          responseType: \"stream\",\r\n        })) as { data: Readable };\r\n        data.append(\"file\", readableStream.data, {\r\n          filename: att.split(\"/\").pop(),\r\n        });\r\n      }\r\n\r\n      if (att instanceof Readable) {\r\n        data.append(\"file\", att);\r\n      }\r\n\r\n      if (att instanceof File) {\r\n        const buffer = Buffer.from(await att.arrayBuffer());\r\n        data.append(\"file\", buffer, { filename: att.name });\r\n      }\r\n\r\n      await client.cdn.post(\"/attachments\", data).then((attachment) => {\r\n        const { id } = attachment as CDNAttachmentResponse;\r\n        embed.media = id;\r\n      });\r\n    }\r\n\r\n    return embed;\r\n  }\r\n\r\n  /**\r\n   * Converts the embed to a JSON object that can be sent to the API.\r\n   *\r\n   * @returns {SendableEmbed} The JSON representation of the embed.\r\n   */\r\n  toJSON(): SendableEmbed {\r\n    return {\r\n      title: this.#title,\r\n      icon_url: this.#icon_url,\r\n      colour: this.#color,\r\n      description: this.#description,\r\n      url: this.#url,\r\n      media: this.#media?.toString(),\r\n    };\r\n  }\r\n}\r\n","import type { Channel as APIChannel } from \"revolt-api\";\r\nimport { Channel, MessageStruct, User } from \"./index\";\r\nimport { TextBasedChannel } from \"./interfaces/baseChannel\";\r\nimport { client } from \"../client/client\";\r\nimport {\r\n  MessageManager,\r\n  MessageOptions,\r\n  MessageResolvable,\r\n} from \"../managers/index\";\r\nimport { ChannelTypes } from \"../utils/index\";\r\n\r\ntype APINotesChannel = Extract<APIChannel, { channel_type: \"SavedMessages\" }>;\r\n\r\n/**\r\n * Represents a notes channel, which is used for saving personal messages.\r\n *\r\n * @extends Channel\r\n */\r\nexport class NotesChannel extends Channel implements TextBasedChannel {\r\n  /** The type of the channel, which is always `NOTES` for notes channels. */\r\n  readonly type = ChannelTypes.NOTES;\r\n\r\n  /** The ID of the user associated with the notes channel. */\r\n  userId!: string;\r\n\r\n  /** The ID of the last message sent in this notes channel, if any. */\r\n  lastMessageId: string | null = null;\r\n\r\n  /** Manages the messages in this notes channel. */\r\n  messages = new MessageManager(this);\r\n\r\n  /**\r\n   * Creates a new NotesChannel instance.\r\n   *\r\n   * @param {client} client - The client instance.\r\n   * @param {APINotesChannel} data - The raw data for the notes channel from the API.\r\n   */\r\n  constructor(client: client, data: APINotesChannel) {\r\n    super(client);\r\n    this._patch(data);\r\n  }\r\n\r\n  /**\r\n   * Updates the notes channel instance with new data from the API.\r\n   *\r\n   * @param {APINotesChannel} data - The raw data for the notes channel from the API.\r\n   * @returns {this} The updated notes channel instance.\r\n   * @protected\r\n   */\r\n  protected _patch(data: APINotesChannel): this {\r\n    super._patch(data);\r\n\r\n    if (data.user) {\r\n      this.userId = data.user;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sends a message to this notes channel.\r\n   *\r\n   * @param {MessageOptions | string} options - The message content or options for the message.\r\n   * @returns {Promise<Message>} A promise that resolves with the sent message.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * await notesChannel.send(\"This is a saved message.\");\r\n   * ```\r\n   */\r\n  send(options: MessageOptions | string): Promise<MessageStruct> {\r\n    return this.messages.send(options);\r\n  }\r\n\r\n  /**\r\n   * Deletes multiple messages from this notes channel.\r\n   *\r\n   * @param {MessageResolvable[] | Map<string, Message> | number} messages - The messages to delete. This can be an array of message resolvables, a map of messages, or a number indicating how many recent messages to delete.\r\n   * @returns {Promise<void>} A promise that resolves when the messages have been successfully deleted.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * await notesChannel.bulkDelete(5); // Deletes the last 5 messages.\r\n   * ```\r\n   */\r\n  bulkDelete(\r\n    messages: MessageResolvable[] | Map<string, MessageStruct> | number,\r\n  ): Promise<void> {\r\n    return this.messages.bulkDelete(messages);\r\n  }\r\n\r\n  /**\r\n   * Retrieves the last message sent in this notes channel.\r\n   *\r\n   * @returns {Message | null} The last message, or `null` if no message exists.\r\n   */\r\n  get lastMessage(): MessageStruct | null {\r\n    if (!this.lastMessageId) return null;\r\n    return this.messages.cache.get(this.lastMessageId) ?? null;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the user associated with this notes channel.\r\n   *\r\n   * @returns {User} The user associated with the notes channel.\r\n   */\r\n  get user(): User {\r\n    return this.client.user!;\r\n  }\r\n}\r\n","import type { FieldsChannel } from \"revolt-api\";\r\nimport {\r\n  Attachment,\r\n  Category,\r\n  Channel,\r\n  Invite,\r\n  MessageStruct,\r\n  Server,\r\n} from \"./index\";\r\nimport { client } from \"../client/client\";\r\nimport { FullPermissions } from \"../utils/index\";\r\nimport { APIServerChannel } from \"../types\";\r\nimport { MessageManager, MessageOptions } from \"../managers\";\r\nimport { AudioPlayer } from \"../client/player\";\r\n\r\nexport interface Overwrite {\r\n  allow: FullPermissions;\r\n  deny: FullPermissions;\r\n}\r\n\r\n/**\r\n * Represents a server channel, which can be a text or voice channel.\r\n *\r\n * @extends Channel\r\n */\r\nexport class ServerChannel extends Channel {\r\n  /** The name of the channel. */\r\n  name!: string;\r\n\r\n  /** The ID of the server this channel belongs to. */\r\n  serverId!: string;\r\n\r\n  /** The description of the channel, or `null` if none is set. */\r\n  description: string | null = null;\r\n\r\n  /** The icon of the channel, or `null` if none is set. */\r\n  icon: Attachment | null = null;\r\n\r\n  /** Manages the messages in this Server channel. */\r\n  messages = new MessageManager(this);\r\n\r\n  /** The permission overwrites for the channel. */\r\n  overwrites = new Map<string, Overwrite>();\r\n\r\n  /** Whether the channel is marked as NSFW (Not Safe For Work). */\r\n  nsfw = false;\r\n\r\n  /**\r\n   * Creates a new ServerChannel instance.\r\n   *\r\n   * @param {client} client - The client instance.\r\n   * @param {APIServerChannel} data - The raw data for the server channel from the API.\r\n   */\r\n  constructor(client: client, data: APIServerChannel) {\r\n    super(client);\r\n    this._patch(data);\r\n  }\r\n\r\n  /**\r\n   * Updates the server channel instance with new data from the API.\r\n   *\r\n   * @param {APIServerChannel} data - The raw data for the server channel from the API.\r\n   * @param {FieldsChannel[]} [clear=[]] - Fields to clear in the channel.\r\n   * @returns {this} The updated server channel instance.\r\n   * @protected\r\n   */\r\n  protected _patch(data: APIServerChannel, clear: FieldsChannel[] = []): this {\r\n    super._patch(data);\r\n\r\n    if (data.name) this.name = data.name;\r\n\r\n    if (data.server) this.serverId = data.server;\r\n\r\n    if (\"description\" in data) this.description = data.description ?? null;\r\n\r\n    if (data.icon) this.icon = new Attachment(this.client, data.icon);\r\n\r\n    if (typeof data.nsfw === \"boolean\") this.nsfw = data.nsfw;\r\n\r\n    if (data.role_permissions) {\r\n      this.overwrites.clear();\r\n      for (const [id, { a, d }] of Object.entries(data.role_permissions)) {\r\n        this.overwrites.set(id, {\r\n          allow: new FullPermissions(a),\r\n          deny: new FullPermissions(d),\r\n        });\r\n      }\r\n    }\r\n\r\n    for (const field of clear) {\r\n      if (field === \"Icon\") this.icon = null;\r\n      if (field === \"Description\") this.description = null;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Creates an invite for the server channel.\r\n   *\r\n   * @returns {Promise<Invite>} A promise that resolves with the created invite.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const invite = await serverChannel.createInvite();\r\n   * console.log(`Invite created: ${invite}`);\r\n   * ```\r\n   */\r\n  async createInvite(): Promise<Invite> {\r\n    const data = await this.client.api.post(`/channels/${this.id}/invites`, {});\r\n    return new Invite(\r\n      this.client,\r\n      data as\r\n        | {\r\n            type: \"Server\";\r\n            _id: string;\r\n            server: string;\r\n            creator: string;\r\n            channel: string;\r\n          }\r\n        | { type: \"Group\"; _id: string; creator: string; channel: string },\r\n    );\r\n  }\r\n\r\n  //   iconURL(options?: { size: number }): string | null {\r\n  //     return this.icon\r\n  //       ? this.client.api.cdn.icon(this.icon.id, options?.size)\r\n  //       : null;\r\n  //   }\r\n\r\n  /**\r\n   * Retrieves the server this channel belongs to.\r\n   *\r\n   * @returns {Server} The server instance.\r\n   */\r\n  get server(): Server {\r\n    return this.client.servers.cache.get(this.serverId)!;\r\n  }\r\n\r\n  /**\r\n   * Sends a message to this Server channel.\r\n   *\r\n   * @param {MessageOptions | string} options - The message content or options for the message.\r\n   * @returns {Promise<Message>} A promise that resolves with the sent message.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * await serverChannel.send(\"Hello, world!\");\r\n   * ```\r\n   */\r\n  send(options: MessageOptions | string): Promise<MessageStruct> {\r\n    return this.messages.send(options);\r\n  }\r\n\r\n  /**\r\n   * Retrieves the category this channel belongs to, if any.\r\n   *\r\n   * @returns {Category | null} The category instance, or `null` if the channel is not in a category.\r\n   */\r\n  get category(): Category | null {\r\n    return (\r\n      Array.from(this.server.categories.values()).find((cat) =>\r\n        cat.children.has(this.id),\r\n      ) ?? null\r\n    );\r\n  }\r\n}\r\n","import type { Member as APIMember, FieldsMember } from \"revolt-api\";\r\nimport { Base } from \"./base\";\r\nimport { Attachment, Server, User, Role, Presence } from \"./index\";\r\nimport { client } from \"../client/client\";\r\nimport { FullPermissions, Badges } from \"../utils\";\r\n\r\n/**\r\n * Represents a member of a server.\r\n *\r\n * @extends Base\r\n */\r\nexport class ServerMember extends Base {\r\n  /** The ID of the server this member belongs to. */\r\n  serverId!: string;\r\n\r\n  /** The nickname of the member, or `null` if none is set. */\r\n  nickname: string | null = null;\r\n\r\n  /** The avatar of the member, or `null` if none is set. */\r\n  avatar: Attachment | null = null;\r\n\r\n  /** roles assigned to the member */\r\n  roles: Role[] = [];\r\n\r\n  /**\r\n   * Creates a new ServerMember instance.\r\n   *\r\n   * @param {client} client - The client instance.\r\n   * @param {APIMember} data - The raw data for the server member from the API.\r\n   */\r\n  constructor(client: client, data: APIMember) {\r\n    super(client);\r\n    this._patch(data);\r\n  }\r\n\r\n  /**\r\n   * Updates the server member instance with new data from the API.\r\n   *\r\n   * @param {APIMember} data - The raw data for the server member from the API.\r\n   * @param {FieldsMember[]} [clear=[]] - Fields to clear in the server member.\r\n   * @returns {this} The updated server member instance.\r\n   * @protected\r\n   */\r\n  protected _patch(data: APIMember, clear: FieldsMember[] = []): this {\r\n    super._patch(data);\r\n\r\n    if (\"nickname\" in data) {\r\n      this.nickname = data.nickname ?? null;\r\n    }\r\n\r\n    if (data.avatar) {\r\n      this.avatar = new Attachment(this.client, data.avatar);\r\n    }\r\n\r\n    if (data._id) {\r\n      this.serverId = data._id.server;\r\n      this.id = data._id.user;\r\n    }\r\n\r\n    if (Array.isArray(data.roles)) {\r\n      if (!data.roles.length) this.roles = [];\r\n      else {\r\n        this.roles = data.roles.map((roleId) => {\r\n          const role = this.server.roles.cache.get(roleId);\r\n          if (!role) {\r\n            throw new Error(\r\n              `Role with ID ${roleId} not found in server ${this.serverId}`,\r\n            );\r\n          }\r\n          return role;\r\n        });\r\n      }\r\n    }\r\n\r\n    for (const field of clear) {\r\n      if (field === \"Avatar\") this.avatar = null;\r\n      if (field === \"Nickname\") this.nickname = null;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the nickname of the server member.\r\n   *\r\n   * @param {string} [nickname] - The new nickname to set, or `undefined` to clear the nickname.\r\n   * @returns {Promise<this>} A promise that resolves with the updated server member instance.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * await member.setNickname(\"NewNickname\");\r\n   * ```\r\n   */\r\n  async setNickname(nickname?: string): Promise<this> {\r\n    await this.server.members.edit(this, { nickname });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * adds a role to the server member.\r\n   * @param roleId - The ID of the role to add to the member.\r\n   * @returns\r\n   */\r\n  async addRole(roleId: string): Promise<this> {\r\n    const currentRoles = this.roles.map((role) => role.id);\r\n    if (currentRoles.includes(roleId)) {\r\n      return this; // Role already exists, no need to add it again\r\n    }\r\n    await this.server.members.edit(this, {\r\n      roles: [...currentRoles, roleId],\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes a role from the server member.\r\n   *\r\n   * @param {string} roleId - The ID of the role to remove from the member.\r\n   * @returns {Promise<this>} A promise that resolves with the updated server member instance.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * await member.removeRole(\"roleId\");\r\n   * ```\r\n   */\r\n  async removeRole(roleId: string): Promise<this> {\r\n    const currentRoles = this.roles.map((role) => role.id);\r\n    if (!currentRoles.includes(roleId)) {\r\n      return this; // Role does not exist, no need to remove it\r\n    }\r\n    await this.server.members.edit(this, {\r\n      roles: currentRoles.filter((id) => id !== roleId),\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Bans the server member.\r\n   *\r\n   * @param {string} [reason] - The reason for the ban.\r\n   * @returns {Promise<void>} A promise that resolves when the member is banned.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * await member.ban(\"Violation of rules\");\r\n   * ```\r\n   */\r\n  ban(reason?: string): Promise<void> {\r\n    return this.server.members.ban(this, reason);\r\n  }\r\n\r\n  /**\r\n   * Kicks the server member.\r\n   *\r\n   * @returns {Promise<void>} A promise that resolves when the member is kicked.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * await member.kick();\r\n   * ```\r\n   */\r\n  kick(): Promise<void> {\r\n    return this.server.members.kick(this);\r\n  }\r\n\r\n  /**\r\n   * Leaves the server.\r\n   *\r\n   * @returns {Promise<void>} A promise that resolves when the member leaves the server.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * await member.leave();\r\n   * ```\r\n   */\r\n  leave(): Promise<void> {\r\n    return this.client.servers.delete(this.serverId);\r\n  }\r\n\r\n  /**\r\n   * Gets the effective permissions for this server member based on their roles.\r\n   *\r\n   * The permissions are calculated by:\r\n   * 1. Starting with a base FullPermissions with no permissions\r\n   * 2. For each role the member has, applying the role's allow permissions\r\n   * 3. For each role the member has, removing the role's deny permissions\r\n   *\r\n   * @returns {FullPermissions} The effective permissions for this member\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const permissions = member.getPermissions();\r\n   * console.log(permissions.has('MANAGE_MESSAGES')); // true or false\r\n   * ```\r\n   */\r\n  permissions(): FullPermissions {\r\n    // Start with no permissions\r\n    let permissions = new FullPermissions();\r\n\r\n    // Apply allow permissions from all roles\r\n    for (const role of this.roles) {\r\n      if (role.overwrite?.allow) {\r\n        permissions = permissions.add(role.overwrite.allow);\r\n      }\r\n    }\r\n\r\n    // Remove deny permissions from all roles\r\n    for (const role of this.roles) {\r\n      if (role.overwrite?.deny) {\r\n        permissions = permissions.remove(role.overwrite.deny);\r\n      }\r\n    }\r\n\r\n    return permissions;\r\n  }\r\n\r\n  /**\r\n   * Checks if this server member has a specific permission.\r\n   *\r\n   * @param {string | number | FullPermissions} permission - The permission to check for\r\n   * @returns {boolean} Whether the member has the permission\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * if (member.hasPermission('MANAGE_MESSAGES')) {\r\n   *   // Member can manage messages\r\n   * }\r\n   * ```\r\n   *\r\n   * note this works on the same basis as stoats permissions checking\r\n   */\r\n  hasPermission(permission: string | number | FullPermissions): boolean {\r\n    if (this.client.servers.cache.get(this.serverId)?.ownerId === this.id)\r\n      return true;\r\n    return this.permissions().has(permission);\r\n  }\r\n\r\n  //   async displayAvatarURL(options?: { size: number }): Promise<string> {\r\n  //     return await this.user.displayAvatarURL(options);\r\n  //   }\r\n\r\n  /**\r\n   * Retrieves the user associated with this server member.\r\n   *\r\n   * @returns {User} The user instance.\r\n   */\r\n  get user(): User {\r\n    return this.client.users.cache.get(this.id)!;\r\n  }\r\n\r\n  /**\r\n   * Gets the username of the user.\r\n   *\r\n   * @returns {string} The username of the user.\r\n   */\r\n  get username(): string {\r\n    return this.user.username;\r\n  }\r\n\r\n  /**\r\n   * Gets whether the user is a bot.\r\n   *\r\n   * @returns {boolean} Whether the user is a bot.\r\n   */\r\n  get bot(): boolean {\r\n    return this.user.bot ?? false;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the server this member belongs to.\r\n   *\r\n   * @returns {Server} The server instance.\r\n   */\r\n  get server(): Server {\r\n    return this.client.servers.cache.get(this.serverId)!;\r\n  }\r\n\r\n  /**\r\n   * Converts the server member to a string representation.\r\n   *\r\n   * @returns {string} A string representation of the server member in the format `<@userId>`.\r\n   */\r\n  toString(): string {\r\n    return `<@${this.id}>`;\r\n  }\r\n\r\n  /**\r\n   * Sets a timeout for the server member.\r\n   * @param duration - The duration of the timeout as a Date object.\r\n   * @returns A promise that resolves when the timeout is set.\r\n   */\r\n  timeout(duration: Date): Promise<void> {\r\n    return this.server.members.edit(this, { timeout: duration });\r\n  }\r\n}\r\n","import type { Channel } from \"revolt-api\";\r\nimport { MessageStruct, ServerChannel } from \"./index\";\r\nimport { TextBasedChannel } from \"./interfaces/baseChannel\";\r\nimport { client } from \"../client/client\";\r\nimport {\r\n  MessageManager,\r\n  MessageOptions,\r\n  MessageResolvable,\r\n} from \"../managers/index\";\r\nimport { ChannelTypes } from \"../utils/index\";\r\n\r\ntype APITextChannel = Extract<Channel, { channel_type: \"TextChannel\" }>;\r\n\r\n/**\r\n * Represents a text channel in a server.\r\n *\r\n * @extends ServerChannel\r\n */\r\nexport class TextChannel extends ServerChannel implements TextBasedChannel {\r\n  /** The ID of the last message sent in this text channel, if any. */\r\n  lastMessageId: string | null = null;\r\n\r\n  /** Manages the messages in this text channel. */\r\n  messages = new MessageManager(this);\r\n\r\n  /** The type of the channel, which is always `TEXT` for text channels. */\r\n  readonly type = ChannelTypes.TEXT;\r\n\r\n  /**\r\n   * Creates a new TextChannel instance.\r\n   *\r\n   * @param {client} client - The client instance.\r\n   * @param {APITextChannel} data - The raw data for the text channel from the API.\r\n   */\r\n  constructor(client: client, data: APITextChannel) {\r\n    super(client, data);\r\n    this._patch(data);\r\n  }\r\n\r\n  /**\r\n   * Updates the text channel instance with new data from the API.\r\n   *\r\n   * @param {APITextChannel} data - The raw data for the text channel from the API.\r\n   * @returns {this} The updated text channel instance.\r\n   * @protected\r\n   */\r\n  protected _patch(data: APITextChannel): this {\r\n    super._patch(data);\r\n\r\n    if (data.last_message_id) this.lastMessageId = data.last_message_id;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the last message sent in this text channel.\r\n   *\r\n   * @returns {Message | null} The last message, or `null` if no message exists.\r\n   */\r\n  get lastMessage(): MessageStruct | null {\r\n    if (!this.lastMessageId) return null;\r\n    return this.messages.cache.get(this.lastMessageId) ?? null;\r\n  }\r\n\r\n  /**\r\n   * Sends a message to this text channel.\r\n   *\r\n   * @param {MessageOptions | string} options - The message content or options for the message.\r\n   * @returns {Promise<Message>} A promise that resolves with the sent message.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * await textChannel.send(\"Hello, world!\");\r\n   * ```\r\n   */\r\n  send(options: MessageOptions | string): Promise<MessageStruct> {\r\n    return this.messages.send(options);\r\n  }\r\n\r\n  /**\r\n   * Deletes multiple messages from this text channel.\r\n   *\r\n   * @param {MessageResolvable[] | Map<string, Message> | number} messages - The messages to delete. This can be an array of message resolvables, a map of messages, or a number indicating how many recent messages to delete.\r\n   * @returns {Promise<void>} A promise that resolves when the messages have been successfully deleted.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * await textChannel.bulkDelete(10); // Deletes the last 10 messages.\r\n   * ```\r\n   */\r\n  bulkDelete(\r\n    messages: MessageResolvable[] | Map<string, MessageStruct> | number,\r\n  ): Promise<void> {\r\n    return this.messages.bulkDelete(messages);\r\n  }\r\n}\r\n","import type { Channel } from \"revolt-api\";\r\nimport { ServerChannel } from \"./index\";\r\nimport { client } from \"../client/client\";\r\nimport { ChannelTypes } from \"../utils/index\";\r\nimport { AudioPlayer } from \"../client/player\";\r\n\r\ntype APIVoiceChannel = Extract<Channel, { channel_type: \"VoiceChannel\" }>;\r\n\r\nexport type Voice = {\r\n  id: string;\r\n  participants: voiceParticipant[];\r\n};\r\n\r\nexport type voiceParticipant = {\r\n  id: string;\r\n  joined_at: string;\r\n  is_receving: boolean;\r\n  is_publishing: boolean;\r\n  screensharing: boolean;\r\n  camera: boolean;\r\n};\r\n\r\n/**\r\n * Represents a voice channel in a server.\r\n *\r\n * @extends ServerChannel\r\n */\r\nexport class VoiceChannel extends ServerChannel {\r\n  /** The type of the channel, which is always `VOICE` for voice channels. */\r\n  readonly type = ChannelTypes.VOICE;\r\n  voice?: Map<string, voiceParticipant> = new Map();\r\n\r\n  /**\r\n   * Creates a new VoiceChannel instance.\r\n   *\r\n   * @param {client} client - The client instance.\r\n   * @param {APIVoiceChannel} data - The raw data for the voice channel from the API.\r\n   */\r\n  constructor(client: client, data: APIVoiceChannel) {\r\n    super(client, data);\r\n    this._patch(data);\r\n  }\r\n\r\n  /**\r\n   * Updates the voice channel instance with new data from the API.\r\n   *\r\n   * @param {APIVoiceChannel} data - The raw data for the voice channel from the API.\r\n   * @returns {this} The updated voice channel instance.\r\n   * @protected\r\n   */\r\n  protected _patch(data: APIVoiceChannel): this {\r\n    super._patch(data);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Acknowledges the voice channel.\r\n   *\r\n   * @throws {TypeError} Throws an error because voice channels cannot be acknowledged.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * try {\r\n   *   await voiceChannel.ack();\r\n   * } catch (error) {\r\n   *   console.error(error.message); // \"Cannot ack voice channel\"\r\n   * }\r\n   * ```\r\n   */\r\n  ack(): Promise<void> {\r\n    throw new TypeError(\"Cannot ack voice channel\");\r\n  }\r\n  /**\r\n   * Creates and connects an AudioPlayer to this voice channel in one step.\r\n   * This is a convenience method that combines createPlayer() and connect().\r\n   *\r\n   * @returns {Promise<AudioPlayer>} A promise that resolves to a connected AudioPlayer\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const voiceChannel = await client.channels.fetch('voice-channel-id') as VoiceChannel;\r\n   * const player = await voiceChannel.connect();\r\n   *\r\n   * // Already connected, ready to play\r\n   * await player.playFromUrl('https://example.com/music.mp3');\r\n   * ```\r\n   */\r\n  async connect(): Promise<AudioPlayer> {\r\n    return this.client.voice.connectToChannel(this.id, this.serverId);\r\n  }\r\n\r\n  /** Disconnects the AudioPlayer from this voice channel's server. */\r\n  async disconnect(): Promise<void> {\r\n    return this.client.voice.disconnectFromChannel(this.serverId);\r\n  }\r\n  /** Stops the AudioPlayer in this voice channel's server. */\r\n  async stop(): Promise<void> {\r\n    return this.client.voice.stopPlayerInChannel(this.serverId);\r\n  }\r\n  /** Plays audio through the AudioPlayer connected to this voice channel.\r\n   * @param source - The audio source (URL, file path, or stream)\r\n   */\r\n  async play(source: string): Promise<void> {\r\n    const player = await this.getPlayer();\r\n    if (!player) throw new Error(\"No active player found for this channel\");\r\n    return player.play(source);\r\n  }\r\n  /** Retrieves the AudioPlayer associated with this voice channel, if any.\r\n   * @returns {Promise<AudioPlayer | null>} A promise that resolves to the AudioPlayer or null if not found\r\n   */\r\n  async getPlayer(): Promise<AudioPlayer | null> {\r\n    const player = this.client.voice[\"players\"].get(this.serverId);\r\n    return player ?? null;\r\n  }\r\n}\r\n","import type { Category as APICategory } from \"revolt-api\";\r\nimport { Base, Server, ServerChannel } from \"./index\";\r\n\r\n/**\r\n * Represents a category in a server, which groups multiple channels together.\r\n *\r\n * @extends Base\r\n */\r\nexport class Category extends Base {\r\n  /** The name of the category. */\r\n  name!: string;\r\n\r\n  /** An array of channel IDs that belong to this category. */\r\n  protected _children: string[] = [];\r\n\r\n  /**\r\n   * Creates a new Category instance.\r\n   *\r\n   * @param {Server} server - The server this category belongs to.\r\n   * @param {APICategory} data - The raw data for the category from the API.\r\n   */\r\n  constructor(\r\n    public readonly server: Server,\r\n    data: APICategory,\r\n  ) {\r\n    super(server.client);\r\n    this._patch(data);\r\n  }\r\n\r\n  /**\r\n   * Updates the category instance with new data from the API.\r\n   *\r\n   * @param {APICategory} data - The raw data for the category from the API.\r\n   * @returns {this} The updated category instance.\r\n   * @protected\r\n   */\r\n  protected _patch(data: APICategory): this {\r\n    super._patch(data);\r\n\r\n    if (data.title) {\r\n      this.name = data.title;\r\n    }\r\n\r\n    if (Array.isArray(data.channels)) {\r\n      this._children = data.channels;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the channels that belong to this category.\r\n   *\r\n   * @returns {Map<string, ServerChannel>} A map of channel IDs to their corresponding `ServerChannel` instances.\r\n   */\r\n  get children(): Map<string, ServerChannel> {\r\n    const coll = new Map<string, ServerChannel>();\r\n\r\n    for (const childId of this._children) {\r\n      const child = this.server.channels.cache.get(childId);\r\n      if (child) coll.set(child.id, child);\r\n    }\r\n\r\n    return coll;\r\n  }\r\n\r\n  /**\r\n   * Converts the category to a string representation.\r\n   *\r\n   * @returns {string} The name of the category.\r\n   */\r\n  toString(): string {\r\n    return this.name;\r\n  }\r\n}\r\n","import { Base } from \"./base\";\r\nimport { client } from \"../client/client\";\r\n\r\n/**\r\n * Represents an emoji in the client.\r\n *\r\n * @extends Base\r\n */\r\nexport class Emoji extends Base {\r\n  /** The parent object of the emoji, which can be a server or other entity. */\r\n  parent?: { type: string; id: string } | null = null;\r\n\r\n  /** The ID of the user who created the emoji, or `null` if not available. */\r\n  creator_id?: string | null = null;\r\n\r\n  /** The name of the emoji, or `null` if not set. */\r\n  name?: string | null = null;\r\n\r\n  /**\r\n   * Creates a new Emoji instance.\r\n   *\r\n   * @param {client} client - The client instance.\r\n   * @param {Emoji} data - The raw data for the emoji.\r\n   */\r\n  constructor(client: client, data: Emoji) {\r\n    super(client);\r\n    this._patch(data);\r\n  }\r\n\r\n  /**\r\n   * Retrieves the user who created the emoji.\r\n   *\r\n   * @returns {User | null} The creator of the emoji, or `null` if not found.\r\n   */\r\n  get creator() {\r\n    return this.client.users.cache.get(this.creator_id!) ?? null;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the server associated with the emoji, if any.\r\n   *\r\n   * @returns {Server | null} The server instance, or `null` if the emoji is not associated with a server.\r\n   */\r\n  get server() {\r\n    if (!this.parent) return null;\r\n    return this.client.servers.cache.get(this.parent.id) ?? null;\r\n  }\r\n}\r\n","import type { Channel as APIChannel } from \"revolt-api\";\r\nimport { BaseManager } from \"./baseManager\";\r\nimport {\r\n  Channel,\r\n  DMChannel,\r\n  GroupChannel,\r\n  NotesChannel,\r\n  TextChannel,\r\n  VoiceChannel,\r\n} from \"../struct/index\";\r\n\r\nexport type ChannelResolvable = Channel | APIChannel | string;\r\n\r\nexport class ChannelManager extends BaseManager<Channel, APIChannel> {\r\n  /** @private */\r\n  holds = null;\r\n\r\n  /** @private */\r\n  _add(data: APIChannel & { voice?: any }): Channel {\r\n    let channel: Channel;\r\n\r\n    switch (data.channel_type) {\r\n      case \"TextChannel\":\r\n        if (data.voice !== undefined) {\r\n          channel = new VoiceChannel(this.client, data as any);\r\n        } else {\r\n          channel = new TextChannel(this.client, data);\r\n        }\r\n        break;\r\n      case \"VoiceChannel\":\r\n        channel = new VoiceChannel(this.client, data);\r\n        break;\r\n      case \"DirectMessage\":\r\n        channel = new DMChannel(this.client, data);\r\n        break;\r\n      case \"Group\":\r\n        channel = new GroupChannel(this.client, data);\r\n        break;\r\n      case \"SavedMessages\":\r\n        channel = new NotesChannel(this.client, data);\r\n        if (this.client.user) this.client.user.notes = channel as NotesChannel;\r\n        break;\r\n      default:\r\n        throw new Error(`Unknown Channel Type: ${data}`);\r\n    }\r\n\r\n    this.cache.set(channel.id, channel);\r\n\r\n    return channel;\r\n  }\r\n\r\n  _remove(id: string): void {\r\n    const channel = this.cache.get(id);\r\n\r\n    if (channel?.inServer()) {\r\n      channel.server?.channels.cache.delete(id);\r\n    }\r\n\r\n    super._remove(id);\r\n  }\r\n\r\n  /**\r\n   * used to delete a channel\r\n   *\r\n   * @param channel The channel to delete\r\n   * @returns A promise that resolves when the channel is deleted\r\n   */\r\n  async delete(channel: ChannelResolvable): Promise<void> {\r\n    const id = this.resolveId(channel);\r\n    if (!id) {\r\n      throw new TypeError(\"INVALID_TYPE\");\r\n    }\r\n    await this.client.api.delete(`/channels/${id}`);\r\n  }\r\n\r\n  /**\r\n   * used to fetch a channel\r\n   *\r\n   * @param channel The channel to fetch\r\n   * @param force Whether to force fetch the channel using the api or return it form cache if able\r\n   * @returns A promise that resolves with the fetched channel\r\n   */\r\n  async fetch(\r\n    channel: ChannelResolvable,\r\n    { force = true } = {},\r\n  ): Promise<Channel> {\r\n    const id = this.resolveId(channel);\r\n\r\n    if (!id) {\r\n      throw new TypeError(\"INVALID_TYPE\");\r\n    }\r\n\r\n    if (!force) {\r\n      const channel = this.cache.get(id);\r\n      if (channel) return channel;\r\n    }\r\n\r\n    const data = (await this.client.api.get(`/channels/${id}`)) as APIChannel;\r\n\r\n    return this._add(data);\r\n  }\r\n\r\n  /**\r\n   * resolves a channel from a string or a channel object\r\n   * @param channel The channel to resolve\r\n   * @returns the resolved channel or null if not found\r\n   */\r\n  resolve(channel: ChannelResolvable): Channel | null {\r\n    if (channel instanceof Channel) return channel;\r\n    return super.resolve(channel);\r\n  }\r\n\r\n  /**\r\n   * resolves a channel id from a string or a channel object\r\n   * @param channel The channel to resolve\r\n   * @returns the resolved channel id or null if not found\r\n   */\r\n  resolveId(channel: ChannelResolvable): string | null {\r\n    if (channel instanceof Channel) return channel.id;\r\n    return super.resolveId(channel);\r\n  }\r\n}\r\n","import { BaseManager } from \"./baseManager\";\r\nimport { Server } from \"../struct/index\";\r\nimport { Server as APIServer } from \"revolt-api\";\r\n\r\nexport type ServerResolvable = Server | APIServer | string;\r\n\r\nexport interface EditServerOptions {\r\n  name?: string;\r\n  description?: string;\r\n}\r\n\r\nexport class ServerManager extends BaseManager<Server, APIServer> {\r\n  /** @private */\r\n  readonly holds = Server;\r\n\r\n  /** @private */\r\n  _remove(id: string): void {\r\n    const server = this.cache.get(id);\r\n\r\n    for (const id of server?.channels.cache.keys() ?? []) {\r\n      this.client.channels._remove(id);\r\n    }\r\n\r\n    return super._remove(id);\r\n  }\r\n\r\n  /**\r\n   * edits a server\r\n   * @param server The server to edit\r\n   * @param options The options to edit the server with\r\n   * @param options.name The name of the server\r\n   * @param options.description The description of the server\r\n   * @returns A promise that resolves when the server is edited\r\n   */\r\n  async edit(\r\n    server: ServerResolvable,\r\n    options: EditServerOptions,\r\n  ): Promise<void> {\r\n    const id = this.resolveId(server);\r\n    if (!id) throw new TypeError(\"INVALID_TYPE\");\r\n    await this.client.api.patch(`/servers/${id}`, { body: options });\r\n  }\r\n\r\n  /**\r\n   * leaves a server\r\n   * @param server the server to leave\r\n   */\r\n  async delete(server: ServerResolvable): Promise<void> {\r\n    const id = this.resolveId(server);\r\n    if (!id) throw new TypeError(\"INVALID_TYPE\");\r\n    await this.client.api.delete(`/servers/${id}`);\r\n  }\r\n\r\n  async fetch(\r\n    server: ServerResolvable,\r\n    { force = true } = {},\r\n  ): Promise<Server> {\r\n    const id = this.resolveId(server);\r\n\r\n    if (!id) throw new TypeError(\"INVALID_TYPE\");\r\n\r\n    if (!force) {\r\n      const server = this.cache.get(id);\r\n      if (server) return server;\r\n    }\r\n\r\n    const data = await this.client.api.get(`/servers/${id}`);\r\n\r\n    return this._add(data as APIServer);\r\n  }\r\n}\r\n","import type { User as APIUser } from \"revolt-api\";\r\nimport { BaseManager } from \"./baseManager\";\r\nimport { MessageStruct, ServerMember, User } from \"../struct/index\";\r\n\r\nexport type UserResolvable = User | APIUser | MessageStruct | string;\r\n\r\nexport class UserManager extends BaseManager<User, APIUser> {\r\n  /** @private */\r\n  holds = User;\r\n\r\n  /**\r\n   *\r\n   * @param user The user to fetch\r\n   * @returns A promise that resolves when the user is fetched\r\n   */\r\n  async fetch(user: UserResolvable, { force = false } = {}): Promise<User> {\r\n    const id = this.resolveId(user);\r\n\r\n    if (!id) throw new TypeError(\"INVALID_TYPE\");\r\n\r\n    if (!force) {\r\n      const user = this.cache.get(id);\r\n      if (user) return user;\r\n    }\r\n\r\n    const data = (await this.client.api.get(`/users/${id}`)) as APIUser;\r\n\r\n    return this._add(data);\r\n  }\r\n\r\n  /**\r\n   * get a user form cache\r\n   * @param resolvable The user to resolve\r\n   * @returns The user or null if it cannot be resolved\r\n   */\r\n  resolve(resolvable: MessageStruct | User): User | null;\r\n  resolve(resolvable: string | APIUser): User | null;\r\n  resolve(resolvable: User | APIUser | string | MessageStruct): User | null {\r\n    if (resolvable instanceof MessageStruct)\r\n      return resolvable.author as unknown as User;\r\n    return super.resolve(resolvable) as User | null;\r\n  }\r\n\r\n  /**\r\n   * get a user id form cache\r\n   * @param resolvable The user to resolve\r\n   * @returns The user id or null if it cannot be resolved\r\n   */\r\n  resolveId(resolvable: UserResolvable): string | null {\r\n    if (resolvable instanceof MessageStruct) return resolvable.authorId;\r\n    return super.resolveId(resolvable);\r\n  }\r\n}\r\n","import type {\r\n  Message as APIMessage,\r\n  Masquerade,\r\n  MessageSort,\r\n  SendableEmbed,\r\n} from \"revolt-api\";\r\nimport { File } from \"node:buffer\";\r\nimport { Readable } from \"stream\";\r\nimport FormData from \"form-data\";\r\nimport axios from \"axios\";\r\nimport { BaseManager } from \"./baseManager\";\r\nimport { Channel, Emoji, MessageStruct, MessageEmbed } from \"../struct/index\";\r\nimport { UUID } from \"../utils/index\";\r\nimport { CDNAttachmentResponse } from \"../utils/types\";\r\n\r\nexport type MessageResolvable = MessageStruct | APIMessage | string;\r\n\r\nexport interface MessageReply {\r\n  id: string;\r\n  mention: boolean;\r\n}\r\n\r\nexport interface MessageOptions {\r\n  content?: string;\r\n  replies?: MessageReply[];\r\n  attachments?: Readable[] | string[] | File[];\r\n  embeds?: MessageEmbed[];\r\n  masquerade?: Masquerade;\r\n}\r\n\r\nexport interface MessageEditOptions {\r\n  content?: string;\r\n  attachments?: string[];\r\n  embeds?: MessageEmbed[];\r\n}\r\n\r\nexport interface MessageSearchOptions {\r\n  query: string;\r\n  limit?: number;\r\n  before?: string;\r\n  after?: string;\r\n  sort?: MessageSort;\r\n}\r\n\r\nexport interface MessageQueryOptions {\r\n  limit?: number;\r\n  before?: string;\r\n  after?: string;\r\n  sort?: MessageSort;\r\n  nearby?: string;\r\n}\r\n\r\nexport class MessageManager extends BaseManager<MessageStruct, APIMessage> {\r\n  /** @private */\r\n  holds = MessageStruct;\r\n  constructor(\r\n    protected readonly channel: Channel,\r\n    maxSize = 1000,\r\n  ) {\r\n    super(channel.client, maxSize);\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param content The content to send. Can be a string or an object with the following properties:\r\n   * - content: The content of the message\r\n   * - replies: An array of message IDs to reply to\r\n   * - attachments: An array of attachment URLs, Files, or ReadStreams\r\n   * - embeds: An array of MessageEmbed objects\r\n   * @returns Promise that resolves to the sent message\r\n   */\r\n  async send(content: MessageOptions | string): Promise<MessageStruct> {\r\n    if (typeof content === \"string\") content = { content };\r\n    let attachments: string[] = [];\r\n    let embeds: SendableEmbed[] = [];\r\n\r\n    if (Array.isArray(content.attachments)) {\r\n      const promises = content.attachments.map(async (att) => {\r\n        const data = new FormData();\r\n        if (typeof att === \"string\") {\r\n          const readableStream = (await axios.get(att, {\r\n            responseType: \"stream\",\r\n          })) as { data: Readable };\r\n          data.append(\"file\", readableStream.data, {\r\n            filename: att.split(\"/\").pop(),\r\n          });\r\n        }\r\n\r\n        if (att instanceof Readable) {\r\n          data.append(\"file\", att);\r\n        }\r\n\r\n        if (att instanceof File) {\r\n          const buffer = Buffer.from(await att.arrayBuffer());\r\n          data.append(\"file\", buffer, { filename: att.name });\r\n        }\r\n\r\n        await this.client.cdn.post(\"/attachments\", data).then((attachment) => {\r\n          const { id } = attachment as CDNAttachmentResponse;\r\n          attachments.push(id);\r\n        });\r\n      });\r\n      await Promise.all(promises);\r\n    }\r\n\r\n    if (Array.isArray(content.embeds)) {\r\n      const promises = content.embeds.map(async (embed) => {\r\n        const json = await embed.toJSONWithMedia(this.client);\r\n        embeds.push(json);\r\n      });\r\n      await Promise.all(promises);\r\n    }\r\n\r\n    const resp = (await this.client.api.post(\r\n      `/channels/${this.channel.id}/messages`,\r\n      {\r\n        body: { ...content, attachments, embeds, nonce: UUID.generate() },\r\n      },\r\n    )) as APIMessage;\r\n    return this._add(resp);\r\n  }\r\n\r\n  /**\r\n   * acknowledge a message to mark it as read (not important for bots)\r\n   * @param message The message to acknowledge\r\n   * @returns Promise that resolves when the message is acknowledged\r\n   */\r\n  async ack(message: MessageResolvable): Promise<void> {\r\n    const id = this.resolveId(message);\r\n    if (!id) {\r\n      throw new TypeError(\"INVALID_TYPE\");\r\n    }\r\n    await this.client.api.put(`/channels/${this.channel.id}/ack/${id}`);\r\n  }\r\n\r\n  /**\r\n   * bulk delete messages from the channel\r\n   * @param messages The messages to delete. Can be an array of message IDs or a Map of message IDs to Message objects.\r\n   * @returns Promise that resolves when the messages are deleted\r\n   */\r\n  async bulkDelete(\r\n    messages: MessageResolvable[] | number | Map<string, MessageStruct>,\r\n  ): Promise<void> {\r\n    let ids: string[] = [];\r\n\r\n    if (typeof messages === \"number\") {\r\n      messages = await this.fetch(messages);\r\n      ids = messages instanceof Map ? [...messages.keys()] : [];\r\n    } else if (messages instanceof Map) {\r\n      ids = [...messages.keys()];\r\n    } else {\r\n      ids = messages.map((m) => this.resolveId(m)!).filter(Boolean);\r\n    }\r\n\r\n    await this.client.api.delete(`/channels/${this.channel.id}/messages/bulk`, {\r\n      body: JSON.stringify({ ids }),\r\n    });\r\n  }\r\n\r\n  /**\r\n   * delete a message from the channel\r\n   * @param message The message to delete. Can be a Message object or a message ID.\r\n   * @returns Promise that resolves when the message is deleted\r\n   */\r\n  async delete(message: MessageResolvable): Promise<void> {\r\n    const id = this.resolveId(message);\r\n    if (!id) {\r\n      throw new TypeError(\"INVALID_TYPE\");\r\n    }\r\n    await this.client.api.delete(`/channels/${this.channel.id}/messages/${id}`);\r\n  }\r\n\r\n  /**\r\n   * edit a message in the channel\r\n   * @param message The message to edit. Can be a Message object or a message ID.\r\n   * @param options The options to edit the message with. Can be a string or an object with the following properties:\r\n   * - content: The new content of the message\r\n   * - attachments: An array of attachment URLs\r\n   * - embeds: An array of MessageEmbed objects\r\n   * @returns Promise that resolves when the message is edited\r\n   */\r\n  async edit(\r\n    message: MessageResolvable,\r\n    options: MessageEditOptions | string,\r\n  ): Promise<void> {\r\n    const id = this.resolveId(message);\r\n\r\n    if (!id) {\r\n      throw new TypeError(\"INVALID_TYPE\");\r\n    }\r\n\r\n    if (typeof options === \"string\") options = { content: options };\r\n\r\n    await this.client.api.patch(`/channels/${this.channel.id}/messages/${id}`, {\r\n      body: options,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * search for messages in the channel\r\n   * @param query The query to search for. Can be a string or an object with the following properties:\r\n   * - query: The query to search for\r\n   * - limit: The maximum number of messages to return\r\n   * - before: The message ID to start searching from (exclusive)\r\n   * - after: The message ID to stop searching at (exclusive)\r\n   * - sort: The sort order of the results (asc or desc)\r\n   * @returns Promise that resolves to a Map of message IDs to Message objects\r\n   */\r\n  async search(\r\n    query: MessageSearchOptions | string,\r\n  ): Promise<Map<string, MessageStruct>> {\r\n    if (typeof query === \"string\") query = { query };\r\n\r\n    const response = (await this.client.api.post(\r\n      `/channels/${this.channel.id}/search`,\r\n      {\r\n        query: query as Required<MessageSearchOptions>,\r\n      },\r\n    )) as APIMessage[];\r\n\r\n    return response.reduce((coll, cur) => {\r\n      const msg = this._add(cur);\r\n      coll.set(msg.id, msg);\r\n      return coll;\r\n    }, new Map<string, MessageStruct>());\r\n  }\r\n\r\n  /**\r\n   * fetch a message from the channel\r\n   * @param message The message to fetch. Can be a Message object, a message ID, or an object with the following properties:\r\n   * - limit: The maximum number of messages to return\r\n   * - before: The message ID to start fetching from (exclusive)\r\n   * - after: The message ID to stop fetching at (exclusive)\r\n   * @returns Promise that resolves to a Message object or a Map of message IDs to Message objects\r\n   */\r\n  fetch(message: MessageResolvable): Promise<MessageStruct>;\r\n  fetch(query?: MessageQueryOptions): Promise<Map<string, MessageStruct>>;\r\n  fetch(limit: number): Promise<Map<string, MessageStruct>>;\r\n  async fetch(\r\n    query?: MessageResolvable | MessageQueryOptions | number,\r\n  ): Promise<Map<string, MessageStruct> | MessageStruct> {\r\n    const id = this.resolveId(query as string);\r\n\r\n    if (id) {\r\n      const data = (await this.client.api.get(\r\n        `/channels/${this.channel.id}/messages/${id}`,\r\n      )) as APIMessage;\r\n      return this._add(data);\r\n    }\r\n\r\n    if (typeof query === \"number\") query = { limit: query };\r\n    else if (typeof query === \"undefined\") query = { limit: 100 };\r\n    const queryObj = Object.fromEntries(\r\n      Object.entries(query as MessageQueryOptions).filter(\r\n        ([, v]) => v !== undefined,\r\n      ),\r\n    ) as Record<string, string | number>;\r\n    const messages = await this.client.api.get(\r\n      `/channels/${this.channel.id}/messages`,\r\n      queryObj,\r\n    );\r\n\r\n    return (messages as APIMessage[]).reduce((coll, cur) => {\r\n      const msg = this._add(cur);\r\n      coll.set(msg.id, msg);\r\n      return coll;\r\n    }, new Map<string, MessageStruct>());\r\n  }\r\n\r\n  /**\r\n   * add a reaction to a message\r\n   * @param message The message to react to. Can be a Message object or a message ID.\r\n   * @param emoji emoji to react with. Can be a string or an Emoji object.\r\n   * @returns Promise that resolves when the reaction is added\r\n   */\r\n  async addReaction(\r\n    message: MessageResolvable | string,\r\n    emoji: string | Emoji,\r\n  ): Promise<void> {\r\n    const id = this.resolveId(message);\r\n    if (!id) {\r\n      throw new TypeError(\"INVALID_TYPE\");\r\n    }\r\n    if (emoji instanceof Emoji) emoji = emoji.id;\r\n    else if (typeof emoji !== \"string\") {\r\n      throw new TypeError(\"INVALID_TYPE\");\r\n    }\r\n    await this.client.api.put(\r\n      `/channels/${this.channel.id}/messages/${id}/reactions/${emoji}`,\r\n    );\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param message The message to unreact. Can be a Message object or a message ID.\r\n   * @param emoji the emoji to unreact with. Can be a string or an Emoji object.\r\n   * @param user_id The user ID to remove the reaction for. If not provided, removes the reaction for the current user.\r\n   * @param remove_all Whether to remove all of the specified reaction for the message. Defaults to false.\r\n   * @returns Promise that resolves when the reaction is removed\r\n   */\r\n  async removeReaction(\r\n    message: MessageResolvable | string,\r\n    emoji: string | Emoji,\r\n    user_id?: string,\r\n    remove_all = false,\r\n  ): Promise<void> {\r\n    const id = this.resolveId(message);\r\n    if (!id) {\r\n      throw new TypeError(\"INVALID_TYPE\");\r\n    }\r\n    if (emoji instanceof Emoji) emoji = emoji.id;\r\n    else if (typeof emoji !== \"string\") {\r\n      throw new TypeError(\"INVALID_TYPE\");\r\n    }\r\n    const queryString = user_id\r\n      ? `?user_id=${user_id}&remove_all=${remove_all}`\r\n      : `?remove_all=${remove_all}`;\r\n    await this.client.api.delete(\r\n      `/channels/${this.channel.id}/messages/${id}/reactions/${emoji}${queryString}`,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * remove all reactions from a message\r\n   * @param message The message to remove reactions from. Can be a Message object or a message ID.\r\n   * @returns Promise that resolves when the reactions are removed\r\n   */\r\n  async removeAllReactions(message: MessageResolvable | string): Promise<void> {\r\n    const id = this.resolveId(message);\r\n    if (!id) {\r\n      throw new TypeError(\"INVALID_TYPE\");\r\n    }\r\n    await this.client.api.delete(\r\n      `/channels/${this.channel.id}/messages/${id}/reactions`,\r\n    );\r\n  }\r\n}\r\n","import type { Role as APIRole } from \"revolt-api\";\r\nimport { BaseManager } from \"./baseManager\";\r\nimport { Role, Server } from \"../struct/index\";\r\nimport { FullPermissions } from \"../utils\";\r\nimport { editableRole } from \"../utils/types\";\r\n\r\nexport type RoleResolvable = Role | string;\r\n\r\nexport class RoleManager extends BaseManager<Role, APIRole & { id: string }> {\r\n  /** @private */\r\n  holds = Role;\r\n  constructor(protected readonly server: Server) {\r\n    super(server.client);\r\n  }\r\n\r\n  /** @private */\r\n  _add(data: APIRole & { id: string }): Role {\r\n    const role = new Role(this.server, data);\r\n    this.cache.set(role.id, role);\r\n    return role;\r\n  }\r\n\r\n  /**\r\n   * creates a new role in the server\r\n   * @param name The name of the role to create\r\n   * @returns\r\n   */\r\n  async create(name: string): Promise<Role> {\r\n    const { id, role } = await this.client.api.post<{\r\n      id: string;\r\n      role: APIRole;\r\n    }>(`/servers/${this.server.id}/roles`, { body: { name } });\r\n    return this._add(Object.assign(role, { id }));\r\n  }\r\n\r\n  /**\r\n   * deletes a role from the server\r\n   * @param role the role to delete\r\n   * @returns A promise that resolves when the role is deleted\r\n   */\r\n  async delete(role: RoleResolvable): Promise<void> {\r\n    const id = this.resolveId(role);\r\n    if (!id) throw new TypeError(\"INVALID_TYPE\");\r\n    await this.client.api.delete(`/servers/${this.server.id}/roles/${id}`);\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param role the role to edit\r\n   * @param data data to edit the role with\r\n   * @param data.permissions The permissions to set for the role, in the format { a: allow, d: deny }\r\n   * @param data.name The name of the role\r\n   * @param data.colour The color of the role, or `null` if no color is set\r\n   * @param data.hoist Whether the role is displayed separately in the member list\r\n   * @param data.rank The rank of the role, used for ordering\r\n   * @param data.remove Fields to remove from the role\r\n   * @returns Role\r\n   * @throws {TypeError} If the role ID is invalid\r\n   */\r\n  async edit(role: RoleResolvable, data: editableRole): Promise<Role> {\r\n    const id = this.resolveId(role);\r\n    if (!id) throw new TypeError(\"INVALID_TYPE\");\r\n\r\n    if (data.permissions) {\r\n      const permissions = {\r\n        allow: new FullPermissions(data.permissions?.a || []).bitfield,\r\n        deny: new FullPermissions(data.permissions?.d || []).bitfield,\r\n      };\r\n\r\n      await this.client.api.put(\r\n        `/servers/${this.server.id}/permissions/${id}`,\r\n        { body: { permissions } },\r\n      );\r\n    }\r\n    delete data.permissions;\r\n    const updatedRole = (await this.client.api.patch(\r\n      `/servers/${this.server.id}/roles/${id}`,\r\n      { body: data },\r\n    )) as APIRole;\r\n\r\n    return this._add(Object.assign(updatedRole, { id }));\r\n  }\r\n}\r\n","import type { Channel } from \"revolt-api\";\r\nimport { BaseManager } from \"./baseManager\";\r\nimport {\r\n  Server,\r\n  ServerChannel,\r\n  TextChannel,\r\n  VoiceChannel,\r\n} from \"../struct/index\";\r\nimport { UUID } from \"../utils/index\";\r\nimport { APIServerChannel } from \"../types\";\r\n\r\nexport type ServerChannelResolvable = ServerChannel | APIServerChannel | string;\r\n\r\nexport interface CreateChannelOptions {\r\n  name: string;\r\n  type?: \"Text\" | \"Voice\";\r\n  description?: string;\r\n  nsfw?: boolean;\r\n  voice: {\r\n    max_users?: number;\r\n  };\r\n}\r\n\r\nexport class ServerChannelManager extends BaseManager<ServerChannel> {\r\n  /** @private */\r\n  holds = ServerChannel;\r\n  constructor(protected readonly server: Server) {\r\n    super(server.client);\r\n  }\r\n\r\n  /** @private */\r\n  _add(data: APIServerChannel): ServerChannel {\r\n    let channel: ServerChannel;\r\n\r\n    switch (data.channel_type) {\r\n      case \"TextChannel\":\r\n        channel = new TextChannel(this.client, data);\r\n        break;\r\n      case \"VoiceChannel\":\r\n        channel = new VoiceChannel(this.client, data);\r\n        break;\r\n      default:\r\n        throw new Error(\r\n          `Unknown channel type: ${(data as APIServerChannel).channel_type}`,\r\n        );\r\n    }\r\n\r\n    this.cache.set(channel.id, channel);\r\n\r\n    return channel;\r\n  }\r\n\r\n  /**\r\n   * Creates a new channel in the server.\r\n   * @param options - Options for creating the channel.\r\n   * @param options.name - The name of the channel to create.\r\n   * @param [options.type=\"Text\"] - The type of the channel to create. Can be \"Text\" or \"Voice\". Defaults to \"Text\".\r\n   * @param [options.description] - The description of the channel to create. Only used for voice channels.\r\n   * @returns A promise that resolves to the created channel.\r\n   */\r\n  async create({\r\n    name,\r\n    type = \"Text\",\r\n    description,\r\n  }: CreateChannelOptions): Promise<ServerChannel> {\r\n    const data = await this.client.api.post(\r\n      `/servers/${this.server.id}/channels`,\r\n      {\r\n        body: {\r\n          name,\r\n          type,\r\n          description,\r\n          nonce: UUID.generate(),\r\n        },\r\n      },\r\n    );\r\n    return this._add(data as APIServerChannel);\r\n  }\r\n\r\n  /**\r\n   * fetch a channel from the server\r\n   * @param channel The channel to fetch. Can be a string, a channel object, or an API channel object.\r\n   * @param force Whether to force fetch the channel from the API. Defaults to true.\r\n   * If set to false, the method will return the channel from the cache if it exists.\r\n   * @returns A promise that resolves to the fetched channel\r\n   */\r\n  async fetch(\r\n    channel: ServerChannelResolvable,\r\n    { force = true } = {},\r\n  ): Promise<ServerChannel> {\r\n    const id = this.resolveId(channel);\r\n\r\n    if (!id) {\r\n      throw new TypeError(\"INVALID_ID\");\r\n    }\r\n\r\n    if (!force) {\r\n      const channel = this.cache.get(id);\r\n      if (channel) return channel;\r\n    }\r\n\r\n    const data = await this.client.api.get(\r\n      `/servers/${this.server.id}/channels/${id}`,\r\n    );\r\n\r\n    return this._add(data as APIServerChannel);\r\n  }\r\n}\r\n","import type { Member, User as APIUser } from \"revolt-api\";\r\nimport { BaseManager } from \"./baseManager\";\r\nimport { Server, ServerMember, User } from \"../struct/index\";\r\n\r\nexport type ServerMemberResolvable = ServerMember | User | Member | string;\r\n\r\nexport interface EditServerMemberOptions {\r\n  nickname?: string;\r\n  avatar?: string;\r\n  roles?: string[];\r\n  timeout?: Date | number;\r\n}\r\n\r\nexport class ServerMemberManager extends BaseManager<ServerMember, Member> {\r\n  /** @private */\r\n  holds = ServerMember;\r\n  constructor(protected readonly server: Server) {\r\n    super(server.client);\r\n  }\r\n\r\n  /**\r\n   * edit selected member in the server\r\n   * @param member The member to edit\r\n   * @param options The options to edit the member with\r\n   * @param options.nickname The nickname of the member to set\r\n   * @param options.avatar The avatar of the member to set\r\n   * @param options.roles The roles of the member to set\r\n   * @returns A promise that resolves when the member is edited\r\n   */\r\n  async edit(\r\n    member: ServerMemberResolvable,\r\n    options: EditServerMemberOptions,\r\n  ): Promise<void> {\r\n    const id = this.resolveId(member);\r\n    if (!id) {\r\n      throw new TypeError(\"INVALID_TYPE\");\r\n    }\r\n    await this.client.api.patch(`/servers/${this.server.id}/members/${id}`, {\r\n      body: { ...options },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * ban selected member in the server\r\n   * @param member The member to ban\r\n   * @param reason the reason for the ban\r\n   * @returns A promise that resolves when the member is banned\r\n   */\r\n  async ban(member: ServerMemberResolvable, reason?: string): Promise<void> {\r\n    const id = this.resolveId(member);\r\n    if (!id) {\r\n      throw new TypeError(\"INVALID_TYPE\");\r\n    }\r\n    await this.client.api.put(`/servers/${this.server.id}/bans/${id}`, {\r\n      body: { reason },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * kick selected member in the server\r\n   * @param member The member to kick\r\n   * @returns A promise that resolves when the member is kicked\r\n   */\r\n  async kick(member: ServerMemberResolvable): Promise<void> {\r\n    const id = this.resolveId(member);\r\n    if (!id) {\r\n      throw new TypeError(\"INVALID_TYPE\");\r\n    }\r\n    await this.client.api.delete(`/servers/${this.server.id}/members/${id}`);\r\n  }\r\n\r\n  /**\r\n   * unban selected member in the server\r\n   * @param member The member to unban\r\n   * @returns A promise that resolves when the member is unbanned\r\n   */\r\n  async unban(member: ServerMemberResolvable): Promise<void> {\r\n    const id = this.resolveId(member);\r\n    if (!id) {\r\n      throw new TypeError(\"INVALID_TYPE\");\r\n    }\r\n    await this.client.api.delete(`/servers/${this.server.id}/bans/${id}`);\r\n  }\r\n\r\n  /**\r\n   * set timeout for a member in the server\r\n   * @param member The member to set the timeout for\r\n   * @param duration The duration of the timeout as a Date object\r\n   * @returns A promise that resolves when the timeout is set\r\n   */\r\n  async timeout(member: string, duration: Date): Promise<void> {\r\n    await this.client.api.patch(\r\n      `/servers/${this.server.id}/members/${member}`,\r\n      {\r\n        body: { timeout: duration },\r\n      },\r\n    );\r\n  }\r\n\r\n  /**\r\n   * fetch a member from the server\r\n   * @param member The member to fetch\r\n   * @returns A promise that resolves with the fetched member\r\n   */\r\n  async fetch(member: ServerMemberResolvable): Promise<ServerMember>;\r\n  async fetch(): Promise<Map<string, ServerMember>>;\r\n  async fetch(\r\n    member?: ServerMemberResolvable,\r\n  ): Promise<ServerMember | Map<string, ServerMember>> {\r\n    if (typeof member !== \"undefined\") {\r\n      const id = this.resolveId(member);\r\n      if (!id) {\r\n        throw new TypeError(\"INVALID_TYPE\");\r\n      }\r\n      const data = await this.client.api.get(\r\n        `/servers/${this.server.id}/members/${id}`,\r\n      );\r\n      return this._add(data as Member);\r\n    }\r\n\r\n    const { users, members } = await this.client.api.get<{\r\n      users: APIUser[];\r\n      members: Member[];\r\n    }>(`/servers/${this.server.id}/members`);\r\n\r\n    users.reduce((coll, cur) => {\r\n      const user = this.client.users._add(cur);\r\n      coll.set(user.id, user);\r\n      return coll;\r\n    }, this.client.users.cache);\r\n\r\n    return members.reduce((coll, cur) => {\r\n      const member = this._add(cur);\r\n      coll.set(member.id, member);\r\n      return coll;\r\n    }, new Map<string, ServerMember>());\r\n  }\r\n\r\n  /**\r\n   * resolves a member from a string or a member object\r\n   * @param member The member to resolve\r\n   * @returns The id of the member or null if it cannot be resolved\r\n   */\r\n  resolveId(member: ServerMemberResolvable): string | null {\r\n    if (member == null) return null;\r\n    if (member instanceof ServerMember || member instanceof User) {\r\n      return member.id;\r\n    }\r\n    if (typeof member === \"string\") return member;\r\n    if (\"_id\" in member) return member._id.user;\r\n    return null;\r\n  }\r\n}\r\n","import { Readable } from \"stream\";\r\nimport type { client } from \"../client/client\";\r\nimport {\r\n  CDNAttachmentResponse,\r\n  createWebhookResponse,\r\n  editWebhookOptions,\r\n} from \"../utils/types\";\r\nimport axios from \"axios\";\r\nimport FormData from \"form-data\";\r\nimport { UUID } from \"../utils\";\r\nimport { SendableEmbed, Message as APIMessage } from \"revolt-api\";\r\nimport { MessageOptions } from \"./messageManager\";\r\n\r\n/**\r\n * Manages webhooks for the client.\r\n * Provides methods for creating, managing, and sending messages through webhooks.\r\n */\r\nexport class WebhookManager {\r\n  /**\r\n   * Creates a new WebhookManager instance.\r\n   *\r\n   * @param client - The client instance this manager belongs to\r\n   */\r\n  constructor(protected readonly client: client) {}\r\n\r\n  /**\r\n   * Creates a new webhook in the specified channel.\r\n   *\r\n   * @param channelId - The ID of the channel where the webhook will be created\r\n   * @param name - The name of the webhook\r\n   * @param avatar - Optional avatar for the webhook. Can be a URL string, Readable stream, or File object\r\n   * @returns Promise resolving to the created webhook response\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const webhook = await client.webhooks.create(\"channelId\", \"My Webhook\", \"https://example.com/avatar.png\");\r\n   * ```\r\n   */\r\n  async create(\r\n    channelId: string,\r\n    name: string,\r\n    avatar?: Readable | string | File,\r\n  ): Promise<createWebhookResponse> {\r\n    const data = new FormData();\r\n    let avatarID: string | undefined = undefined;\r\n    if (typeof avatar === \"string\") {\r\n      const readableStream = (await axios.get(avatar, {\r\n        responseType: \"stream\",\r\n      })) as { data: Readable };\r\n      data.append(\"file\", readableStream.data, {\r\n        filename: avatar.split(\"/\").pop(),\r\n      });\r\n    }\r\n\r\n    if (avatar instanceof Readable) {\r\n      data.append(\"file\", avatar, { filename: \"avatar.png\" });\r\n    }\r\n\r\n    if (avatar instanceof File) {\r\n      const buffer = Buffer.from(await avatar.arrayBuffer());\r\n      data.append(\"file\", buffer, { filename: avatar.name });\r\n    }\r\n\r\n    if (avatar) {\r\n      await this.client.cdn.post(\"/avatars\", data).then((attachment) => {\r\n        const { id } = attachment as CDNAttachmentResponse;\r\n        avatarID = id;\r\n      });\r\n    }\r\n\r\n    const response = (await this.client.api.post(\r\n      `/channels/${channelId}/webhooks`,\r\n      {\r\n        body: {\r\n          name,\r\n          avatar: avatarID,\r\n        },\r\n      },\r\n    )) as createWebhookResponse;\r\n\r\n    return response;\r\n  }\r\n\r\n  /**\r\n   * Retrieves all webhooks for the specified channel.\r\n   *\r\n   * @param channelId - The ID of the channel to get webhooks from\r\n   * @returns Promise resolving to an array of webhook responses\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const webhooks = await client.webhooks.getAll(\"channelId\");\r\n   * console.log(`Found ${webhooks.length} webhooks`);\r\n   * ```\r\n   */\r\n  async getAll(channelId: string): Promise<createWebhookResponse[]> {\r\n    const response = (await this.client.api.get(\r\n      `/channels/${channelId}/webhooks`,\r\n    )) as createWebhookResponse[];\r\n    return response;\r\n  }\r\n\r\n  /**\r\n   * Retrieves a specific webhook by ID and token.\r\n   *\r\n   * @param webhookId - The ID of the webhook to retrieve\r\n   * @param token - The token of the webhook\r\n   * @returns Promise resolving to the webhook response\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const webhook = await client.webhooks.get(\"webhookId\", \"webhookToken\");\r\n   * console.log(`Webhook name: ${webhook.name}`);\r\n   * ```\r\n   */\r\n  async get(webhookId: string, token: string): Promise<createWebhookResponse> {\r\n    const response = (await this.client.api.get(\r\n      `/webhooks/${webhookId}/${token}`,\r\n    )) as createWebhookResponse;\r\n    return response;\r\n  }\r\n\r\n  /**\r\n   * Sends a message through a webhook.\r\n   *\r\n   * @param webhookId - The ID of the webhook to send the message through\r\n   * @param token - The token of the webhook\r\n   * @param content - The message content. Can be a string or MessageOptions object with attachments and embeds\r\n   * @returns Promise resolving to the sent message\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Send a simple text message\r\n   * await client.webhooks.send(\"webhookId\", \"token\", \"Hello, world!\");\r\n   *\r\n   * // Send a message with embeds and attachments\r\n   * await client.webhooks.send(\"webhookId\", \"token\", {\r\n   *   content: \"Check out this image!\",\r\n   *   attachments: [\"https://example.com/image.png\"],\r\n   *   embeds: [myEmbed]\r\n   * });\r\n   * ```\r\n   */\r\n  async send(\r\n    webhookId: string,\r\n    token: string,\r\n    content: MessageOptions | string,\r\n  ): Promise<APIMessage> {\r\n    if (typeof content === \"string\") content = { content };\r\n    let attachments: string[] = [];\r\n    let embeds: SendableEmbed[] = [];\r\n\r\n    if (Array.isArray(content.attachments)) {\r\n      const promises = content.attachments.map(async (att) => {\r\n        const data = new FormData();\r\n        if (typeof att === \"string\") {\r\n          const readableStream = (await axios.get(att, {\r\n            responseType: \"stream\",\r\n          })) as { data: Readable };\r\n          data.append(\"file\", readableStream.data, {\r\n            filename: att.split(\"/\").pop(),\r\n          });\r\n        }\r\n\r\n        if (att instanceof Readable) {\r\n          data.append(\"file\", att);\r\n        }\r\n\r\n        if (att instanceof File) {\r\n          const buffer = Buffer.from(await att.arrayBuffer());\r\n          data.append(\"file\", buffer, { filename: att.name });\r\n        }\r\n\r\n        await this.client.cdn.post(\"/attachments\", data).then((attachment) => {\r\n          const { id } = attachment as CDNAttachmentResponse;\r\n          attachments.push(id);\r\n        });\r\n      });\r\n      await Promise.all(promises);\r\n    }\r\n\r\n    if (Array.isArray(content.embeds)) {\r\n      const promises = content.embeds.map(async (embed) => {\r\n        const json = await embed.toJSONWithMedia(this.client);\r\n        embeds.push(json);\r\n      });\r\n      await Promise.all(promises);\r\n    }\r\n\r\n    const resp = (await this.client.api.post(\r\n      `/webhooks/${webhookId}/${token}`,\r\n      {\r\n        body: { ...content, attachments, embeds, nonce: UUID.generate() },\r\n      },\r\n    )) as APIMessage;\r\n\r\n    return resp;\r\n  }\r\n\r\n  /**\r\n   * Deletes a webhook.\r\n   *\r\n   * @param webhookId - The ID of the webhook to delete\r\n   * @param token - The token of the webhook\r\n   * @returns Promise that resolves when the webhook is deleted\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * await client.webhooks.delete(\"webhookId\", \"webhookToken\");\r\n   * console.log(\"Webhook deleted successfully\");\r\n   * ```\r\n   */\r\n  async delete(webhookId: string, token: string): Promise<void> {\r\n    await this.client.api.delete(`/webhooks/${webhookId}/${token}`);\r\n  }\r\n\r\n  /**\r\n   * Edits a webhook's properties.\r\n   *\r\n   * @param webhookId - The ID of the webhook to edit\r\n   * @param token - The token of the webhook\r\n   * @param options - The options to edit on the webhook\r\n   * @returns Promise resolving to the updated webhook response\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const updatedWebhook = await client.webhooks.edit(\"webhookId\", \"token\", {\r\n   *   name: \"New Webhook Name\",\r\n   *   avatar: \"https://example.com/new-avatar.png\"\r\n   * });\r\n   * ```\r\n   */\r\n  async edit(\r\n    webhookId: string,\r\n    token: string,\r\n    options: editWebhookOptions,\r\n  ): Promise<createWebhookResponse> {\r\n    const data = new FormData();\r\n    let avatarID: string | undefined = undefined;\r\n    if (typeof options.avatar === \"string\") {\r\n      const readableStream = (await axios.get(options.avatar, {\r\n        responseType: \"stream\",\r\n      })) as { data: Readable };\r\n      data.append(\"file\", readableStream.data, {\r\n        filename: options.avatar.split(\"/\").pop(),\r\n      });\r\n    }\r\n\r\n    if (options.avatar instanceof Readable) {\r\n      data.append(\"file\", options.avatar, { filename: \"avatar.png\" });\r\n    }\r\n\r\n    if (options.avatar instanceof File) {\r\n      const buffer = Buffer.from(await options.avatar.arrayBuffer());\r\n      data.append(\"file\", buffer, { filename: options.avatar.name });\r\n    }\r\n\r\n    if (options.avatar) {\r\n      await this.client.cdn.post(\"/avatars\", data).then((attachment) => {\r\n        const { id } = attachment as CDNAttachmentResponse;\r\n        avatarID = id;\r\n      });\r\n    }\r\n\r\n    const response = (await this.client.api.patch(\r\n      `/webhooks/${webhookId}/${token}`,\r\n      {\r\n        body: {\r\n          ...options,\r\n          avatar: avatarID,\r\n          remove: options.remove ?? [],\r\n        },\r\n      },\r\n    )) as createWebhookResponse;\r\n    return response;\r\n  }\r\n\r\n  /**\r\n   * Retrieves partial information about a webhook using only its ID.\r\n   * This method provides limited webhook information without requiring a token.\r\n   *\r\n   * @param webhookId - The ID of the webhook to retrieve partial information for\r\n   * @returns Promise resolving to the webhook response with partial information\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const partialWebhook = await client.webhooks.getPartial(\"webhookId\");\r\n   * console.log(`Webhook name: ${partialWebhook.name}`);\r\n   * ```\r\n   */\r\n  async getPartial(webhookId: string): Promise<createWebhookResponse> {\r\n    const response = (await this.client.api.get(\r\n      `/webhooks/${webhookId}`,\r\n    )) as createWebhookResponse;\r\n    return response;\r\n  }\r\n}\r\n","import type {\r\n  Channel,\r\n  Role,\r\n  Server,\r\n  ServerMember,\r\n  User,\r\n} from \"../struct/index\";\r\nimport { EventEmitter } from \"node:events\";\r\nimport { DEFAULT_CLIENT_OPTIONS, Events } from \"../utils/constants\";\r\nimport { RestClient } from \"../rest/restClient\";\r\nimport { MessageStruct } from \"../struct/index\";\r\nimport { client } from \"./client\";\r\nimport { CDNClient } from \"../rest/CDNClient\";\r\nimport {\r\n  WebhookCreateData,\r\n  WebhookDeleteData,\r\n  WebhookUpdateData,\r\n} from \"../utils/types\";\r\nimport {\r\n  UserVoiceStateUpdate,\r\n  UserVoiceStateUpdateData,\r\n} from \"./events/userVoiceStateUpdate\";\r\nimport { VoiceChannelJoinData } from \"./events/voiceChannelJoin\";\r\nimport { VoiceChannelLeaveData } from \"./events/voiceChannelLeave\";\r\n\r\n/**\r\n * Represents the base client that provides core functionality for interacting with the API.\r\n *\r\n * @extends EventEmitter\r\n */\r\nexport declare interface BaseClient {\r\n  on<K extends keyof ClientEvents>(\r\n    event: K,\r\n    listener: (...args: ClientEvents[K]) => Awaited<void>,\r\n  ): this;\r\n  on<S extends string | symbol>(\r\n    event: Exclude<S, keyof ClientEvents>,\r\n    listener: (...args: any[]) => Awaited<void>,\r\n  ): this;\r\n  once<K extends keyof ClientEvents>(\r\n    event: K,\r\n    listener: (...args: ClientEvents[K]) => Awaited<void>,\r\n  ): this;\r\n  once<S extends string | symbol>(\r\n    event: Exclude<S, keyof ClientEvents>,\r\n    listener: (...args: any[]) => Awaited<void>,\r\n  ): this;\r\n  emit<K extends keyof ClientEvents>(\r\n    event: K,\r\n    ...args: ClientEvents[K]\r\n  ): boolean;\r\n  emit<S extends string | symbol>(\r\n    event: Exclude<S, keyof ClientEvents>,\r\n    ...args: unknown[]\r\n  ): boolean;\r\n  off<K extends keyof ClientEvents>(\r\n    event: K,\r\n    listener: (...args: ClientEvents[K]) => Awaited<void>,\r\n  ): this;\r\n  off<S extends string | symbol>(\r\n    event: Exclude<S, keyof ClientEvents>,\r\n    listener: (...args: any[]) => Awaited<void>,\r\n  ): this;\r\n  removeAllListeners<K extends keyof ClientEvents>(event?: K): this;\r\n  removeAllListeners<S extends string | symbol>(\r\n    event?: Exclude<S, keyof ClientEvents>,\r\n  ): this;\r\n}\r\n\r\n/**\r\n * Represents the events that the client can emit.\r\n */\r\nexport interface ClientEvents {\r\n  /** Emitted when a debug message is logged. */\r\n  [Events.DEBUG]: [unknown];\r\n  /** Emitted when a message is received. */\r\n  [Events.MESSAGE]: [MessageStruct];\r\n  /** Emitted when a message is deleted. */\r\n  [Events.MESSAGE_DELETE]: [MessageStruct];\r\n  /** Emitted when a message is updated. */\r\n  [Events.MESSAGE_UPDATE]: [MessageStruct, MessageStruct];\r\n  /** Emitted when a reaction is added to a message. */\r\n  [Events.MESSAGE_REACT]: [MessageStruct];\r\n  /** Emitted when a reaction is removed from a message. */\r\n  [Events.MESSAGE_REACT_REMOVE]: [MessageStruct];\r\n  /** Emitted when a message is bulk deleted. */\r\n  [Events.MESSAGE_DELETE_BULK]: [string[]];\r\n  /** Emitted when a channel is created. */\r\n  [Events.CHANNEL_CREATE]: [Channel];\r\n  /** Emitted when a channel is deleted. */\r\n  [Events.CHANNEL_DELETE]: [Channel];\r\n  /** Emitted when a channel is updated. */\r\n  [Events.CHANNEL_UPDATE]: [Channel, Channel];\r\n  /** Emitted when a server is created. */\r\n  [Events.SERVER_CREATE]: [Server];\r\n  /** Emitted when a server is deleted. */\r\n  [Events.SERVER_DELETE]: [Server];\r\n  /** Emitted when a server is updated. */\r\n  [Events.SERVER_UPDATE]: [Server, Server];\r\n  /** Emitted when a server member joins. */\r\n  [Events.SERVER_MEMBER_JOIN]: [ServerMember];\r\n  /** Emitted when a server member leaves. */\r\n  [Events.SERVER_MEMBER_LEAVE]: [ServerMember];\r\n  /** Emitted when a server member is updated. */\r\n  [Events.SERVER_MEMBER_UPDATE]: [ServerMember, ServerMember];\r\n  /** Emitted when a user is updated. */\r\n  [Events.USER_UPDATE]: [User, User];\r\n  /** Emitted when a user is typing. */\r\n  [Events.TYPING_START]: [Channel, User];\r\n  /** Emitted when a user stops typing. */\r\n  [Events.TYPING_STOP]: [Channel, User];\r\n  /** Emitted when a group member joins. */\r\n  [Events.GROUP_JOIN]: [Channel, User];\r\n  /** Emitted when a group member leaves. */\r\n  [Events.GROUP_LEAVE]: [Channel, User];\r\n  /** Emitted when the client is ready. */\r\n  [Events.READY]: [client];\r\n  /** Emitted when an error occurs. */\r\n  [Events.ERROR]: [unknown];\r\n  /** Emitted when a raw event is received. */\r\n  [Events.RAW]: [unknown];\r\n  /** emitted when a role is created */\r\n  [Events.ROLE_CREATE]: [Role];\r\n  /** emitted when a role is deleted */\r\n  [Events.ROLE_DELETE]: [Role];\r\n  /** emitted when a role is updated */\r\n  [Events.ROLE_UPDATE]: [Role, Role];\r\n  /** emitted when a webhook is created */\r\n  [Events.WEBHOOKS_CREATE]: [WebhookCreateData];\r\n  /** emitted when a webhook is deleted */\r\n  [Events.WEBHOOKS_DELETE]: [WebhookDeleteData];\r\n  /** emitted when a webhook is updated */\r\n  [Events.WEBHOOKS_UPDATE]: [WebhookUpdateData];\r\n  /** emitted when a user's voice state is updated */\r\n  [Events.USER_VOICE_STATE_UPDATE]: [UserVoiceStateUpdateData];\r\n  /** emitted when a user joins a voice channel */\r\n  [Events.VOICE_CHANNEL_JOIN]: [VoiceChannelJoinData];\r\n  /** emitted when a user leaves a voice channel */\r\n  [Events.VOICE_CHANNEL_LEAVE]: [VoiceChannelLeaveData];\r\n}\r\n\r\n/**\r\n * Represents the options for configuring the client.\r\n */\r\nexport interface clientOptions {\r\n  /** Whether to fetch all members of a server. */\r\n  fetchMembers?: boolean;\r\n\r\n  /** events for the client to ignore.*/\r\n  ignoreEvents?: string[];\r\n\r\n  /** Whether to ignore bot messages. */\r\n  ignoreBots?: boolean;\r\n\r\n  /** wether to use X-Session-Token or X-Bot-Token*/\r\n  isBot?: boolean;\r\n\r\n  /** Configuration for REST API requests. */\r\n  rest?: {\r\n    /** The timeout for REST requests in milliseconds. */\r\n    timeout?: number;\r\n    /** The number of retries for failed REST requests. */\r\n    retries?: number;\r\n    /** URL for stoat API instance without trailing slash */\r\n    instanceURL?: string;\r\n    /** URL for stoat CDN instance without trailing slash */\r\n    instanceCDNURL?: string;\r\n  };\r\n\r\n  MessageCache?: {\r\n    /** The maximum size of the cache. */\r\n    maxSize?: number;\r\n  };\r\n\r\n  /** Configuration for WebSocket connections. */\r\n  ws?: {\r\n    /** The interval for sending heartbeats in milliseconds. */\r\n    heartbeatInterval?: number;\r\n    /** Whether to automatically reconnect on disconnection. */\r\n    reconnect?: boolean;\r\n    /** URL for stoat WebSocket instance without trailing slash */\r\n    instanceURL?: string;\r\n  };\r\n}\r\n\r\nexport interface VoiceClientOptions {\r\n  enabled?: boolean;\r\n  nodes?: VoiceNode[];\r\n}\r\n\r\nexport interface VoiceNode {\r\n  name: string;\r\n  lat: number;\r\n  lon: number;\r\n  public_url: string;\r\n}\r\n\r\n/**\r\n * Represents the base client that provides core functionality for interacting with the API.\r\n *\r\n * @extends EventEmitter\r\n */\r\nexport abstract class BaseClient extends EventEmitter {\r\n  /** The REST client for making API requests. */\r\n  readonly api: RestClient;\r\n\r\n  /** The CDN client for accessing media resources. */\r\n  readonly cdn: CDNClient;\r\n\r\n  /** The authentication token for the client. */\r\n  #token: string | null = null;\r\n\r\n  /** The options for configuring the client. */\r\n  options: clientOptions;\r\n\r\n  voiceOptions: VoiceClientOptions = { enabled: false };\r\n\r\n  /** Track current voice connection to prevent AlreadyConnected errors */\r\n  currentVoiceConnection: { channelId: string; playerId: string } | null = null;\r\n\r\n  /** Whether the client is a bot. */\r\n  bot = true;\r\n\r\n  /** Whether to use the default error handler */\r\n  #useDefaultErrorHandler = true;\r\n\r\n  /**\r\n   * Creates a new BaseClient instance.\r\n   *\r\n   * @param {clientOptions} [options={}] - The options for configuring the client.\r\n   */\r\n  constructor(options: clientOptions = {}) {\r\n    if (options.rest?.instanceURL) {\r\n      if (!options.rest?.instanceURL) {\r\n        console.error(\r\n          'instance URLs must be provided (REST) see docs at \"https://jade3375.github.io/stoatbot.js/interfaces/clientOptions.html\"',\r\n        );\r\n        process.exit(0);\r\n      } else {\r\n        console.warn(\r\n          \"You are connecting to a custom instance of Revolt. compatibility with StoatBot.js is not guaranteed.\",\r\n        );\r\n      }\r\n    }\r\n    super();\r\n    this.options = {\r\n      ...DEFAULT_CLIENT_OPTIONS,\r\n      ...options,\r\n    };\r\n    this.bot = this.options.isBot ?? true;\r\n    this.api = new RestClient(this);\r\n    this.cdn = new CDNClient(this);\r\n\r\n    // Set up default error handler to prevent unhandled error exceptions\r\n    this.on(\"error\", (error) => {\r\n      // Only use default handler if user hasn't added their own\r\n      if (this.#useDefaultErrorHandler && this.listenerCount(\"error\") === 1) {\r\n        console.error(\r\n          \"[stoatbot.js] Unhandled client error occurred. \" +\r\n            \"Consider adding an error listener to your client:\",\r\n          error,\r\n        );\r\n        console.error(\r\n          \"Example: client.on('error', (error) => { console.error('Bot error:', error); });\",\r\n        );\r\n      }\r\n    });\r\n\r\n    // Disable default error handler when user adds their own\r\n    this.on(\"newListener\", (event) => {\r\n      if (event === \"error\") {\r\n        this.#useDefaultErrorHandler = false;\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Emits a debug message.\r\n   *\r\n   * @param {unknown} msg - The debug message to emit.\r\n   */\r\n  debug(msg: unknown): void {\r\n    this.emit(Events.DEBUG, msg);\r\n  }\r\n\r\n  /**\r\n   * Sets the authentication token for the client.\r\n   *\r\n   * @param {string | null} token - The authentication token.\r\n   */\r\n  set token(token: string | null) {\r\n    this.#token = token;\r\n  }\r\n\r\n  /**\r\n   * Gets the authentication token for the client.\r\n   *\r\n   * @returns {string | null} The authentication token, or `null` if not set.\r\n   */\r\n  get token(): string | null {\r\n    return this.#token;\r\n  }\r\n}\r\n","import axios, { AxiosError, AxiosRequestConfig, AxiosResponse } from \"axios\";\r\nimport { BaseClient } from \"../client/baseClient\";\r\nimport { apiUrl, DEFAULT_CLIENT_OPTIONS } from \"../utils\";\r\nimport { version } from \"../../package.json\";\r\nimport { RateLimitQueue } from \"./restUtils/rateLimitQueue\";\r\nimport { ApiDiscoveryResponse } from \"../utils/types\";\r\n\r\nexport class RestClient {\r\n  private rateLimitQueue = new RateLimitQueue();\r\n  constructor(private readonly client: BaseClient) {}\r\n\r\n  /**\r\n   * Helper function to handle API requests.\r\n   * @param method The HTTP method (GET, POST, PATCH, PUT, DELETE).\r\n   * @param url The URL for the request.\r\n   * @param body The request body (if applicable).\r\n   * @param query Query parameters (if applicable).\r\n   * @returns The API response.\r\n   */\r\n  private async request<T>(\r\n    method: \"GET\" | \"POST\" | \"PATCH\" | \"PUT\" | \"DELETE\",\r\n    url: string,\r\n    body?: any,\r\n    query?: Record<string, string | number>,\r\n    retry?: boolean,\r\n  ): Promise<T> {\r\n    try {\r\n      if (!this.client.token) throw new Error(\"Token is required\");\r\n\r\n      const authHeader = this.client.bot ? \"X-Bot-Token\" : \"X-Session-Token\";\r\n      const config: AxiosRequestConfig & { url: string } = {\r\n        ...{\r\n          method,\r\n          url: `${this.client.options.rest?.instanceURL ? this.client.options.rest?.instanceURL : apiUrl}${url}`,\r\n          params: query,\r\n          data: body?.body,\r\n          headers: {\r\n            [authHeader]: this.client.token,\r\n            \"User-Agent\": `StoatBot.js/${version}`,\r\n          },\r\n        },\r\n        url: `${this.client.options.rest?.instanceURL ? this.client.options.rest?.instanceURL : apiUrl}${url}`,\r\n      };\r\n      if (process.env.NODE_ENV === \"DEV\") {\r\n        console.info(\"Request Body:\", body);\r\n        console.info(\"Request Query:\", query);\r\n        console.info(\"Request URL:\", config.url);\r\n      }\r\n      // Use the rate limit queue for all requests\r\n      const response: AxiosResponse<T> =\r\n        await this.rateLimitQueue.request<T>(config);\r\n      return response.data;\r\n    } catch (error) {\r\n      if (retry) throw typeof error;\r\n      if (error instanceof AxiosError) {\r\n        if (error.status && (error.status === 429 || error.status >= 500)) {\r\n          return this.retryRequest<T>(0, method, url, body, query);\r\n        }\r\n        if (error.status) {\r\n          if (process.env.NODE_ENV === \"DEV\") {\r\n            console.error(\"Error details:\", error);\r\n            console.error(\"Error response data:\", error.response?.data);\r\n            console.error(\"Error request config:\", error.config);\r\n            console.error(\"Error message:\", error.message);\r\n            console.error(\"Error URL:\", url);\r\n          }\r\n          throw new Error(\r\n            `API call failed with status ${error.status}: ${error.response?.statusText}`,\r\n          );\r\n        }\r\n      }\r\n      throw new Error(\r\n        `API call failed: ${error instanceof Error ? error.message : error}`,\r\n      );\r\n    }\r\n  }\r\n\r\n  async getConfig(): Promise<void> {\r\n    try {\r\n      const response: AxiosResponse<ApiDiscoveryResponse> = await axios.get(\r\n        `${this.client.options.rest?.instanceURL ? this.client.options.rest?.instanceURL : apiUrl}/`,\r\n      );\r\n      const config = response.data;\r\n      this.client.options.rest = {\r\n        ...this.client.options.rest,\r\n        instanceCDNURL: config.features.autumn.url,\r\n      };\r\n      this.client.options.ws = {\r\n        ...this.client.options.ws,\r\n        instanceURL: config.ws,\r\n      };\r\n      this.client.voiceOptions = {\r\n        ...config.features.livekit,\r\n      };\r\n    } catch (error) {\r\n      console.error(\"Failed to fetch configuration:\", error);\r\n      process.exit(1);\r\n    }\r\n  }\r\n\r\n  private async retryRequest<T>(\r\n    attempt: number = 0,\r\n    method: \"GET\" | \"POST\" | \"PATCH\" | \"PUT\" | \"DELETE\",\r\n    url: string,\r\n    body?: any,\r\n    query?: Record<string, string | number>,\r\n  ): Promise<T> {\r\n    if (attempt >= (this.client.options.rest?.retries ?? 3)) {\r\n      throw new Error(\"Max retries reached\");\r\n    }\r\n\r\n    try {\r\n      return await this.request<T>(method, url, body, query, true);\r\n    } catch (error) {\r\n      console.warn(`Attempt ${attempt + 1} failed:`, error);\r\n      await new Promise((resolve) =>\r\n        setTimeout(\r\n          resolve,\r\n          this.client.options.rest?.timeout ??\r\n            DEFAULT_CLIENT_OPTIONS.rest?.timeout,\r\n        ),\r\n      );\r\n      return this.retryRequest<T>(attempt + 1, method, url, body, query);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * GET request.\r\n   * @param url The URL for the request.\r\n   * @param query Query parameters (if applicable).\r\n   * @returns The API response.\r\n   */\r\n  async get<T>(\r\n    url: string,\r\n    query?: Record<string, string | number>,\r\n  ): Promise<T> {\r\n    return this.request<T>(\"GET\", url, undefined, query);\r\n  }\r\n\r\n  /**\r\n   * POST request.\r\n   * @param url The URL for the request.\r\n   * @param body The request body.\r\n   * @param query Query parameters (if applicable).\r\n   * @returns The API response.\r\n   */\r\n  async post<T>(\r\n    url: string,\r\n    body?: any,\r\n    query?: Record<string, string | number>,\r\n  ): Promise<T> {\r\n    return this.request<T>(\"POST\", url, body, query);\r\n  }\r\n\r\n  /**\r\n   * PATCH request.\r\n   * @param url The URL for the request.\r\n   * @param body The request body.\r\n   * @param query Query parameters (if applicable).\r\n   * @returns The API response.\r\n   */\r\n  async patch<T>(\r\n    url: string,\r\n    body: any,\r\n    query?: Record<string, string | number>,\r\n  ): Promise<T> {\r\n    return this.request<T>(\"PATCH\", url, body, query);\r\n  }\r\n\r\n  /**\r\n   * PUT request.\r\n   * @param url The URL for the request.\r\n   * @param body The request body.\r\n   * @param query Query parameters (if applicable).\r\n   * @returns The API response.\r\n   */\r\n  async put<T>(\r\n    url: string,\r\n    body?: any,\r\n    query?: Record<string, string | number>,\r\n  ): Promise<T> {\r\n    return this.request<T>(\"PUT\", url, body, query);\r\n  }\r\n\r\n  /**\r\n   * DELETE request.\r\n   * @param url The URL for the request.\r\n   * @param query Query parameters (if applicable).\r\n   * @returns The API response.\r\n   */\r\n  async delete<T>(\r\n    url: string,\r\n    body?: any,\r\n    query?: Record<string, string | number>,\r\n  ): Promise<T> {\r\n    return this.request<T>(\"DELETE\", url, body, query);\r\n  }\r\n}\r\n","{\r\n  \"name\": \"stoatbot.js\",\r\n  \"version\": \"0.4.5\",\r\n  \"description\": \"A Stoat bot client used to interact with the stoat api for Node.js, written in TypeScript.\",\r\n  \"main\": \"./dist/index.js\",\r\n  \"module\": \"./dist/index.mjs\",\r\n  \"types\": \"./dist/index.d.ts\",\r\n  \"files\": [\r\n    \"dist\"\r\n  ],\r\n  \"engines\": {\r\n    \"node\": \">=21.0.0\"\r\n  },\r\n  \"repository\": \"https://github.com/Jade3375/stoatbot.js\",\r\n  \"keywords\": [\r\n    \"revoltjs\",\r\n    \"revolt.js\",\r\n    \"stoatjs\",\r\n    \"stoat.js\",\r\n    \"bot\",\r\n    \"client\",\r\n    \"stoatbot\",\r\n    \"stoat\",\r\n    \"typescript\"\r\n  ],\r\n  \"homepage\": \"https://jade3375.github.io/stoatbot.js/\",\r\n  \"author\": \"Jade3375\",\r\n  \"license\": \"MIT\",\r\n  \"packageManager\": \"yarn@4.9.1\",\r\n  \"devDependencies\": {\r\n    \"@mxssfd/typedoc-theme\": \"^1.1.7\",\r\n    \"@types/node\": \"^22.15.2\",\r\n    \"@types/ws\": \"^8.18.1\",\r\n    \"cross-env\": \"^10.1.0\",\r\n    \"eslint-config-prettier\": \"^10.1.2\",\r\n    \"prettier\": \"^3.5.3\",\r\n    \"rimraf\": \"^6.0.1\",\r\n    \"tsup\": \"^8.4.0\",\r\n    \"typedoc\": \"^0.28.3\",\r\n    \"typedoc-plugin-extras\": \"^4.0.0\",\r\n    \"typedoc-plugin-mdn-links\": \"^5.0.1\",\r\n    \"typedoc-plugin-merge-modules\": \"^7.0.0\",\r\n    \"typescript\": \"^5.8.3\"\r\n  },\r\n  \"dependencies\": {\r\n    \"@livekit/rtc-node\": \"^0.13.22\",\r\n    \"axios\": \"^1.12.2\",\r\n    \"form-data\": \"^4.0.2\",\r\n    \"revolt-api\": \"^0.8.9\",\r\n    \"ws\": \"^8.18.1\"\r\n  },\r\n  \"scripts\": {\r\n    \"lint\": \"eslint . --ext .ts --fix\",\r\n    \"build\": \"yarn clean && yarn tsup ./src/index.ts --format cjs,esm --clean --dts --sourcemap\",\r\n    \"start\": \"yarn build && yarn node --enable-source-maps dist/index.js\",\r\n    \"testClient\": \"yarn test:build && yarn node --enable-source-maps dist/test.js\",\r\n    \"testClient:debug\": \"yarn test:build && cross-env NODE_ENV=DEV yarn node --enable-source-maps dist/test.js\",\r\n    \"clean\": \"rimraf dist\",\r\n    \"test:docs\": \"rimraf docs && yarn typedoc --options static/typedoc.json\",\r\n    \"test:build\": \"yarn clean && tsc -p tsconfig.json\"\r\n  }\r\n}\r\n","import axios, { AxiosRequestConfig, AxiosResponse } from \"axios\";\r\n\r\ninterface RateLimitInfo {\r\n  limit: number;\r\n  remaining: number;\r\n  resetAfter: number; // epoch ms\r\n  bucket: string;\r\n  resetIn: number; // ms until reset\r\n}\r\n\r\ninterface BucketState extends RateLimitInfo {\r\n  queue: Array<() => void>;\r\n  resetTimeout?: NodeJS.Timeout;\r\n  lastPath: string;\r\n}\r\n\r\nexport class RateLimitQueue {\r\n  private bucketMap: Map<string, BucketState> = new Map();\r\n  private pathToBucket: Map<string, string> = new Map();\r\n\r\n  async request<T = any>(\r\n    config: AxiosRequestConfig & { url: string },\r\n  ): Promise<AxiosResponse<T>> {\r\n    const path = config.url!;\r\n    const bucketId = this.pathToBucket.get(path);\r\n    let bucket = bucketId ? this.bucketMap.get(bucketId) : undefined;\r\n\r\n    if (bucket && bucket.remaining <= 0 && Date.now() < bucket.resetAfter) {\r\n      // Rate limited, queue the request\r\n      return new Promise<AxiosResponse<T>>((resolve, reject) => {\r\n        bucket!.queue.push(async () => {\r\n          try {\r\n            const res = await this._doRequest<T>(config, path);\r\n            resolve(res);\r\n          } catch (e) {\r\n            console.error(e);\r\n          }\r\n        });\r\n      });\r\n    } else {\r\n      // Not rate limited, do the request\r\n      return this._doRequest<T>(config, path);\r\n    }\r\n  }\r\n\r\n  private async _doRequest<T>(\r\n    config: AxiosRequestConfig,\r\n    path: string,\r\n  ): Promise<AxiosResponse<T>> {\r\n    const response = await axios(config);\r\n    this._updateRateLimit(path, response);\r\n    return response;\r\n  }\r\n\r\n  private _updateRateLimit(path: string, response: AxiosResponse) {\r\n    const headers = response.headers;\r\n    const limit = parseInt(headers[\"x-ratelimit-limit\"]);\r\n    const remaining = parseInt(headers[\"x-ratelimit-remaining\"]);\r\n    const resetAfter =\r\n      parseFloat(headers[\"x-ratelimit-reset-after\"]) * 1000 + Date.now();\r\n    const bucket = headers[\"x-ratelimit-bucket\"];\r\n    const resetIn = parseInt(headers[\"x-ratelimit-reset-after\"]);\r\n\r\n    if (!bucket) return;\r\n    this.pathToBucket.set(path, bucket);\r\n    let state = this.bucketMap.get(bucket);\r\n    if (!state) {\r\n      state = {\r\n        limit,\r\n        remaining,\r\n        resetAfter,\r\n        bucket,\r\n        resetIn,\r\n        queue: [],\r\n        lastPath: path,\r\n      };\r\n      this.bucketMap.set(bucket, state);\r\n    } else {\r\n      state.limit = limit;\r\n      state.remaining = remaining;\r\n      state.resetAfter = resetAfter;\r\n      state.lastPath = path;\r\n    }\r\n\r\n    if (remaining <= 0) {\r\n      if (state.resetTimeout) clearTimeout(state.resetTimeout);\r\n      const delay = resetIn;\r\n      state.resetTimeout = setTimeout(() => {\r\n        state.remaining = state.limit;\r\n        state.resetTimeout = undefined;\r\n        // Process queued requests\r\n        while (state.queue.length > 0 && state.remaining > 0) {\r\n          const fn = state.queue.shift();\r\n          if (fn) {\r\n            state.remaining--;\r\n            fn();\r\n          }\r\n        }\r\n      }, delay);\r\n    }\r\n  }\r\n}\r\n","import axios, { AxiosError, AxiosRequestConfig, AxiosResponse } from \"axios\";\r\nimport { BaseClient } from \"../client/baseClient\";\r\nimport { DEFAULT_CLIENT_OPTIONS } from \"../utils\";\r\nimport { version } from \"../../package.json\";\r\nimport FormData from \"form-data\";\r\nimport { RateLimitQueue } from \"./restUtils/rateLimitQueue\";\r\nexport class CDNClient {\r\n  private rateLimitQueue = new RateLimitQueue();\r\n  constructor(private readonly client: BaseClient) {}\r\n\r\n  /**\r\n   * Helper function to handle API requests.\r\n   * @param method The HTTP method (GET, POST, PATCH, PUT, DELETE).\r\n   * @param url The URL for the request.\r\n   * @param body The request body (if applicable).\r\n   * @param query Query parameters (if applicable).\r\n   * @returns The API response.\r\n   */\r\n  private async request<T>(\r\n    method: \"GET\" | \"POST\" | \"PATCH\" | \"PUT\" | \"DELETE\",\r\n    url: string,\r\n    data: FormData,\r\n    query?: Record<string, string | number>,\r\n    retry?: boolean,\r\n  ): Promise<T> {\r\n    try {\r\n      if (!this.client.token) throw new Error(\"Token is required\");\r\n\r\n      const authHeader = this.client.bot ? \"X-Bot-Token\" : \"X-Session-Token\";\r\n      const config: AxiosRequestConfig & { url: string } = {\r\n        ...{\r\n          method,\r\n          url: `${this.client.options.rest?.instanceCDNURL}${url}`,\r\n          params: query,\r\n          data,\r\n          maxBodyLength: Infinity,\r\n          headers: {\r\n            [authHeader]: this.client.token,\r\n            \"Content-Type\": \"multipart/form-data\",\r\n            \"User-Agent\": `StoatBot.js/${version}`,\r\n            ...data.getHeaders(),\r\n          },\r\n        },\r\n        url: `${this.client.options.rest?.instanceCDNURL}${url}`,\r\n      };\r\n\r\n      if (process.env.NODE_ENV === \"DEV\") {\r\n        console.info(\"Request Data:\", data);\r\n        console.info(\"Request Query:\", query);\r\n        console.info(\"Request URL:\", config.url);\r\n      }\r\n\r\n      // Use the rate limit queue for all requests\r\n      const response: AxiosResponse<T> =\r\n        await this.rateLimitQueue.request<T>(config);\r\n      return response.data;\r\n    } catch (error) {\r\n      if (retry) throw typeof error;\r\n      if (error instanceof AxiosError) {\r\n        if (error.status && (error.status === 429 || error.status >= 500)) {\r\n          return this.retryRequest<T>(0, method, url, data, query);\r\n        }\r\n        if (error.status) {\r\n          console.error(`API call failed with status ${error.status}:`, error);\r\n          throw new Error(\r\n            `API call failed with status ${error.status}: ${error.message}`,\r\n          );\r\n        }\r\n      }\r\n      throw new Error(\r\n        `API call failed: ${error instanceof Error ? error.message : error}`,\r\n      );\r\n    }\r\n  }\r\n\r\n  private async retryRequest<T>(\r\n    attempt: number = 0,\r\n    method: \"GET\" | \"POST\" | \"PATCH\" | \"PUT\" | \"DELETE\",\r\n    url: string,\r\n    body?: any,\r\n    query?: Record<string, string | number>,\r\n  ): Promise<T> {\r\n    if (attempt >= (this.client.options.rest?.retries ?? 3)) {\r\n      throw new Error(\"Max retries reached\");\r\n    }\r\n\r\n    try {\r\n      return await this.request<T>(method, url, body, query, true);\r\n    } catch (error) {\r\n      console.warn(`Attempt ${attempt + 1} failed:`, error);\r\n      await new Promise((resolve) =>\r\n        setTimeout(\r\n          resolve,\r\n          this.client.options.rest?.timeout ??\r\n            DEFAULT_CLIENT_OPTIONS.rest?.timeout,\r\n        ),\r\n      );\r\n      return this.retryRequest<T>(attempt + 1, method, url, body, query);\r\n    }\r\n  }\r\n  /**\r\n   * POST request.\r\n   * @param url The URL for the request.\r\n   * @param data The request body.\r\n   * @returns The API response.\r\n   */\r\n  async post<T>(url: string, data: FormData): Promise<T> {\r\n    return this.request<T>(\"POST\", url, data);\r\n  }\r\n}\r\n","import type { client } from \"../client\";\r\n\r\n/**\r\n * Represents the base class for all event handlers.\r\n * All event handlers must extend this class and implement the `handle` method.\r\n *  @private\r\n */\r\nexport abstract class Event {\r\n  /**\r\n   * Creates a new Event instance.\r\n   *\r\n   * @param {client} client - The client instance.\r\n   */\r\n  constructor(protected readonly client: client) {}\r\n\r\n  /**\r\n   * Handles the event logic.\r\n   * This method must be implemented by subclasses to define the behavior for the specific event.\r\n   *\r\n   * @param {unknown} data - The data associated with the event.\r\n   * @returns {Promise<unknown | void>} A promise that resolves with the result of the event handling or `void`.\r\n   */\r\n  abstract handle(data: unknown): Awaited<unknown | void>;\r\n}\r\n\r\nexport { Events } from \"../../utils/constants\";\r\nexport type * as API from \"revolt-api\";\r\n","import { Event, Events } from \"./event\";\r\n\r\n/**\r\n * Represents the event handler for bulk message deletions.\r\n * @private\r\n * @extends Event\r\n */\r\nexport class BulkMessageDelete extends Event {\r\n  /**\r\n   * Handles the bulk message delete event.\r\n   *\r\n   * @param {{ ids: string[] }} data - The data for the event, containing the IDs of the deleted messages.\r\n   */\r\n  handle(data: { ids: string[] }) {\r\n    // TODO: Get cached messages\r\n    this.client.emit(Events.MESSAGE_DELETE_BULK, data.ids);\r\n  }\r\n}\r\n","import { Event, API, Events } from \"./event\";\r\n\r\n/**\r\n * Represents the event handler for channel creation.\r\n * @private\r\n * @extends Event\r\n */\r\nexport class ChannelCreate extends Event {\r\n  /**\r\n   * Handles the channel creation event.\r\n   *\r\n   * @param {API.Channel} data - The raw data for the created channel from the API.\r\n   * @returns {Promise<{ channel: unknown }>} A promise that resolves with the created channel.\r\n   * @private\r\n   */\r\n  async handle(data: API.Channel): Promise<unknown> {\r\n    const channel = this.client.channels._add(data);\r\n\r\n    if (channel) {\r\n      if (channel.inServer()) {\r\n        const server =\r\n          channel.server ?? (await this.client.servers.fetch(channel.serverId));\r\n        server.channels.cache.set(channel.id, channel);\r\n      }\r\n      this.client.emit(Events.CHANNEL_CREATE, channel);\r\n    }\r\n\r\n    return { channel };\r\n  }\r\n}\r\n","import { Event, Events } from \"./event\";\r\n\r\n/**\r\n * Represents the event handler for channel deletion.\r\n * @private\r\n * @extends Event\r\n */\r\nexport class ChannelDelete extends Event {\r\n  /**\r\n   * Handles the channel deletion event.\r\n   *\r\n   * @param {{ id: string }} data - The data for the event, containing the ID of the deleted channel.\r\n   * @returns {{ channel: unknown }} An object containing the deleted channel, or `undefined` if not found.\r\n   */\r\n  handle(data: { id: string }): unknown {\r\n    const channel = this.client.channels.cache.get(data.id);\r\n\r\n    if (channel) {\r\n      if (channel.inServer()) {\r\n        channel.server?.channels.cache.delete(channel.id);\r\n      }\r\n      this.client.emit(Events.CHANNEL_DELETE, channel);\r\n    }\r\n\r\n    return { channel };\r\n  }\r\n}\r\n","import { Event, Events } from \"./event\";\r\n\r\n/**\r\n * Represents the event handler for a user joining a group channel.\r\n * @private\r\n * @extends Event\r\n */\r\nexport class ChannelGroupJoin extends Event {\r\n  /**\r\n   * Handles the group channel join event.\r\n   *\r\n   * @param {{ id: string; user: string }} data - The data for the event, containing the channel ID and user ID.\r\n   * @returns {Promise<{ channel: unknown; user: unknown }>} A promise that resolves with the updated channel and user.\r\n   */\r\n  async handle(data: { id: string; user: string }): Promise<unknown> {\r\n    const channel = this.client.channels.cache.get(data.id);\r\n    const user = await this.client.users.fetch(data.user, { force: false });\r\n\r\n    if (channel?.isGroup()) {\r\n      channel.users.set(user.id, user);\r\n      this.client.emit(Events.GROUP_JOIN, channel, user);\r\n    }\r\n\r\n    return { channel, user };\r\n  }\r\n}\r\n","import { Event, Events } from \"./event\";\r\n\r\n/**\r\n * Represents the event handler for a user leaving a group channel.\r\n * @private\r\n * @extends Event\r\n */\r\nexport class ChannelGroupLeave extends Event {\r\n  /**\r\n   * Handles the group channel leave event.\r\n   *\r\n   * @param {{ id: string; user: string }} data - The data for the event, containing the channel ID and user ID.\r\n   * @returns {Promise<{ channel: unknown; user: unknown }>} A promise that resolves with the updated channel and user.\r\n   */\r\n  async handle(data: { id: string; user: string }): Promise<unknown> {\r\n    const channel = this.client.channels.cache.get(data.id);\r\n    const user = await this.client.users.fetch(data.user, { force: false });\r\n\r\n    if (channel?.isGroup()) {\r\n      channel.users.delete(data.user);\r\n      this.client.emit(Events.GROUP_LEAVE, channel, user);\r\n    }\r\n\r\n    return { channel, user };\r\n  }\r\n}\r\n","import { Event, Events } from \"./event\";\r\n\r\n/**\r\n * Represents the event handler for when a user starts typing in a channel.\r\n * @private\r\n * @extends Event\r\n */\r\nexport class ChannelStartTyping extends Event {\r\n  /**\r\n   * Handles the typing start event.\r\n   *\r\n   * @param {{ id: string; user: string }} data - The data for the event, containing the channel ID and user ID.\r\n   * @returns {{ channel: unknown; user: unknown }} An object containing the channel and user involved in the event.\r\n   */\r\n  handle(data: { id: string; user: string }): unknown {\r\n    const channel = this.client.channels.cache.get(data.id);\r\n    const user = this.client.users.cache.get(data.user);\r\n\r\n    if (channel?.isText() && user) {\r\n      this.client.emit(Events.TYPING_START, channel, user);\r\n    }\r\n\r\n    return { channel, user };\r\n  }\r\n}\r\n","import { Event, Events } from \"./event\";\r\n\r\n/**\r\n * Represents the event handler for when a user stops typing in a channel.\r\n * @private\r\n * @extends Event\r\n */\r\nexport class ChannelStopTyping extends Event {\r\n  /**\r\n   * Handles the typing stop event.\r\n   *\r\n   * @param {{ id: string; user: string }} data - The data for the event, containing the channel ID and user ID.\r\n   * @returns {{ channel: unknown; user: unknown }} An object containing the channel and user involved in the event.\r\n   */\r\n  handle(data: { id: string; user: string }): unknown {\r\n    const channel = this.client.channels.cache.get(data.id);\r\n    const user = this.client.users.cache.get(data.user);\r\n\r\n    if (channel?.isText() && user) {\r\n      this.client.emit(Events.TYPING_STOP, channel, user);\r\n    }\r\n\r\n    return { channel, user };\r\n  }\r\n}\r\n","import { Event, API, Events } from \"./event\";\r\n\r\n/**\r\n * Represents the event handler for channel updates.\r\n * @private\r\n * @extends Event\r\n */\r\nexport class ChannelUpdate extends Event {\r\n  /**\r\n   * Handles the channel update event.\r\n   *\r\n   * @param {{ id: string; data: API.Channel; clear: API.FieldsChannel }} data - The data for the event, containing the channel ID, updated data, and fields to clear.\r\n   * @returns {void}\r\n   */\r\n  handle(data: {\r\n    id: string;\r\n    data: API.Channel;\r\n    clear: API.FieldsChannel;\r\n  }): void {\r\n    const channel = this.client.channels.cache.get(data.id);\r\n    const oldChannel = channel?._update(data.data);\r\n\r\n    if (channel && oldChannel && !channel.equals(oldChannel)) {\r\n      this.client.emit(Events.CHANNEL_UPDATE, oldChannel, channel);\r\n    }\r\n  }\r\n}\r\n","import { Event, API, Events } from \"./event\";\r\nimport { SYSTEM_USER_ID } from \"../../utils/constants\";\r\n\r\n/**\r\n * Represents the event handler for incoming messages.\r\n *\r\n * @private\r\n * @extends Event\r\n */\r\nexport class Message extends Event {\r\n  /**\r\n   * Handles the message event.\r\n   *\r\n   * @param {API.Message} data - The raw data for the message from the API.\r\n   * @returns {Promise<{ message: unknown }>} A promise that resolves with the created message, or an empty object if the channel is not text-based.\r\n   * @private\r\n   */\r\n  async handle(data: API.Message): Promise<unknown> {\r\n    if (data.system) {\r\n      return {};\r\n    }\r\n    const channel = this.client.channels.cache.get(data.channel);\r\n\r\n    if (channel?.isText()) {\r\n      if (data.user?.bot && this.client.options.ignoreBots) {\r\n        return {};\r\n      }\r\n      const message = channel.messages._add(data);\r\n      if (data.author !== SYSTEM_USER_ID && !data.webhook) {\r\n        await this.client.users.fetch(data.author, { force: false });\r\n      }\r\n\r\n      this.client.emit(Events.MESSAGE, message);\r\n\r\n      return { message };\r\n    }\r\n\r\n    return {};\r\n  }\r\n}\r\n","import { Event, Events } from \"./event\";\r\n\r\n/**\r\n * Represents the event handler for message deletions.\r\n * @private\r\n * @extends Event\r\n */\r\nexport class MessageDelete extends Event {\r\n  /**\r\n   * Handles the message deletion event.\r\n   *\r\n   * @param {{ id: string; channel: string }} data - The data for the event, containing the message ID and channel ID.\r\n   * @returns {{ message: unknown } | {}} An object containing the deleted message, or an empty object if the channel is not text-based or the message is not found.\r\n   */\r\n  handle(data: { id: string; channel: string }): unknown {\r\n    const channel = this.client.channels.cache.get(data.channel);\r\n\r\n    if (channel?.isText()) {\r\n      const message = channel.messages.cache.get(data.id);\r\n\r\n      if (message) {\r\n        channel.messages._remove(message.id);\r\n        this.client.emit(Events.MESSAGE_DELETE, message);\r\n      }\r\n\r\n      return { message };\r\n    }\r\n\r\n    return {};\r\n  }\r\n}\r\n","import { Event, API, Events } from \"./event\";\r\n\r\n/**\r\n * Represents the event handler for message updates.\r\n * @private\r\n * @extends Event\r\n */\r\nexport class MessageUpdate extends Event {\r\n  /**\r\n   * Handles the message update event.\r\n   *\r\n   * @param {{ id: string; channel: string; data: API.Message }} data - The data for the event, containing the message ID, channel ID, and updated message data.\r\n   * @returns {void}\r\n   */\r\n  handle(data: { id: string; channel: string; data: API.Message }): void {\r\n    const channel = this.client.channels.cache.get(data.channel);\r\n\r\n    if (!channel?.isText()) return;\r\n\r\n    const message = channel?.messages.cache.get(data.id);\r\n    const oldMessage = message?._update(data.data);\r\n\r\n    if (oldMessage && message && !message.equals(oldMessage)) {\r\n      this.client.emit(Events.MESSAGE_UPDATE, oldMessage, message);\r\n    }\r\n  }\r\n}\r\n","import { Event, API, Events } from \"./event\";\r\n\r\n/**\r\n * Represents the event handler for server creation.\r\n * @private\r\n * @extends Event\r\n */\r\nexport class ServerCreate extends Event {\r\n  /**\r\n   * Handles the server creation event.\r\n   *\r\n   * @param {API.Server} data - The raw data for the created server from the API.\r\n   * @returns {Promise<void>} A promise that resolves when the server is added and members are optionally fetched.\r\n   * @private\r\n   */\r\n  async handle(data: API.Server): Promise<void> {\r\n    const server = this.client.servers._add(data);\r\n\r\n    if (this.client.options.fetchMembers) {\r\n      await server.members.fetch();\r\n    }\r\n\r\n    this.client.emit(Events.SERVER_CREATE, server);\r\n  }\r\n}\r\n","import { Event, API, Events } from \"./event\";\r\n\r\n/**\r\n * Represents the event handler for server deletion.\r\n * @private\r\n * @extends Event\r\n */\r\nexport class ServerDelete extends Event {\r\n  /**\r\n   * Handles the server deletion event.\r\n   *\r\n   * @param {API.Server} data - The raw data for the deleted server from the API.\r\n   * @returns {{ server: unknown }} An object containing the deleted server, or `undefined` if not found.\r\n   */\r\n  handle(data: API.Server): unknown {\r\n    const server = this.client.servers.cache.get(data._id);\r\n\r\n    if (server) {\r\n      this.client.servers._remove(server.id);\r\n      this.client.emit(Events.SERVER_DELETE, server);\r\n    }\r\n\r\n    return { server };\r\n  }\r\n}\r\n","import { Event, Events } from \"./event\";\r\n\r\n/**\r\n * Represents the event handler for a member joining a server.\r\n * @private\r\n * @extends Event\r\n */\r\nexport class ServerMemberJoin extends Event {\r\n  /**\r\n   * Handles the server member join event.\r\n   *\r\n   * @param {{ id: string; user: string }} data - The data for the event, containing the server ID and user ID.\r\n   * @returns {Promise<{ member: unknown }>} A promise that resolves with the joined member.\r\n   */\r\n  async handle(data: { id: string; user: string }): Promise<unknown> {\r\n    let server = this.client.servers.cache.get(data.id);\r\n\r\n    if (!server) {\r\n      server = await this.client.servers.fetch(data.id);\r\n      this.client.emit(Events.SERVER_CREATE, server);\r\n    }\r\n\r\n    const member = await server.members.fetch(data.user);\r\n\r\n    server.members.cache.set(member.id, member);\r\n\r\n    this.client.emit(Events.SERVER_MEMBER_JOIN, member);\r\n\r\n    return { member };\r\n  }\r\n}\r\n","import { Event, Events } from \"./event\";\r\n\r\n/**\r\n * Represents the event handler for a member leaving a server.\r\n * @private\r\n * @extends Event\r\n */\r\nexport class ServerMemberLeave extends Event {\r\n  /**\r\n   * Handles the server member leave event.\r\n   *\r\n   * @param {{ id: string; user: string }} data - The data for the event, containing the server ID and user ID.\r\n   * @returns {{ server: unknown; member?: unknown }} An object containing the server and the member who left, or just the server if the member is not found.\r\n   */\r\n  handle(data: { id: string; user: string }): unknown {\r\n    const server = this.client.servers.cache.get(data.id);\r\n\r\n    if (server) {\r\n      const member = server.members.cache.get(data.user);\r\n\r\n      if (member) {\r\n        server.members._remove(member.id);\r\n        this.client.emit(Events.SERVER_MEMBER_LEAVE, member);\r\n      }\r\n\r\n      return { server, member };\r\n    }\r\n\r\n    return { server };\r\n  }\r\n}\r\n","import { Role } from \"../../struct\";\r\nimport { Event, API, Events } from \"./event\";\r\n\r\n/**\r\n * Represents the event handler for server member updates.\r\n * @private\r\n * @extends Event\r\n */\r\nexport class ServerMemberUpdate extends Event {\r\n  /**\r\n   * Handles the server member update event.\r\n   *\r\n   * @param {{ id: string; data: API.Member }} data - The data for the event, containing the server ID and updated member data.\r\n   * @returns {void}\r\n   */\r\n  handle(data: {\r\n    id: { server: string; user: string };\r\n    data: API.Member;\r\n  }): void {\r\n    const updateData = {\r\n      ...data.data,\r\n      _id: { server: data.id.server, user: data.id.user },\r\n    };\r\n    const server = this.client.servers.cache.get(data.id.server);\r\n    const member = server?.members.cache.get(data.id.user);\r\n    const oldMember = member?._update(updateData);\r\n\r\n    if (\r\n      oldMember &&\r\n      member &&\r\n      (!member.equals(oldMember) ||\r\n        areRolesDifferent(member.roles, oldMember.roles))\r\n    ) {\r\n      this.client.emit(Events.SERVER_MEMBER_UPDATE, oldMember, member);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Compares the role IDs of two members and determines if they are different.\r\n *\r\n * @param {API.Role[]} rolesA - The roles of the first member.\r\n * @param {API.Role[]} rolesB - The roles of the second member.\r\n * @returns {boolean} - Returns true if the roles are different, otherwise false.\r\n */\r\nfunction areRolesDifferent(rolesA: Role[], rolesB: Role[]): boolean {\r\n  const idsA = rolesA.map((role) => role.id).sort();\r\n  const idsB = rolesB.map((role) => role.id).sort();\r\n\r\n  return (\r\n    idsA.length !== idsB.length ||\r\n    !idsA.every((id, index) => id === idsB[index])\r\n  );\r\n}\r\n","import { Event, Events } from \"./event\";\r\n\r\n/**\r\n * Represents the event handler for server role deletions.\r\n * @private\r\n * @extends Event\r\n */\r\nexport class ServerRoleDelete extends Event {\r\n  /**\r\n   * Handles the server role deletion event.\r\n   *\r\n   * @param {{ id: string; role_id: string }} data - The data for the event, containing the server ID and role ID.\r\n   * @returns {{ role: unknown } | {}} An object containing the deleted role, or an empty object if the role or server is not found.\r\n   */\r\n  handle(data: { id: string; role_id: string }): unknown {\r\n    const server = this.client.servers.cache.get(data.id);\r\n\r\n    if (server) {\r\n      const role = server.roles.cache.get(data.role_id);\r\n\r\n      if (role) {\r\n        server.roles._remove(role.id);\r\n        this.client.emit(Events.ROLE_DELETE, role);\r\n      }\r\n\r\n      return { role };\r\n    }\r\n\r\n    return {};\r\n  }\r\n}\r\n","import { Event, API, Events } from \"./event\";\r\nimport type { Role as APIRole } from \"revolt-api\";\r\n\r\n/**\r\n * Represents the event handler for server role updates.\r\n * @private\r\n * @extends Event\r\n */\r\nexport class ServerRoleUpdate extends Event {\r\n  /**\r\n   * Handles the server role update event.\r\n   *\r\n   * @param {{ id: string; role_id: string; data: API.Role & { _id: string }; clear: API.FieldsRole[] }} data - The data for the event, containing the server ID, role ID, updated role data, and fields to clear.\r\n   * @returns {void}\r\n   */\r\n  async handle(data: {\r\n    id: string;\r\n    role_id: string;\r\n    data: API.Role & { _id: string };\r\n    clear: API.FieldsRole[];\r\n  }): Promise<void> {\r\n    const server = this.client.servers.cache.get(data.id);\r\n\r\n    if (!server) return;\r\n\r\n    let role = server.roles.cache.get(data.role_id);\r\n    const oldRole = role?._update(data.data, data.clear);\r\n\r\n    if (!oldRole && !role) {\r\n      await Promise.all(\r\n        Object.values(data.data).map(async (raw) => {\r\n          if (raw && typeof raw === \"object\") {\r\n            server.roles._add({\r\n              name: \"\",\r\n              permissions: {\r\n                a: 0,\r\n                d: 0,\r\n              },\r\n              ...raw,\r\n              id: data.role_id,\r\n            });\r\n          }\r\n        }),\r\n      );\r\n      role = server.roles.cache.get(data.role_id)!;\r\n    }\r\n\r\n    if (role && oldRole && !role.equals(oldRole)) {\r\n      this.client.emit(Events.ROLE_UPDATE, oldRole, role);\r\n    }\r\n  }\r\n}\r\n","import { Event, API, Events } from \"./event\";\r\n\r\n/**\r\n * Represents the event handler for server updates.\r\n * @private\r\n * @extends Event\r\n */\r\nexport class ServerUpdate extends Event {\r\n  /**\r\n   * Handles the server update event.\r\n   *\r\n   * @param {{ id: string; data: API.Server; clear: API.FieldsServer[] }} data - The data for the event, containing the server ID, updated server data, and fields to clear.\r\n   * @returns {void}\r\n   */\r\n  handle(data: {\r\n    id: string;\r\n    data: API.Server;\r\n    clear: API.FieldsServer[];\r\n  }): void {\r\n    const server = this.client.servers.cache.get(data.id);\r\n    const oldServer = server?._update(data.data, data.clear);\r\n\r\n    if (oldServer && server && !oldServer.equals(server)) {\r\n      this.client.emit(Events.SERVER_UPDATE, oldServer, server);\r\n    }\r\n  }\r\n}\r\n","import { Event, API, Events } from \"./event\";\r\n\r\n/**\r\n * Represents the event handler for user updates.\r\n * @private\r\n * @extends Event\r\n */\r\nexport class UserUpdate extends Event {\r\n  /**\r\n   * Handles the user update event.\r\n   *\r\n   * @param {{ id: string; data: API.User; clear: API.FieldsUser[] }} data - The data for the event, containing the user ID, updated user data, and fields to clear.\r\n   * @returns {void}\r\n   */\r\n  handle(data: { id: string; data: API.User; clear: API.FieldsUser[] }): void {\r\n    const user =\r\n      data.id === this.client.user!.id\r\n        ? this.client.user\r\n        : this.client.users.cache.get(data.id);\r\n    const oldUser = user?._update(data.data, data.clear);\r\n\r\n    if (user && oldUser && !user.equals(oldUser)) {\r\n      this.client.emit(Events.USER_UPDATE, oldUser, user);\r\n    }\r\n  }\r\n}\r\n","import { Event, API, Events } from \"./event\";\r\n\r\n/**\r\n * Represents the data for a message reaction event.\r\n */\r\nexport interface MessageReactData {\r\n  /** The ID of the message being reacted to. */\r\n  id: string;\r\n\r\n  /** The ID of the channel containing the message. */\r\n  channel_id: string;\r\n\r\n  /** The ID of the user who reacted. */\r\n  user_id: string;\r\n\r\n  /** The ID of the emoji used for the reaction. */\r\n  emoji_id: string;\r\n}\r\n\r\n/**\r\n * Represents the event handler for message reactions.\r\n * @private\r\n * @extends Event\r\n */\r\nexport class MessageReact extends Event {\r\n  /**\r\n   * Handles the message reaction event.\r\n   *\r\n   * @param {MessageReactData} data - The data for the event, containing the message ID, channel ID, user ID, and emoji ID.\r\n   * @returns {Promise<unknown>} A promise that resolves with an empty object.\r\n   */\r\n  async handle(data: MessageReactData): Promise<unknown> {\r\n    const channel = this.client.channels.cache.get(data.channel_id);\r\n\r\n    if (channel?.isText()) {\r\n      let message = channel.messages.cache.get(data.id)\r\n        ? channel.messages.cache.get(data.id)\r\n        : await channel.messages.fetch(data.id);\r\n\r\n      if (message) {\r\n        if (message.reactions.get(data.emoji_id)?.indexOf(data.user_id)) return;\r\n        if (!message.reactions.get(data.emoji_id)?.push(data.user_id))\r\n          message.reactions.set(data.emoji_id, [data.user_id]);\r\n\r\n        this.client.emit(Events.MESSAGE_REACT, message);\r\n      }\r\n    }\r\n\r\n    return {};\r\n  }\r\n}\r\n","import { Event, API, Events } from \"./event\";\r\nimport { MessageReactData } from \"./messageReact\";\r\n\r\n/**\r\n * Represents the event handler for message reaction removals.\r\n * @private\r\n * @extends Event\r\n */\r\nexport class MessageUnreact extends Event {\r\n  /**\r\n   * Handles the message reaction removal event.\r\n   *\r\n   * @param {MessageReactData} data - The data for the event, containing the message ID, channel ID, user ID, and emoji ID.\r\n   * @returns {Promise<unknown>} A promise that resolves with an empty object.\r\n   */\r\n  async handle(data: MessageReactData): Promise<unknown> {\r\n    const channel = this.client.channels.cache.get(data.channel_id);\r\n\r\n    if (channel?.isText()) {\r\n      let message = channel.messages.cache.get(data.id)\r\n        ? channel.messages.cache.get(data.id)\r\n        : await channel.messages.fetch(data.id);\r\n\r\n      if (message) {\r\n        const reaction = message.reactions.get(data.emoji_id);\r\n        if (reaction) {\r\n          const index = reaction.indexOf(data.user_id);\r\n          if (index !== -1) {\r\n            reaction.splice(index, 1);\r\n          }\r\n          if (reaction.length === 0) {\r\n            message.reactions.delete(data.emoji_id);\r\n          }\r\n        }\r\n        this.client.emit(Events.MESSAGE_REACT_REMOVE, message);\r\n      }\r\n    }\r\n\r\n    return {};\r\n  }\r\n}\r\n","import { Event, Events } from \"./event\";\r\nimport { WebhookCreateData } from \"../../utils/types\";\r\n\r\n/**\r\n * Represents the event handler for webhook creations.\r\n * @extends Event\r\n * @private\r\n */\r\nexport class WebhookCreate extends Event {\r\n  /**\r\n   * Handles the webhook create event.\r\n   * @param {id: string, channel_id: string, server_id: string, name: string} data - The data for the event, containing the webhook ID, channel ID, server ID, and name.\r\n   * @returns {void}\r\n   */\r\n  handle(data: {\r\n    id: string;\r\n    channel_id: string;\r\n    server_id: string;\r\n    name: string;\r\n    creator_id: string;\r\n    token: string;\r\n  }): void {\r\n    const webhookData: WebhookCreateData = {\r\n      webhookId: data.id,\r\n      channelId: data.channel_id,\r\n      name: data.name,\r\n      creatorId: data.creator_id,\r\n      token: data.token,\r\n    };\r\n\r\n    this.client.emit(Events.WEBHOOKS_CREATE, webhookData);\r\n  }\r\n}\r\n","import { Event, Events } from \"./event\";\r\nimport { WebhookDeleteData } from \"../../utils/types\";\r\n\r\n/**\r\n * Represents the event handler for webhook deletions.\r\n * @extends Event\r\n * @private\r\n */\r\nexport class WebhookDelete extends Event {\r\n  /**\r\n   * Handles the webhook delete event.\r\n   * @param {id: string, channel_id: string, server_id: string} data - The data for the event, containing the webhook ID, channel ID, and server ID.\r\n   * @returns {void}\r\n   */\r\n  handle(data: { id: string; channel_id: string; server_id: string }): void {\r\n    const webhookData: WebhookDeleteData = {\r\n      webhookId: data.id,\r\n    };\r\n\r\n    this.client.emit(Events.WEBHOOKS_DELETE, webhookData);\r\n  }\r\n}\r\n","import { Event, Events } from \"./event\";\r\nimport { WebhookUpdateData } from \"../../utils/types\";\r\n\r\n/**\r\n * Represents the event handler for webhook updates.\r\n * @extends Event\r\n * @private\r\n */\r\nexport class WebhookUpdate extends Event {\r\n  /**\r\n   * Handles the webhook update event.\r\n   * @param {id: string, data: { name: string; avatar?: { _id: string; tag: string; filename: string; metadata: any; content_type: string; size: number; }; remove: string[]; }} data- The data for the event, containing the webhook ID and updated webhook data.\r\n   * @returns {void}\r\n   */\r\n  handle(data: {\r\n    id: string;\r\n    data: {\r\n      name: string;\r\n      avatar?: {\r\n        _id: string;\r\n        tag: string;\r\n        filename: string;\r\n        metadata: any;\r\n        content_type: string;\r\n        size: number;\r\n      };\r\n      remove: string[];\r\n    };\r\n  }): void {\r\n    const webhookData: WebhookUpdateData = {\r\n      webhookId: data.id,\r\n      name: data.data.name,\r\n      avatar: data.data.avatar,\r\n      remove: data.data.remove,\r\n    };\r\n\r\n    this.client.emit(Events.WEBHOOKS_UPDATE, webhookData);\r\n  }\r\n}\r\n","import { Event, API, Events } from \"./event\";\r\n\r\n/**\r\n * Data structure for user voice state update event.\r\n */\r\nexport interface UserVoiceStateUpdateData {\r\n  id: string;\r\n  channel_id: string;\r\n  data: { is_publishing: boolean; screensharing: boolean; camera: boolean };\r\n}\r\n\r\n/**\r\n * Represents the event handler for user voice state updates.\r\n * @private\r\n * @extends Event\r\n */\r\nexport class UserVoiceStateUpdate extends Event {\r\n  /**\r\n   * Handles the user voice state update event.\r\n   * @param {{ id: string; channel_id: string; data: { is_publishing: boolean; screensharing: boolean; camera: boolean; }; }} data - The data for the event, containing the user ID, channel ID, and updated voice state data.\r\n   * @returns {void}\r\n   */\r\n  handle(data: UserVoiceStateUpdateData): void {\r\n    this.client.emit(Events.USER_VOICE_STATE_UPDATE, data);\r\n  }\r\n}\r\n","import { voiceParticipant } from \"../../struct\";\r\nimport { ChannelTypes } from \"../../utils\";\r\nimport { Event, API, Events } from \"./event\";\r\n\r\n/**\r\n * Data structure for voice channel join event.\r\n */\r\nexport interface VoiceChannelJoinData {\r\n  id: string;\r\n  state: voiceParticipant;\r\n}\r\n\r\n/**\r\n * Represents the event handler for voice channel joins.\r\n * @private\r\n * @extends Event\r\n */\r\nexport class VoiceChannelJoin extends Event {\r\n  /**\r\n   * Handles the voice channel join event.\r\n   * @param {{ id: string; state: voiceParticipant; }} data - The data for the event, containing the channel ID and participant state.\r\n   * @returns {void}\r\n   */\r\n  handle(data: VoiceChannelJoinData): void {\r\n    const channel = this.client.channels.cache.get(data.id);\r\n    if (\r\n      channel?.type === ChannelTypes.VOICE ||\r\n      channel?.type === ChannelTypes.GROUP\r\n    ) {\r\n      channel.voice?.set(data.id, data.state);\r\n    }\r\n    this.client.emit(Events.VOICE_CHANNEL_JOIN, data);\r\n  }\r\n}\r\n","import { voiceParticipant } from \"../../struct\";\r\nimport { ChannelTypes } from \"../../utils\";\r\nimport { Event, API, Events } from \"./event\";\r\n\r\n/**\r\n * Data structure for voice channel leave event.\r\n */\r\nexport interface VoiceChannelLeaveData {\r\n  id: string;\r\n  user: string;\r\n}\r\n\r\n/**\r\n * Represents the event handler for voice channel leaves.\r\n * @private\r\n * @extends Event\r\n */\r\nexport class VoiceChannelLeave extends Event {\r\n  /**\r\n   * Handles the voice channel leave event.\r\n   * @param {{ id: string; user: string; }} data - The data for the event, containing the channel ID and user ID.\r\n   * @returns {void}\r\n   */\r\n  handle(data: VoiceChannelLeaveData): void {\r\n    const channel = this.client.channels.cache.get(data.id);\r\n    if (\r\n      channel?.type === ChannelTypes.VOICE ||\r\n      channel?.type === ChannelTypes.GROUP\r\n    ) {\r\n      channel.voice?.delete(data.id);\r\n    }\r\n    this.client.emit(Events.VOICE_CHANNEL_LEAVE, data);\r\n  }\r\n}\r\n","// Static event map for robust registration\r\nimport { BulkMessageDelete } from \"./bulkMessageDelete\";\r\nimport { ChannelCreate } from \"./channelCreate\";\r\nimport { ChannelDelete } from \"./channelDelete\";\r\nimport { ChannelGroupJoin } from \"./channelGroupJoin\";\r\nimport { ChannelGroupLeave } from \"./channelGroupLeave\";\r\nimport { ChannelStartTyping } from \"./channelStarttyping\";\r\nimport { ChannelStopTyping } from \"./channelStopTyping\";\r\nimport { ChannelUpdate } from \"./channelUpdate\";\r\nimport { Message as MessageReceved } from \"./message\";\r\nimport { MessageDelete } from \"./messageDelete\";\r\nimport { MessageUpdate } from \"./messageUpdate\";\r\nimport { ServerCreate } from \"./serverCreate\";\r\nimport { ServerDelete } from \"./serverDelete\";\r\nimport { ServerMemberJoin } from \"./serverMemberJoin\";\r\nimport { ServerMemberLeave } from \"./serverMemberLeave\";\r\nimport { ServerMemberUpdate } from \"./serverMemberUpdate\";\r\nimport { ServerRoleDelete } from \"./serverRoleDelete\";\r\nimport { ServerRoleUpdate } from \"./serverRoleUpdate\";\r\nimport { ServerUpdate } from \"./serverupdate\";\r\nimport { UserUpdate } from \"./userUpdate\";\r\nimport { MessageReact } from \"./messageReact\";\r\nimport { MessageUnreact } from \"./messageUnreact\";\r\nimport { WebhookCreate } from \"./webhookCreate\";\r\nimport { WebhookDelete } from \"./webhookDelete\";\r\nimport { WebhookUpdate } from \"./webhookUpdate\";\r\nimport { UserVoiceStateUpdate } from \"./userVoiceStateUpdate\";\r\nimport { VoiceChannelJoin } from \"./voiceChannelJoin\";\r\nimport { VoiceChannelLeave } from \"./voiceChannelLeave\";\r\n\r\nexport const EventMap = {\r\n  bulkMessageDelete: BulkMessageDelete,\r\n  channelCreate: ChannelCreate,\r\n  channelDelete: ChannelDelete,\r\n  channelGroupJoin: ChannelGroupJoin,\r\n  channelGroupLeave: ChannelGroupLeave,\r\n  channelStartTyping: ChannelStartTyping,\r\n  channelStopTyping: ChannelStopTyping,\r\n  channelUpdate: ChannelUpdate,\r\n  message: MessageReceved,\r\n  messageDelete: MessageDelete,\r\n  messageUpdate: MessageUpdate,\r\n  serverCreate: ServerCreate,\r\n  serverDelete: ServerDelete,\r\n  serverMemberJoin: ServerMemberJoin,\r\n  serverMemberLeave: ServerMemberLeave,\r\n  serverMemberUpdate: ServerMemberUpdate,\r\n  serverRoleDelete: ServerRoleDelete,\r\n  serverRoleUpdate: ServerRoleUpdate,\r\n  serverUpdate: ServerUpdate,\r\n  userUpdate: UserUpdate,\r\n  messageReact: MessageReact,\r\n  messageUnreact: MessageUnreact,\r\n  webhookCreate: WebhookCreate,\r\n  webhookDelete: WebhookDelete,\r\n  webhookUpdate: WebhookUpdate,\r\n  userVoiceStateUpdate: UserVoiceStateUpdate,\r\n  voiceChannelJoin: VoiceChannelJoin,\r\n  voiceChannelLeave: VoiceChannelLeave,\r\n};\r\n","import { EventMap } from \"./index\";\r\nimport { Event as CustomEvent } from \"./event\";\r\nimport { client } from \"../client\";\r\n\r\n/**\r\n * Manages the registration and retrieval of events for the client.\r\n * @private\r\n * @extends Event\r\n */\r\nexport class EventManager {\r\n  /** A map of registered events, keyed by their names. */\r\n  #events = new Map<string, CustomEvent>();\r\n\r\n  /**\r\n   * Creates a new EventManager instance.\r\n   *\r\n   * @param {client} client - The client instance.\r\n   */\r\n  constructor(protected readonly client: client) {\r\n    for (const [key, Event] of Object.entries(EventMap)) {\r\n      if (this.client.options.ignoreEvents?.includes(key)) return;\r\n      this.register(Event as new (client: client) => CustomEvent);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Registers an event with the manager.\r\n   *\r\n   * @param {new (client: client) => CustomEvent} Event - The event class to register.\r\n   */\r\n  register(Event: new (client: client) => CustomEvent): void {\r\n    this.#events.set(Event.name.replace(/Events$/, \"\"), new Event(this.client));\r\n  }\r\n\r\n  /**\r\n   * Retrieves a registered event by its name.\r\n   *\r\n   * @param {string} name - The name of the event to retrieve.\r\n   * @returns {CustomEvent | null} The event instance, or `null` if not found.\r\n   */\r\n  get(name: string): CustomEvent | null {\r\n    return this.#events.get(name) ?? null;\r\n  }\r\n}\r\n","import { spawn } from \"node:child_process\";\r\nimport { Readable } from \"node:stream\";\r\nimport { EventEmitter } from \"node:events\";\r\nimport { existsSync } from \"node:fs\";\r\nimport { URL } from \"node:url\";\r\nimport {\r\n  AudioFrame,\r\n  AudioSource,\r\n  LocalAudioTrack,\r\n  LocalTrackPublication,\r\n  Room,\r\n  RoomEvent,\r\n  TrackPublishOptions,\r\n  TrackSource,\r\n} from \"@livekit/rtc-node\";\r\n\r\nimport { client } from \"./client\";\r\n\r\n/**\r\n * Events emitted by the AudioPlayer\r\n */\r\nexport interface AudioPlayerEvents {\r\n  connected: [channelId: string, serverId: string, roomName?: string];\r\n  disconnected: [channelId: string, serverId: string, reason?: string];\r\n  audioStart: [source: string, type: string];\r\n  audioEnd: [source: string, type: string];\r\n  audioError: [source: string, type: string, error: Error];\r\n  volumeChanged: [oldVolume: number, newVolume: number];\r\n  muted: [previousVolume: number];\r\n  unmuted: [newVolume: number];\r\n  trackPublished: [trackId: string];\r\n  trackStopped: [trackId: string];\r\n  conversionStart: [source: string, sampleRate: number, channels: number];\r\n  conversionEnd: [source: string, samplesProcessed: number];\r\n  conversionError: [source: string, error: Error];\r\n  debug: [message: string, data?: any];\r\n  error: [error: Error, context?: string];\r\n}\r\n\r\nexport declare interface AudioPlayer {\r\n  on<K extends keyof AudioPlayerEvents>(\r\n    event: K,\r\n    listener: (...args: AudioPlayerEvents[K]) => void,\r\n  ): this;\r\n\r\n  off<K extends keyof AudioPlayerEvents>(\r\n    event: K,\r\n    listener: (...args: AudioPlayerEvents[K]) => void,\r\n  ): this;\r\n\r\n  removeAllListeners<K extends keyof AudioPlayerEvents>(event?: K): this;\r\n}\r\n\r\nexport class AudioPlayer extends EventEmitter {\r\n  private readonly channelId: string;\r\n  private readonly serverId: string;\r\n  private readonly client: client;\r\n  private _volume: number = 1.0; // Volume from 0.0 to 2.0 (100% = 1.0, 200% = 2.0)\r\n  private room?: Room;\r\n  private publications: Map<string, LocalTrackPublication> = new Map();\r\n  private audioSources: Map<string, AudioSource> = new Map();\r\n  private isConnected: boolean = false;\r\n  private shouldStop: boolean = false; // Flag to control audio playback cancellation\r\n  private isStreaming: boolean = false; // Flag to control streaming audio playback\r\n\r\n  constructor(channelId: string, serverId: string, client: client) {\r\n    super();\r\n    this.channelId = channelId;\r\n    this.serverId = serverId;\r\n    this.client = client;\r\n  }\r\n\r\n  /**\r\n   * Get the channel ID this player is associated with\r\n   */\r\n  get channel(): string {\r\n    return this.channelId;\r\n  }\r\n\r\n  /**\r\n   * Get the server ID this player is associated with\r\n   */\r\n  get server(): string {\r\n    return this.serverId;\r\n  }\r\n\r\n  /**\r\n   * Get current volume level (0.0 to 2.0)\r\n   */\r\n  get volume(): number {\r\n    return this._volume;\r\n  }\r\n\r\n  /**\r\n   * Check if the player is connected to a voice channel\r\n   */\r\n  get connected(): boolean {\r\n    return this.isConnected && !!this.room;\r\n  }\r\n\r\n  /**\r\n   * Set volume level\r\n   * @param level - Volume level from 0.0 (mute) to 2.0 (200%)\r\n   */\r\n  setVolume(level: number): void {\r\n    const oldVolume = this._volume;\r\n    this._volume = Math.max(0.0, Math.min(2.0, level));\r\n\r\n    this.emit(\"debug\", `Volume set to ${(this._volume * 100).toFixed(0)}%`, {\r\n      oldVolume,\r\n      newVolume: this._volume,\r\n    });\r\n\r\n    this.emit(\"volumeChanged\", oldVolume, this._volume);\r\n  }\r\n\r\n  /**\r\n   * Increase volume by specified amount\r\n   * @param amount - Amount to increase (default: 0.1)\r\n   */\r\n  increaseVolume(amount: number = 0.1): void {\r\n    this.setVolume(this._volume + amount);\r\n  }\r\n\r\n  /**\r\n   * Decrease volume by specified amount\r\n   * @param amount - Amount to decrease (default: 0.1)\r\n   */\r\n  decreaseVolume(amount: number = 0.1): void {\r\n    this.setVolume(this._volume - amount);\r\n  }\r\n\r\n  /**\r\n   * Mute audio (set volume to 0)\r\n   */\r\n  mute(): void {\r\n    const oldVolume = this._volume;\r\n    this.setVolume(0);\r\n    this.emit(\"muted\", oldVolume);\r\n  }\r\n\r\n  /**\r\n   * Unmute audio (restore to 100% if currently muted)\r\n   */\r\n  unmute(): void {\r\n    if (this._volume === 0) {\r\n      this.setVolume(1.0);\r\n      this.emit(\"unmuted\", 1.0);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply volume to PCM audio data\r\n   * @param pcmData - Int16Array audio data\r\n   * @returns Modified PCM data with volume applied\r\n   * @private\r\n   */\r\n  private applyVolume(pcmData: Int16Array): Int16Array {\r\n    if (this._volume === 1.0) return pcmData; // No change needed\r\n\r\n    const result = new Int16Array(pcmData.length);\r\n    for (let i = 0; i < pcmData.length; i++) {\r\n      // Apply volume and clamp to prevent overflow\r\n      const sample = pcmData[i] * this._volume;\r\n      result[i] = Math.max(-32768, Math.min(32767, Math.round(sample)));\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Check if a string is a valid URL\r\n   * @param input - The string to check\r\n   * @returns True if the input is a valid URL\r\n   */\r\n  private isUrl(input: string): boolean {\r\n    try {\r\n      const url = new URL(input);\r\n      return url.protocol === \"http:\" || url.protocol === \"https:\";\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if a string is a valid file path that exists\r\n   * @param input - The string to check\r\n   * @returns True if the input is an existing file path\r\n   * @private\r\n   */\r\n  private isFilePath(input: string): boolean {\r\n    try {\r\n      return existsSync(input);\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if input is a Readable stream\r\n   * @param input - The input to check\r\n   * @returns True if the input is a Readable stream\r\n   * @private\r\n   */\r\n  private isStream(input: any): input is Readable {\r\n    return input instanceof Readable;\r\n  }\r\n\r\n  /**\r\n   * Connect to the voice channel\r\n   */\r\n  async connect(targetChannelId?: string): Promise<void> {\r\n    const channelToConnect = targetChannelId || this.channelId;\r\n\r\n    // If we're already connected and trying to connect to a different channel, disconnect first\r\n    if (this.isConnected && channelToConnect !== this.channelId) {\r\n      await this.disconnect();\r\n      // Update the player's channel ID for the new connection\r\n      (this as any).channelId = channelToConnect;\r\n    } else if (this.isConnected && channelToConnect === this.channelId) {\r\n      return;\r\n    }\r\n\r\n    this.emit(\"debug\", \"Starting connection\", {\r\n      channelId: channelToConnect,\r\n      serverId: this.serverId,\r\n    });\r\n\r\n    try {\r\n      const selectedNode =\r\n        this.client.voiceOptions.nodes?.[0].name || \"worldwide\";\r\n      // First attempt: Try normal join_call\r\n      let response: { token: string; url: string };\r\n\r\n      try {\r\n        response = (await this.client.api.post(\r\n          `/channels/${channelToConnect}/join_call`,\r\n          { body: { node: selectedNode } },\r\n        )) as { token: string; url: string };\r\n      } catch (joinError: any) {\r\n        // Check if this is the AlreadyConnected error\r\n        if (\r\n          joinError.message?.includes(\"AlreadyConnected\") ||\r\n          joinError.response?.data?.type === \"AlreadyConnected\"\r\n        ) {\r\n          // Strategy 1: Try to DELETE on the same channel to clear connection\r\n          try {\r\n            await this.client.api.delete(\r\n              `/channels/${channelToConnect}/join_call`,\r\n            );\r\n\r\n            // Retry the join after clearing\r\n            response = (await this.client.api.post(\r\n              `/channels/${channelToConnect}/join_call`,\r\n              { body: { node: selectedNode } },\r\n            )) as { token: string; url: string };\r\n          } catch (deleteError) {\r\n            // Strategy 2: Try with force parameter\r\n            try {\r\n              response = (await this.client.api.post(\r\n                `/channels/${channelToConnect}/join_call`,\r\n                { body: { node: selectedNode, force: true } },\r\n              )) as { token: string; url: string };\r\n            } catch (forceError) {\r\n              // Final strategy: Provide clear error with solutions\r\n              throw new Error(\r\n                `Unable to join voice channel: Bot is already connected to another voice channel.\\n\\n` +\r\n                  `This typically happens when:\\n` +\r\n                  ` The bot didn't disconnect properly from a previous session\\n` +\r\n                  ` Another instance of the bot is running\\n` +\r\n                  ` The bot crashed without proper cleanup\\n\\n` +\r\n                  `Solutions to try:\\n` +\r\n                  `1. Restart the bot application completely\\n` +\r\n                  `2. Wait 30-60 seconds for the connection to timeout\\n` +\r\n                  `3. Check if another bot instance is running\\n` +\r\n                  `4. Check server permissions for voice channels\\n\\n` +\r\n                  `If this persists, the API may need manual intervention to clear the connection state.`,\r\n              );\r\n            }\r\n          }\r\n        } else {\r\n          // Different error, re-throw it\r\n          throw joinError;\r\n        }\r\n      }\r\n\r\n      const room = new Room();\r\n      this.room = room;\r\n\r\n      // Set up room event handlers\r\n      room.on(RoomEvent.Disconnected, this.handleDisconnected.bind(this));\r\n\r\n      // Connect to the voice room\r\n      await room.connect(response.url, response.token, {\r\n        dynacast: true,\r\n        autoSubscribe: true,\r\n      });\r\n\r\n      this.isConnected = true;\r\n      this.emit(\"connected\", channelToConnect, this.serverId, room.name);\r\n      this.emit(\"debug\", \"Connection established\", { roomName: room.name });\r\n    } catch (error) {\r\n      this.emit(\r\n        \"error\",\r\n        error instanceof Error ? error : new Error(String(error)),\r\n        \"connection\",\r\n      );\r\n      console.error(` [${channelToConnect}] Failed to connect:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generic play method that automatically detects the input type and uses the appropriate play method\r\n   * @param input - Can be a URL string, file path string, or Readable stream\r\n   * @returns Promise that resolves when playback starts\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Play from URL\r\n   * await player.play(\"https://example.com/audio.mp3\");\r\n   *\r\n   * // Play from file path\r\n   * await player.play(\"/path/to/audio.mp3\");\r\n   *\r\n   * // Play from stream\r\n   * await player.play(readableStream);\r\n   * ```\r\n   */\r\n  async play(input: string | Readable): Promise<void> {\r\n    if (this.isStream(input)) {\r\n      this.emit(\"debug\", \"Auto-detected stream input\", { type: \"stream\" });\r\n      this.emit(\"audioStart\", \"stream\", \"stream\");\r\n      await this.playFromStream(input, \"stream\", \"stream\");\r\n    } else if (typeof input === \"string\") {\r\n      if (this.isUrl(input)) {\r\n        this.emit(\"debug\", \"Auto-detected URL input\", { url: input });\r\n        await this.playFromUrl(input);\r\n      } else if (this.isFilePath(input)) {\r\n        this.emit(\"debug\", \"Auto-detected file path input\", {\r\n          filePath: input,\r\n        });\r\n        await this.playFromFile(input);\r\n      } else {\r\n        throw new Error(\r\n          `Invalid input: '${input}' is neither a valid URL nor an existing file path`,\r\n        );\r\n      }\r\n    } else {\r\n      throw new Error(\r\n        `Unsupported input type: expected string or Readable stream, got ${typeof input}`,\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Play audio from a URL (supports both files and streaming URLs like radio stations)\r\n   * @private\r\n   */\r\n  private async playFromUrl(url: string): Promise<void> {\r\n    if (!this.connected) {\r\n      await this.connect();\r\n    }\r\n\r\n    this.emit(\"audioStart\", url, \"url\");\r\n    this.emit(\"debug\", \"Starting URL playback\", { url });\r\n\r\n    try {\r\n      const https = await import(\"node:https\");\r\n      const http = await import(\"node:http\");\r\n\r\n      return new Promise<void>((resolve, reject) => {\r\n        const client = url.startsWith(\"https:\") ? https : http;\r\n\r\n        const request = client.get(url, (response) => {\r\n          if (response.statusCode !== 200) {\r\n            const error = new Error(`HTTP Error: ${response.statusCode}`);\r\n            console.error(\"HTTP Error:\", error.message);\r\n            this.emit(\"audioError\", url, \"url\", error);\r\n            return;\r\n          }\r\n\r\n          // Check if this is likely a continuous stream (radio, live stream)\r\n          const contentType = response.headers[\"content-type\"] || \"\";\r\n          const contentLength = response.headers[\"content-length\"];\r\n          const isLiveStream =\r\n            !contentLength ||\r\n            (contentType.includes(\"audio/mpeg\") && url.includes(\"stream\")) ||\r\n            contentType.includes(\"application/ogg\") ||\r\n            url.toLowerCase().includes(\"radio\") ||\r\n            url.toLowerCase().includes(\"stream\");\r\n\r\n          if (isLiveStream) {\r\n            // Use streaming method for continuous audio\r\n            this.playStreamingAudio(response, url, \"url\")\r\n              .then(() => {\r\n                this.emit(\"audioEnd\", \"URL playback completed\", { url });\r\n                resolve();\r\n              })\r\n              .catch((error) => {\r\n                console.error(\"Error streaming audio from URL:\", error);\r\n                this.emit(\"audioError\", url, \"url\", error);\r\n                this.emit(\"error\", error, \"url-streaming\");\r\n              });\r\n          } else {\r\n            // Use standard conversion for finite files\r\n            this.playFromStream(response, url, \"url\")\r\n              .then(() => {\r\n                this.emit(\"debug\", \"URL playback completed\", { url });\r\n                resolve();\r\n              })\r\n              .catch((error) => {\r\n                console.error(\"Error playing audio from URL:\", error);\r\n                this.emit(\"audioError\", url, \"url\", error);\r\n                this.emit(\"error\", error, \"url-standard\");\r\n              });\r\n          }\r\n        });\r\n\r\n        request.on(\"error\", (error) => {\r\n          console.error(\"Request error:\", error.message);\r\n          this.emit(\"audioError\", url, \"url\", error);\r\n        });\r\n\r\n        request.setTimeout(30000, () => {\r\n          const timeoutError = new Error(\"Request timeout\");\r\n          request.destroy();\r\n          this.emit(\"audioError\", url, \"url\", timeoutError);\r\n        });\r\n      });\r\n    } catch (error) {\r\n      const errorObj =\r\n        error instanceof Error ? error : new Error(String(error));\r\n      this.emit(\"audioError\", url, \"url\", errorObj);\r\n      this.emit(\"error\", errorObj, \"url-playback\");\r\n      console.error(` [${this.channelId}] URL playback failed:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Play audio from a stream in real-time (for radio stations, live streams)\r\n   */\r\n  private async playStreamingAudio(\r\n    audioStream: Readable,\r\n    source?: string,\r\n    type?: string,\r\n  ): Promise<void> {\r\n    // Reset stop flags when starting new streaming\r\n    this.shouldStop = false;\r\n    this.isStreaming = true;\r\n\r\n    if (!this.room) {\r\n      throw new Error(\r\n        `Not connected to voice channel ${this.channelId}. Call connect() first.`,\r\n      );\r\n    }\r\n\r\n    // Check if localParticipant is available\r\n    if (!this.room.localParticipant) {\r\n      await new Promise((resolve) => setTimeout(resolve, 1000));\r\n      if (!this.room.localParticipant) {\r\n        throw new Error(\"Local participant not available after waiting\");\r\n      }\r\n    }\r\n\r\n    try {\r\n      const sampleRate = 48000;\r\n      const channels = 1;\r\n\r\n      const source = new AudioSource(sampleRate, channels);\r\n      const sourceId = `stream_${Date.now()}`;\r\n      this.audioSources.set(sourceId, source);\r\n      const track = LocalAudioTrack.createAudioTrack(\"audio\", source);\r\n      const options = new TrackPublishOptions();\r\n      options.source = TrackSource.SOURCE_MICROPHONE;\r\n\r\n      const publication = await this.room.localParticipant.publishTrack(\r\n        track,\r\n        options,\r\n      );\r\n\r\n      if (publication) {\r\n        this.publications.set(publication.sid!, publication);\r\n        this.emit(\"trackPublished\", publication.sid!);\r\n\r\n        // Try different methods to unmute the track\r\n        try {\r\n          if (typeof (publication as any).setMuted === \"function\") {\r\n            await (publication as any).setMuted(false);\r\n          } else if (typeof (track as any).setMuted === \"function\") {\r\n            await (track as any).setMuted(false);\r\n          }\r\n        } catch (error) {\r\n          this.emit(\"error\", error, \"track-unmute\");\r\n        }\r\n\r\n        // Set up FFmpeg for real-time conversion with simple, stable arguments\r\n        const args = [\r\n          \"-i\",\r\n          \"pipe:0\", // Read from stdin\r\n          \"-f\",\r\n          \"s16le\", // 16-bit little-endian PCM\r\n          \"-ar\",\r\n          sampleRate.toString(), // Sample rate\r\n          \"-ac\",\r\n          channels.toString(), // Number of channels\r\n          \"-\", // Output to stdout\r\n        ];\r\n\r\n        const ffmpeg = spawn(\"ffmpeg\", args);\r\n\r\n        // Enhanced error handling for stdin\r\n        ffmpeg.stdin.on(\"error\", (error) => {\r\n          // Don't stop streaming for stdin errors, they're often recoverable\r\n        });\r\n\r\n        // Pipe the audio stream to ffmpeg with error handling\r\n        audioStream.pipe(ffmpeg.stdin);\r\n\r\n        audioStream.on(\"error\", (error) => {\r\n          this.emit(\"audioError\", \"stream\", \"streaming\", error);\r\n        });\r\n\r\n        audioStream.on(\"close\", () => {\r\n          console.warn(\" Audio stream closed unexpectedly\");\r\n          if (this.isStreaming) {\r\n          }\r\n        });\r\n\r\n        audioStream.on(\"end\", () => {\r\n          if (this.isStreaming) {\r\n            this.isStreaming = false;\r\n            ffmpeg.kill();\r\n          }\r\n        });\r\n\r\n        // Process audio in real-time chunks\r\n        const chunkDurationMs = 100; // 100ms chunks\r\n        const samplesPerChunk =\r\n          Math.floor((sampleRate * chunkDurationMs) / 1000) * channels;\r\n        const bytesPerChunk = samplesPerChunk * 2; // 2 bytes per 16-bit sample\r\n\r\n        let buffer = Buffer.alloc(0);\r\n        let chunkCount = 0;\r\n\r\n        ffmpeg.stdout.on(\"data\", async (chunk: Buffer) => {\r\n          try {\r\n            if (!this.isStreaming || this.shouldStop) return;\r\n\r\n            buffer = Buffer.concat([buffer, chunk]);\r\n            chunkCount++;\r\n\r\n            // Process complete chunks\r\n            while (\r\n              buffer.length >= bytesPerChunk &&\r\n              this.isStreaming &&\r\n              !this.shouldStop\r\n            ) {\r\n              const audioChunk = buffer.slice(0, bytesPerChunk);\r\n              buffer = buffer.slice(bytesPerChunk);\r\n\r\n              // Convert to Int16Array with proper alignment\r\n              const alignedBuffer = Buffer.from(audioChunk);\r\n              const originalPcmData = new Int16Array(\r\n                alignedBuffer.buffer,\r\n                alignedBuffer.byteOffset,\r\n                alignedBuffer.byteLength / 2,\r\n              );\r\n\r\n              // Apply volume control to the audio data\r\n              const volumeAdjustedPcmData = this.applyVolume(originalPcmData);\r\n\r\n              // Create AudioFrame and send to track (using actual data length)\r\n              const frame = new AudioFrame(\r\n                volumeAdjustedPcmData,\r\n                sampleRate,\r\n                channels,\r\n                volumeAdjustedPcmData.length,\r\n              );\r\n\r\n              // Use async captureFrame and handle errors gracefully\r\n              try {\r\n                await source.captureFrame(frame);\r\n              } catch (frameError) {\r\n                console.error(\"Error processing audio chunk:\", frameError);\r\n                if (!this.isStreaming || this.shouldStop) {\r\n                  // If we're no longer streaming or should stop, stop processing\r\n                  return;\r\n                }\r\n                // For InvalidState errors during active streaming, continue without the frame\r\n                if (\r\n                  frameError instanceof Error &&\r\n                  frameError.message?.includes(\"InvalidState\")\r\n                ) {\r\n                  continue;\r\n                }\r\n              }\r\n            }\r\n          } catch (error) {}\r\n        });\r\n\r\n        ffmpeg.on(\"close\", (code) => {\r\n          this.isStreaming = false;\r\n\r\n          // For streaming audio, null or non-zero exit codes are often normal\r\n          // when stopping streams or when streams end naturally\r\n          if (code !== 0 && code !== null) {\r\n            const error = new Error(`FFmpeg exited with code ${code}`);\r\n            this.emit(\"audioError\", \"stream\", \"streaming\", error);\r\n          }\r\n        });\r\n\r\n        // Set up a way to stop streaming\r\n        this.once(\"disconnected\", () => {\r\n          this.isStreaming = false;\r\n          ffmpeg.kill();\r\n        });\r\n\r\n        // Return a promise that resolves when streaming ends\r\n        return new Promise<void>((resolve, reject) => {\r\n          ffmpeg.on(\"close\", (code) => {\r\n            this.emit(\"debug\", \"FFmpeg streaming ended\", {\r\n              code,\r\n              source,\r\n              type,\r\n            });\r\n\r\n            // Emit audioEnd event if source information is provided\r\n            if (source && type) {\r\n              this.emit(\"debug\", \"Emitting audioEnd for streaming\", {\r\n                source,\r\n                type,\r\n              });\r\n              this.emit(\"audioEnd\", source, type);\r\n            } else {\r\n              this.emit(\"debug\", \"No source/type for streaming audioEnd\", {\r\n                source,\r\n                type,\r\n              });\r\n            }\r\n\r\n            // For streaming audio, null or non-zero exit codes are often normal\r\n            // when stopping streams or when streams end naturally\r\n            if (code === 0 || code === null) {\r\n              resolve();\r\n            } else {\r\n              console.warn(\r\n                ` FFmpeg exited with code ${code} - this may be normal for streaming`,\r\n              );\r\n              resolve(); // Resolve anyway since streaming termination is often expected\r\n            }\r\n          });\r\n        });\r\n      } else {\r\n        throw new Error(\"Failed to publish audio track\");\r\n      }\r\n    } catch (error) {\r\n      console.error(\r\n        ` [${this.channelId}] Failed to set up streaming:`,\r\n        error,\r\n      );\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Play audio from a finite stream (for regular audio files)\r\n   * @private\r\n   */\r\n  private async playFromStream(\r\n    stream: Readable,\r\n    source?: string,\r\n    type?: string,\r\n  ): Promise<void> {\r\n    // Reset stop flags when starting new playback\r\n    this.shouldStop = false;\r\n    this.isStreaming = false; // This is not streaming audio, it's converted PCM\r\n\r\n    const pcmData = await this.convertAudioToPCM(stream, 48000, 1);\r\n    this.emit(\"debug\", \"PCM conversion completed\", { source, type });\r\n\r\n    await this.publishPCMAudio(pcmData);\r\n    this.emit(\"debug\", \"Audio publishing completed\", { source, type });\r\n\r\n    // Emit audioEnd event if source information is provided\r\n    if (source && type) {\r\n      this.emit(\"debug\", \"Emitting audioEnd event\", { source, type });\r\n      this.emit(\"audioEnd\", source, type);\r\n    } else {\r\n      this.emit(\"debug\", \"No source/type provided, skipping audioEnd\", {\r\n        source,\r\n        type,\r\n      });\r\n    }\r\n  } /**\r\n   * Convert audio to PCM format using FFmpeg\r\n   * @private\r\n   */\r\n  private async convertAudioToPCM(\r\n    input: string | Readable,\r\n    sampleRate: number = 48000,\r\n    channels: number = 1,\r\n  ): Promise<Int16Array> {\r\n    const sourceDesc = typeof input === \"string\" ? input : \"stream\";\r\n\r\n    this.emit(\"conversionStart\", sourceDesc, sampleRate, channels);\r\n    this.emit(\"debug\", \"Starting FFmpeg audio conversion\", {\r\n      source: sourceDesc,\r\n      sampleRate,\r\n      channels,\r\n    });\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const args = [];\r\n\r\n      if (typeof input === \"string\") {\r\n        // File path input\r\n        args.push(\"-i\", input);\r\n      } else {\r\n        // Stream input\r\n        args.push(\"-i\", \"pipe:0\"); // Read from stdin\r\n      }\r\n\r\n      args.push(\r\n        \"-f\",\r\n        \"s16le\", // 16-bit little-endian PCM\r\n        \"-ar\",\r\n        sampleRate.toString(), // Sample rate\r\n        \"-ac\",\r\n        channels.toString(), // Number of channels\r\n        \"-\", // Output to stdout\r\n      );\r\n\r\n      const ffmpeg = spawn(\"ffmpeg\", args);\r\n      const chunks: Buffer[] = [];\r\n      let errorOutput = \"\";\r\n\r\n      // Handle FFmpeg output\r\n      ffmpeg.stdout.on(\"data\", (chunk: Buffer) => {\r\n        chunks.push(chunk);\r\n      });\r\n\r\n      // Capture error messages\r\n      ffmpeg.stderr.on(\"data\", (data: Buffer) => {\r\n        errorOutput += data.toString();\r\n      });\r\n\r\n      ffmpeg.on(\"close\", (code) => {\r\n        if (code === 0) {\r\n          const pcmBuffer = Buffer.concat(chunks);\r\n          const int16Array = new Int16Array(\r\n            pcmBuffer.buffer,\r\n            pcmBuffer.byteOffset,\r\n            pcmBuffer.length / 2,\r\n          );\r\n\r\n          this.emit(\"conversionEnd\", sourceDesc, int16Array.length);\r\n          this.emit(\"debug\", \"FFmpeg conversion completed\", {\r\n            pcmDataSize: int16Array.length,\r\n            bufferSize: pcmBuffer.length,\r\n          });\r\n\r\n          resolve(int16Array);\r\n        } else {\r\n          const error = new Error(\r\n            `FFmpeg failed with code ${code}: ${errorOutput}`,\r\n          );\r\n          this.emit(\"conversionError\", sourceDesc, error);\r\n          console.error(error);\r\n        }\r\n      });\r\n\r\n      ffmpeg.on(\"error\", (err) => {\r\n        const error = new Error(`FFmpeg spawn error: ${err.message}`);\r\n        this.emit(\"conversionError\", sourceDesc, error);\r\n        console.error(error);\r\n      });\r\n\r\n      // Send audio data to FFmpeg\r\n      if (typeof input === \"string\") {\r\n        ffmpeg.stdin.end();\r\n      } else {\r\n        input.pipe(ffmpeg.stdin);\r\n        input.on(\"end\", () => {\r\n          ffmpeg.stdin.end();\r\n        });\r\n        input.on(\"error\", (err) => {\r\n          ffmpeg.kill(\"SIGTERM\");\r\n          console.error(err);\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Publish PCM audio to the voice channel\r\n   */\r\n  private async publishPCMAudio(pcmData: Int16Array): Promise<void> {\r\n    if (!this.room) {\r\n      throw new Error(\r\n        `Not connected to voice channel ${this.channelId}. Call connect() first.`,\r\n      );\r\n    }\r\n\r\n    // Apply volume control to the PCM data\r\n    const volumeAdjustedPCM = this.applyVolume(pcmData);\r\n\r\n    return new Promise<void>((resolve, reject) => {\r\n      const processAudio = async () => {\r\n        try {\r\n          // Create audio source with 48kHz, mono, 16-bit\r\n          const source = new AudioSource(48000, 1);\r\n          const sourceId = `file_${Date.now()}`;\r\n          this.audioSources.set(sourceId, source);\r\n          const track = LocalAudioTrack.createAudioTrack(\"audio\", source);\r\n          const options = new TrackPublishOptions();\r\n          options.source = TrackSource.SOURCE_MICROPHONE;\r\n\r\n          // Publish the track\r\n          if (!this.room!.localParticipant) {\r\n            throw new Error(\"Room local participant not available\");\r\n          }\r\n          const publication = await this.room!.localParticipant.publishTrack(\r\n            track,\r\n            options,\r\n          );\r\n\r\n          if (publication) {\r\n            // Store the publication for later cleanup\r\n            this.publications.set(publication.sid!, publication);\r\n\r\n            this.emit(\"trackPublished\", publication.sid!);\r\n            this.emit(\"debug\", \"Audio track published successfully\", {\r\n              trackId: publication.sid,\r\n              publicationCount: this.publications.size,\r\n            });\r\n\r\n            // Try different methods to unmute the track\r\n            try {\r\n              // Try multiple unmute approaches\r\n              if (typeof (publication as any).setMuted === \"function\") {\r\n                await (publication as any).setMuted(false);\r\n              } else if (typeof (track as any).setMuted === \"function\") {\r\n                await (track as any).setMuted(false);\r\n              }\r\n\r\n              // Try to ensure the track is enabled and active\r\n              if (typeof (track as any).setEnabled === \"function\") {\r\n                await (track as any).setEnabled(true);\r\n              }\r\n            } catch (error) {\r\n              this.emit(\"error\", error, \"track-unmute\");\r\n            }\r\n\r\n            // Stream PCM audio in real-time chunks (matching working implementation)\r\n            const chunkDurationMs = 100; // 100ms chunks (like working implementation)\r\n            const samplesPerChunk =\r\n              Math.floor((48000 * chunkDurationMs) / 1000) * 1; // sampleRate * duration * channels\r\n            let offset = 0;\r\n            let chunksSent = 0;\r\n\r\n            while (offset < volumeAdjustedPCM.length && !this.shouldStop) {\r\n              const chunkEnd = Math.min(\r\n                offset + samplesPerChunk,\r\n                volumeAdjustedPCM.length,\r\n              );\r\n              const chunk = volumeAdjustedPCM.slice(offset, chunkEnd);\r\n\r\n              // Create AudioFrame with proper format (using total samples, not per-channel)\r\n              const frame = new AudioFrame(\r\n                chunk,\r\n                48000, // sampleRate\r\n                1, // channels (mono)\r\n                chunk.length, // total samples in chunk\r\n              );\r\n\r\n              // Capture the audio frame with better error handling\r\n              try {\r\n                await source.captureFrame(frame);\r\n                chunksSent++;\r\n              } catch (error) {\r\n                this.emit(\"error\", error, \"frame-capture\");\r\n                // Don't reject on individual frame errors, continue playback\r\n              }\r\n\r\n              offset = chunkEnd;\r\n\r\n              // Wait for real-time playback (like the working implementation)\r\n              await new Promise((resolve) =>\r\n                setTimeout(resolve, chunkDurationMs),\r\n              );\r\n            }\r\n\r\n            if (this.shouldStop) {\r\n              this.emit(\"debug\", \"Audio playback stopped by user\", {\r\n                channelId: this.channelId,\r\n                chunksSent,\r\n              });\r\n            } else {\r\n              this.emit(\"debug\", \"Audio playback completed successfully\", {\r\n                channelId: this.channelId,\r\n                chunksSent,\r\n                totalSamples: volumeAdjustedPCM.length,\r\n              });\r\n            }\r\n            this.emit(\"debug\", \"publishPCMAudio resolving\");\r\n            resolve();\r\n          } else {\r\n            console.error(new Error(\"Failed to publish audio track\"));\r\n          }\r\n        } catch (error) {\r\n          console.error(\r\n            ` [${this.channelId}] Failed to publish audio:`,\r\n            error,\r\n          );\r\n          console.error(error);\r\n        }\r\n      };\r\n\r\n      processAudio();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Play audio from a file\r\n   * @private\r\n   */\r\n  private async playFromFile(filePath: string): Promise<void> {\r\n    if (!this.connected) {\r\n      await this.connect();\r\n    }\r\n\r\n    // Reset stop flags when starting new playback\r\n    this.shouldStop = false;\r\n    this.isStreaming = false; // Ensure streaming is disabled for file playback\r\n\r\n    this.emit(\"audioStart\", filePath, \"file\");\r\n    this.emit(\"debug\", \"Starting file playback\", { filePath });\r\n\r\n    try {\r\n      const pcmData = await this.convertAudioToPCM(filePath, 48000, 1);\r\n      await this.publishPCMAudio(pcmData);\r\n\r\n      this.emit(\"audioEnd\", filePath, \"file\");\r\n      this.emit(\"debug\", \"File playback completed\", { filePath });\r\n    } catch (error) {\r\n      const errorObj =\r\n        error instanceof Error ? error : new Error(String(error));\r\n\r\n      this.emit(\"audioError\", filePath, \"file\", errorObj);\r\n      this.emit(\"error\", errorObj, \"file-playback\");\r\n\r\n      console.error(` [${this.channelId}] File playback failed:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Stop current audio playback\r\n   */\r\n  async stop(trackName?: string): Promise<void> {\r\n    // Set the stop flags to halt any ongoing playback loops\r\n    this.shouldStop = true;\r\n    this.isStreaming = false;\r\n\r\n    if (!this.room) {\r\n      return;\r\n    }\r\n\r\n    if (trackName) {\r\n      // Stop specific track\r\n      const publication = this.publications.get(trackName);\r\n      if (publication) {\r\n        try {\r\n          await this.room.localParticipant?.unpublishTrack(publication.sid!);\r\n          this.publications.delete(trackName);\r\n          this.emit(\"trackStopped\", trackName);\r\n        } catch (error) {\r\n          console.error(\r\n            ` [${this.channelId}] Failed to stop track ${trackName}:`,\r\n            error,\r\n          );\r\n        }\r\n      }\r\n    } else {\r\n      // Stop all tracks\r\n      for (const [sid, publication] of this.publications) {\r\n        try {\r\n          await this.room.localParticipant?.unpublishTrack(publication.sid!);\r\n          this.emit(\"trackStopped\", sid);\r\n        } catch (error) {\r\n          console.error(\r\n            ` [${this.channelId}] Failed to stop track ${sid}:`,\r\n            error,\r\n          );\r\n        }\r\n      }\r\n      this.publications.clear();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Disconnect from the voice channel\r\n   */\r\n  async disconnect(): Promise<void> {\r\n    if (!this.room) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      // Stop all audio tracks first\r\n      await this.stop();\r\n\r\n      // Clean up audio sources tracking\r\n      this.audioSources.clear();\r\n\r\n      // Disconnect from the room\r\n      await this.room.disconnect();\r\n\r\n      // Clean up\r\n      this.isConnected = false;\r\n      this.publications.clear();\r\n      this.room = undefined;\r\n\r\n      this.emit(\"disconnected\", this.channelId, this.serverId, \"manual\");\r\n      this.emit(\"debug\", \"Disconnected manually\");\r\n    } catch (error) {\r\n      console.error(` [${this.channelId}] Error during disconnect:`, error);\r\n      // Still clean up even if there was an error\r\n      this.isConnected = false;\r\n      this.publications.clear();\r\n      this.audioSources.clear();\r\n      this.room = undefined;\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle unexpected disconnection\r\n   * @private\r\n   */\r\n  private async handleDisconnected(): Promise<void> {\r\n    // Clean up audio sources tracking\r\n    this.audioSources.clear();\r\n\r\n    this.isConnected = false;\r\n    this.publications.clear();\r\n    this.room = undefined;\r\n\r\n    this.emit(\"disconnected\", this.channelId, this.serverId, \"unexpected\");\r\n    this.emit(\"debug\", \"Voice disconnected unexpectedly\");\r\n  }\r\n\r\n  /**\r\n   * Get player status information\r\n   */\r\n  getStatus(): {\r\n    connected: boolean;\r\n    volume: number;\r\n    activeTracksCount: number;\r\n    channelId: string;\r\n    serverId: string;\r\n  } {\r\n    return {\r\n      connected: this.connected,\r\n      volume: this._volume,\r\n      activeTracksCount: this.publications.size,\r\n      channelId: this.channelId,\r\n      serverId: this.serverId,\r\n    };\r\n  }\r\n}\r\n","import { client } from \"./client\";\r\nimport { AudioPlayer } from \"./player\";\r\n\r\n/**\r\n * VoiceClient acts as a factory for creating AudioPlayer instances.\r\n * Users manage the AudioPlayer instances themselves rather than the VoiceClient managing them internally.\r\n * This design gives users full control over their voice connections and audio playback.\r\n */\r\nexport class VoiceClient {\r\n  private readonly client: client;\r\n  /** Map of active audio players by server ID */\r\n  private readonly players: Map<string, AudioPlayer>;\r\n\r\n  constructor(client: client) {\r\n    this.client = client;\r\n    this.players = new Map();\r\n  }\r\n\r\n  /**\r\n   * Creates a new AudioPlayer instance for the specified voice channel.\r\n   *\r\n   * @param channelId - The ID of the voice channel to connect to\r\n   * @param serverId - The ID of the server containing the voice channel\r\n   * @returns A new AudioPlayer instance that the user can manage\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Create a player for a specific voice channel\r\n   * const player = client.voice.createPlayer('voice-channel-id', 'server-id');\r\n   *\r\n   * // Set up event listeners\r\n   * player.on('connected', () => {\r\n   *   console.log('Connected to voice channel!');\r\n   * });\r\n   *\r\n   * player.on('audioStart', (source, type) => {\r\n   *   console.log(`Started playing ${type}: ${source}`);\r\n   * });\r\n   *\r\n   * // Connect and play audio\r\n   * await player.connect();\r\n   * await player.playFromFile('./music.mp3');\r\n   *\r\n   * // The user is responsible for managing the player lifecycle\r\n   * await player.disconnect();\r\n   * ```\r\n   */\r\n  createPlayer(channelId: string, serverId: string): AudioPlayer {\r\n    return new AudioPlayer(channelId, serverId, this.client);\r\n  }\r\n\r\n  /**\r\n   * Creates a new AudioPlayer instance and immediately connects it to the voice channel.\r\n   * This is a convenience method that combines createPlayer() and connect().\r\n   *\r\n   * @param channelId - The ID of the voice channel to connect to\r\n   * @param serverId - The ID of the server containing the voice channel\r\n   * @returns A new connected AudioPlayer instance\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Create and connect in one step\r\n   * const player = await client.voice.connectToChannel('voice-channel-id', 'server-id');\r\n   *\r\n   * // Player is already connected and ready to use\r\n   * await player.playFromUrl('https://example.com/music.mp3');\r\n   * ```\r\n   */\r\n  async connectToChannel(\r\n    channelId: string,\r\n    serverId: string,\r\n  ): Promise<AudioPlayer> {\r\n    const player =\r\n      this.players.get(serverId) ?? this.createPlayer(channelId, serverId);\r\n    this.players.set(serverId, player);\r\n    await player.connect(channelId);\r\n    return player;\r\n  }\r\n\r\n  /**\r\n   * Disconnects the AudioPlayer from the specified server.\r\n   *\r\n   * @param serverId - The ID of the server to disconnect from\r\n   */\r\n  async disconnectFromChannel(serverId: string): Promise<void> {\r\n    const player = this.players.get(serverId);\r\n    if (player) {\r\n      await player.disconnect();\r\n      this.players.delete(serverId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Stops the AudioPlayer in the specified server.\r\n   *\r\n   * @param serverId - The ID of the server whose player should be stopped\r\n   */\r\n  async stopPlayerInChannel(serverId: string): Promise<void> {\r\n    const player = this.players.get(serverId);\r\n    if (player) {\r\n      await player.stop();\r\n    }\r\n  }\r\n}\r\n","import { NotesChannel, Status, User } from \"./index\";\r\nimport type { User as APIUser } from \"revolt-api\";\r\nimport { client } from \"../client/client\";\r\nimport { stat } from \"node:fs\";\r\n\r\n/**\r\n * Represents the client user, which is the authenticated user or bot.\r\n *\r\n * @extends User\r\n */\r\nexport class ClientUser extends User {\r\n  /** The notes channel associated with the client user, if any. */\r\n  notes: NotesChannel | null = null;\r\n\r\n  owner: string | null = null;\r\n\r\n  constructor(client: client, data: APIUser) {\r\n    super(client, data);\r\n    this._patch(data);\r\n    this.owner = data.bot?.owner || null;\r\n  }\r\n  /**\r\n   * Updates the username of the client user.\r\n   *\r\n   * @param {string} username - The new username to set.\r\n   * @param {string} [password] - The current password of the user (required for non-bot accounts).\r\n   * @returns {Promise<void>} A promise that resolves when the username has been successfully updated.\r\n   * @throws {Error} Throws an error if the client user is a bot and a password is provided.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * await clientUser.setUsername(\"NewUsername\", \"CurrentPassword\");\r\n   * ```\r\n   */\r\n  async setUsername(username: string, password?: string): Promise<void> {\r\n    if (this.bot && password) {\r\n      throw new Error(\"Bots do not have passwords\");\r\n    }\r\n\r\n    await this.client.api.patch(\"/users/@me/username\", {\r\n      body: { username, password },\r\n    });\r\n  }\r\n\r\n  async setStatus(text?: string | null): Promise<void>;\r\n  async setStatus(presence?: Status): Promise<void>;\r\n  /**\r\n   * Updates the status of the client user.\r\n   *\r\n   * @param {string | null} [text] - The status text to set, or `null` to clear the status.\r\n   * @param {Status} [presence] - The presence status (e.g., online, idle, etc.).\r\n   * @returns {Promise<void>} A promise that resolves when the status has been successfully updated.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * await clientUser.setStatus(\"Available\", \"Online\");\r\n   * ```\r\n   */\r\n  async setStatus(\r\n    text?: string | null,\r\n    presence?: keyof typeof Status,\r\n  ): Promise<void>;\r\n  async setStatus(text?: unknown, presence?: unknown): Promise<void> {\r\n    // If 'text' is a valid key of Status, treat it as presence\r\n    if (typeof text === \"string\" && text in Status && !presence) {\r\n      presence = text as keyof typeof Status;\r\n      text = undefined;\r\n    }\r\n    const status = {\r\n      text: text ?? this.client.user?.presence.text,\r\n      presence: presence ?? this.client.user?.presence.status,\r\n    };\r\n    await this.client.api.patch(`/users/${this.client.user?.id}`, {\r\n      body: { status: status },\r\n    });\r\n  }\r\n}\r\n","import { time } from \"node:console\";\r\nimport { ClientUser } from \"../struct/clientUser\";\r\nimport { Emoji } from \"../struct/emoji\";\r\nimport { Events, WSEvents } from \"../utils/constants\";\r\nimport { client } from \"./client\";\r\n\r\ndeclare function setInterval(\r\n  cb: (...args: any[]) => void,\r\n  delay?: number,\r\n  ...args: any[]\r\n): number;\r\n\r\n/**\r\n * Represents the WebSocket client used for real-time communication with the API.\r\n */\r\nexport class WebSocketClient {\r\n  /** The interval for sending heartbeats, in milliseconds. */\r\n  heartbeatInterval?: number;\r\n\r\n  /** The timestamp of the last ping sent, in milliseconds. */\r\n  lastPingTimestamp?: number;\r\n\r\n  /** Whether the last pong acknowledgment was received. */\r\n  lastPongAck?: boolean = false;\r\n\r\n  /** The WebSocket connection instance. */\r\n  socket?: WebSocket | null;\r\n\r\n  /** Whether the WebSocket client is connected. */\r\n  connected: boolean = false;\r\n\r\n  /** A promise representing the reconnecting process, or `null` if not reconnecting. */\r\n  reconnecting: Promise<unknown> | null = null;\r\n\r\n  /** Whether the WebSocket client is ready. */\r\n  ready = false;\r\n\r\n  /** The number of reconnection attempts made. */\r\n  retryCount: number = 0;\r\n\r\n  /**\r\n   * Creates a new WebSocketClient instance.\r\n   *\r\n   * @param {client} client - The client instance.\r\n   */\r\n  constructor(protected readonly client: client) {}\r\n\r\n  /**\r\n   * Logs a debug message.\r\n   *\r\n   * @param {unknown} message - The message to log.\r\n   * @private\r\n   */\r\n  private debug(message: unknown): void {\r\n    this.client.debug(`[WS] ${message}`);\r\n  }\r\n\r\n  /**\r\n   * Sends data through the WebSocket connection.\r\n   *\r\n   * @param {unknown} data - The data to send.\r\n   * @returns {Promise<void>} A promise that resolves when the data is sent.\r\n   * @throws {Error} Throws an error if the WebSocket is not open.\r\n   */\r\n  async send(data: unknown): Promise<void> {\r\n    if (this.reconnecting) {\r\n      this.debug(\"Reconnecting, waiting to send message.\");\r\n      await this.reconnecting;\r\n    }\r\n    if (this.socket?.readyState === WebSocket.OPEN) {\r\n      this.socket.send(JSON.stringify(data));\r\n    } else {\r\n      this.debug(\"Socket is not open, cannot send message.\");\r\n      throw new Error(\"Socket is not open\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handles the WebSocket connection opening.\r\n   *\r\n   * @private\r\n   */\r\n  private onOpen(): void {\r\n    if (!this.client.token) throw new Error(\"Token is required\");\r\n    this.send({\r\n      type: WSEvents.AUTHENTICATE,\r\n      token: this.client.token,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Gets the current ping (latency) of the WebSocket connection.\r\n   *\r\n   * @returns {number} The ping in milliseconds, or `-0` if the WebSocket is not connected.\r\n   */\r\n  get ping(): number {\r\n    if (!this.socket) return -0;\r\n    return Date.now() - this.lastPingTimestamp!;\r\n  }\r\n\r\n  /**\r\n   * Sets the heartbeat interval for the WebSocket connection.\r\n   *\r\n   * @param {number} time - The interval time in milliseconds. Use `-1` to clear the interval.\r\n   */\r\n  setHeartbeatTimer(time: number): void {\r\n    this.debug(`Setting a heartbeat interval for ${time}ms.`);\r\n    if (this.heartbeatInterval) {\r\n      clearInterval(this.heartbeatInterval);\r\n    }\r\n    if (time !== -1) {\r\n      this.heartbeatInterval = setInterval(() => this.sendHeartbeat(), time);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sends a heartbeat to the server to keep the connection alive.\r\n   */\r\n  sendHeartbeat(): void {\r\n    this.debug(\"Sending heartbeat.\");\r\n\r\n    if (!this.lastPongAck) {\r\n      this.debug(\"Did not receive a pong ack.\");\r\n      if (this.client.options.ws?.reconnect) {\r\n        this.reconnecting = this.destroy()\r\n          .then(() => this.connect())\r\n          .then(() => (this.reconnecting = null));\r\n      }\r\n    }\r\n    const now = Date.now();\r\n    this.send({ type: WSEvents.PING, data: now });\r\n    this.lastPongAck = false;\r\n    this.lastPingTimestamp = now;\r\n  }\r\n\r\n  /**\r\n   * Handles WebSocket errors.\r\n   *\r\n   * @param {unknown} event - The error event.\r\n   * @private\r\n   */\r\n  private onError(event: unknown): void {\r\n    this.client.emit(Events.ERROR, event);\r\n  }\r\n\r\n  /**\r\n   * Handles incoming WebSocket messages.\r\n   *\r\n   * @param {{ data: unknown }} param0 - The message event containing the data.\r\n   * @private\r\n   */\r\n  private onMessage({ data }: { data: unknown }): void {\r\n    let packet: unknown;\r\n    try {\r\n      packet = JSON.parse(String(data));\r\n    } catch (err) {\r\n      this.client.emit(Events.ERROR, err);\r\n      return;\r\n    }\r\n\r\n    this.client.emit(Events.RAW, packet);\r\n\r\n    this.onPacket(packet).catch((e) => this.client.emit(Events.ERROR, e));\r\n  }\r\n\r\n  /**\r\n   * Handles the WebSocket connection closing.\r\n   *\r\n   * @param {{ code: number; reason: string }} event - The close event containing the code and reason.\r\n   * @private\r\n   */\r\n  private onClose(event: { code: number; reason: string }): void {\r\n    this.debug(`Closed with reason: ${event.reason}, code: ${event.code}`);\r\n    this.destroy();\r\n  }\r\n\r\n  /**\r\n   * Handles incoming WebSocket packets.\r\n   *\r\n   * @param {any} packet - The packet data.\r\n   * @private\r\n   */\r\n  private async onPacket(packet: any) {\r\n    if (!packet) {\r\n      this.debug(`Received broken packet: '${packet}'.`);\r\n      return;\r\n    }\r\n\r\n    switch (packet.type) {\r\n      case WSEvents.BULK:\r\n        await Promise.all(packet.v.map((p: unknown) => this.onPacket(p)));\r\n        break;\r\n      case WSEvents.AUTHENTICATED:\r\n        this.connected = true;\r\n        this.retryCount = 0;\r\n        this.debug(`Successfully authenticated.`);\r\n        break;\r\n      case WSEvents.PONG:\r\n        this.debug(`Received a heartbeat.`);\r\n        this.lastPongAck = true;\r\n        break;\r\n      case WSEvents.ERROR:\r\n        this.client.emit(Events.ERROR, packet.error);\r\n        break;\r\n      case WSEvents.READY: {\r\n        this.lastPongAck = true;\r\n\r\n        const promises: Promise<unknown>[] = [];\r\n\r\n        for (const user of packet.users) {\r\n          if (user.relationship === \"User\" && !this.client.user) {\r\n            this.client.user = new ClientUser(this.client, user);\r\n          } else {\r\n            this.client.users._add(user);\r\n          }\r\n        }\r\n\r\n        for (const member of packet.members) {\r\n          this.client.servers.cache\r\n            .get(member._id.server)\r\n            ?.members._add(member);\r\n        }\r\n\r\n        for (const emoji of packet.emojis) {\r\n          this.client.servers.cache\r\n            .get(emoji.parent.id)\r\n            ?.emojis.set(emoji._id, { ...emoji, _id: emoji._id });\r\n        }\r\n\r\n        for (const channel of packet.channels) {\r\n          this.client.channels._add(channel);\r\n        }\r\n\r\n        for (const server of packet.servers) {\r\n          const s = this.client.servers._add(server);\r\n          if (this.client.options.fetchMembers) {\r\n            promises.push(s.members.fetch());\r\n          }\r\n        }\r\n\r\n        this.setHeartbeatTimer(\r\n          this.client.options.ws?.heartbeatInterval ?? 30000,\r\n        );\r\n\r\n        await Promise.all(promises);\r\n\r\n        for (const voice_state of packet.voice_states) {\r\n          const channel = this.client.channels.cache.get(voice_state.id);\r\n          for (const participant of voice_state.participants) {\r\n            channel?.voice?.set(participant.id, participant);\r\n          }\r\n        }\r\n\r\n        this.ready = true;\r\n\r\n        this.client.emit(Events.READY, this.client);\r\n        break;\r\n      }\r\n      default: {\r\n        const action = this.client.events.get(packet.type);\r\n        if (action) {\r\n          await action.handle(packet);\r\n        } else {\r\n          this.debug(`Received unknown packet \"${packet.type}\"`);\r\n        }\r\n\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Connects to the WebSocket server.\r\n   *\r\n   * @returns {Promise<this>} A promise that resolves when the connection is established.\r\n   */\r\n  connect(): Promise<this> {\r\n    this.retryCount = this.retryCount + 1;\r\n    if (this.retryCount > 10) {\r\n      this.debug(\"Max retry attempts reached\");\r\n      return Promise.reject(\r\n        new Error(\r\n          \"Max retry attempts reached on WS connection, try again later.\",\r\n        ),\r\n      );\r\n    }\r\n    return new Promise(async (resolve) => {\r\n      if (this.socket?.readyState === WebSocket.OPEN && this.ready) {\r\n        return resolve(this);\r\n      }\r\n\r\n      if (typeof this.client.options === \"undefined\") {\r\n        throw new Error(\"MISSING_CONFIGURATION_SYNC\");\r\n      }\r\n\r\n      if (typeof this.client.token !== \"string\") {\r\n        throw new Error(\"INVALID_TOKEN\");\r\n      }\r\n\r\n      await this.client.init();\r\n\r\n      if (!this.client.options.ws?.instanceURL)\r\n        return Promise.reject(new Error(\"WebSocket instance URL not set.\"));\r\n      const ws = (this.socket =\r\n        this.socket ?? new WebSocket(this.client.options.ws?.instanceURL));\r\n\r\n      ws.onopen = this.onOpen.bind(this);\r\n      ws.onmessage = this.onMessage.bind(this);\r\n      ws.onerror = this.onError.bind(this);\r\n      ws.onclose = this.onClose.bind(this);\r\n      ws.addEventListener(\"open\", () => resolve(this));\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Destroys the WebSocket connection and clears its state.\r\n   *\r\n   * @returns {Promise<void>} A promise that resolves when the connection is destroyed.\r\n   */\r\n  destroy(isUserInitiated?: boolean): Promise<void> {\r\n    return new Promise((resolve) => {\r\n      this.setHeartbeatTimer(-1);\r\n      this.connected = false;\r\n      this.ready = false;\r\n\r\n      if (this.socket?.readyState === WebSocket.OPEN) {\r\n        this.socket.addEventListener(\"close\", () => {\r\n          this.socket = null;\r\n          if (!isUserInitiated) {\r\n            setTimeout(() => this.connect(), 1000);\r\n          }\r\n          resolve();\r\n        });\r\n\r\n        this.socket.close();\r\n        if (!isUserInitiated) {\r\n          setTimeout(() => this.connect(), 1000);\r\n        }\r\n      } else {\r\n        this.socket = null;\r\n        if (!isUserInitiated) {\r\n          setTimeout(() => this.connect(), 1000);\r\n        }\r\n        resolve();\r\n      }\r\n    });\r\n  }\r\n}\r\n","import { ChannelManager, ServerManager } from \"../managers\";\r\nimport { UserManager } from \"../managers/userManager\";\r\nimport { WebhookManager } from \"../managers/webhookManager\";\r\nimport { ClientUser } from \"../struct/clientUser\";\r\nimport { BaseClient } from \"./baseClient\";\r\nimport { EventManager } from \"./events/eventManager\";\r\nimport { VoiceClient } from \"./voiceClient\";\r\nimport { WebSocketClient } from \"./webSocket\";\r\n\r\n/**\r\n * Represents the main client for interacting with the API.\r\n *\r\n * @extends BaseClient\r\n */\r\nexport class client extends BaseClient {\r\n  /** The WebSocket client used for real-time communication. */\r\n  protected readonly ws = new WebSocketClient(this);\r\n\r\n  /** Manages the channels in the client. */\r\n  readonly channels = new ChannelManager(this);\r\n\r\n  /** Manages the servers in the client. */\r\n  readonly servers = new ServerManager(this);\r\n\r\n  /** Manages the users in the client. */\r\n  readonly users = new UserManager(this);\r\n\r\n  /** Manages the events in the client. */\r\n  readonly events = new EventManager(this);\r\n\r\n  /** Manages the webhooks in the client. */\r\n  readonly webhooks = new WebhookManager(this);\r\n\r\n  /** Manages the voice connections in the client. */\r\n  readonly voice = new VoiceClient(this);\r\n\r\n  /** The authenticated user, or `null` if not logged in. */\r\n  user: ClientUser | null = null;\r\n\r\n  /** The timestamp when the client became ready, or `null` if not ready. */\r\n  readyAt: Date | null = null;\r\n\r\n  /**\r\n   * Initializes the client.\r\n   * @private\r\n   */\r\n  async init(): Promise<void> {\r\n    this.debug(\"Initializing client...\");\r\n    if (process.env.NODE_ENV === \"DEV\") {\r\n      console.info(\r\n        \"Development mode enabled: displaying additional debug info.\",\r\n      );\r\n    }\r\n    await this.api.getConfig();\r\n  }\r\n\r\n  /**\r\n   * Gets the timestamp when the client became ready.\r\n   *\r\n   * @returns {number | null} The ready timestamp in milliseconds, or `null` if not ready.\r\n   */\r\n  get readyTimestamp(): number | null {\r\n    return this.readyAt ? this.readyAt.getTime() : null;\r\n  }\r\n\r\n  /**\r\n   * Gets the uptime of the client in milliseconds.\r\n   *\r\n   * @returns {number | null} The uptime in milliseconds, or `null` if the client is not ready.\r\n   */\r\n  get upTime(): number | null {\r\n    return this.readyAt ? Date.now() - this.readyAt.getTime() : null;\r\n  }\r\n\r\n  /**\r\n   * Logs the client into the API using the provided token.\r\n   *\r\n   * @param {string} token - The authentication token.\r\n   * @returns {Promise<void>} A promise that resolves when the client is logged in.\r\n   * @throws {Error} Throws an error if the token is not provided or if the WebSocket connection fails.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * await client.login(\"your-token-here\");\r\n   * ```\r\n   */\r\n  async login(token: string): Promise<void> {\r\n    if (!token) throw new Error(\"Token is required\");\r\n\r\n    this.token = token;\r\n\r\n    this.debug(\"Logging in...\");\r\n    try {\r\n      await this.ws.connect();\r\n    } catch (error) {\r\n      this.debug(`Error connecting to WebSocket: ${error}`);\r\n      throw error;\r\n    }\r\n\r\n    this.readyAt = new Date();\r\n  }\r\n\r\n  /**\r\n   * Destroys the client, disconnecting it from the API and clearing its state.\r\n   *\r\n   * @returns {Promise<void>} A promise that resolves when the client is destroyed.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * await client.destroy();\r\n   * ```\r\n   */\r\n  async destroy(): Promise<void> {\r\n    this.token = null;\r\n    this.user = null;\r\n    this.readyAt = null;\r\n    await this.ws.destroy(true);\r\n  }\r\n\r\n  /**\r\n   * Checks if the client is ready.\r\n   *\r\n   * @returns {boolean} `true` if the client is ready, otherwise `false`.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * if (client.isReady()) {\r\n   *   console.log(\"Client is ready!\");\r\n   * }\r\n   * ```\r\n   */\r\n  isReady(): boolean {\r\n    return this.readyAt !== null;\r\n  }\r\n}\r\n"],"mappings":"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","names":["client","client","Events","WSEvents","ChannelTypes","client","client","client","Status","Server","client","DMChannel","client","GroupChannel","client","client","File","client","File","client","client","ServerMember","client","TextChannel","client","VoiceChannel","client","Emoji","client","VoiceChannel","TextChannel","DMChannel","GroupChannel","channel","Server","id","server","user","File","Readable","FormData","axios","FormData","axios","Readable","File","Emoji","TextChannel","VoiceChannel","channel","ServerMember","member","Readable","axios","FormData","client","FormData","axios","Readable","axios","axios","axios","client","axios","_a","_b","AxiosError","client","AxiosError","_a","_b","client","client","Event","Readable","EventEmitter","EventEmitter","client","Readable","source","resolve","client","client","client","client"]}